<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Awk命令的使用</title>
    <url>/2020/01/10/Awk%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Awk命令的使用"><a href="#Awk命令的使用" class="headerlink" title="Awk命令的使用"></a>Awk命令的使用</h1><blockquote>
<p>The awk utility shall execute programs written in the  awk  programming<br>      language,  which  is  specialized for textual data manipulation. An awk<br>      program is a sequence of patterns and corresponding actions. When input<br>      is read that matches a pattern, the action associated with that pattern<br>      is carried out.</p>
</blockquote>
<a id="more"></a>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk '&#123;pattern + action&#125;' &#123;filenames&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>pattern 表示 AWK 在数据中查找的内容</li>
<li>action 是在找到匹配内容时所执行的一系列命令。花括号（{}）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 </li>
<li>pattern就是要表示的正则表达式，用斜杠括起来。</li>
</ul>
<p>awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。</p>
<p>通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'&#123; print $0 &#125;'</span> /etc/passwd      </span></span><br><span class="line">root:x:0:0::/root:/bin/bash</span><br><span class="line">nobody:x:65534:65534:Nobody:/:/usr/bin/nologin</span><br><span class="line">dbus:x:81:81:System Message Bus:/:/usr/bin/nologin</span><br><span class="line">bin:x:1:1::/:/usr/bin/nologin</span><br><span class="line">daemon:x:2:2::/:/usr/bin/nologin</span><br><span class="line">mail:x:8:12::/var/spool/mail:/usr/bin/nologin</span><br><span class="line">ftp:x:14:11::/srv/ftp:/usr/bin/nologin</span><br><span class="line">http:x:33:33::/srv/http:/usr/bin/nologin</span><br></pre></td></tr></table></figure>
<p>调用 awk时，我们指定/etc/passwd 作为输入文件。执行 awk 时，它依次对/etc/passwd 中的每一行执行 print 命令。</p>
<p><img src="/images/awk_format.jpg" alt="&#39;awk 格式&#39;"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> awk -F<span class="string">":"</span> <span class="string">'&#123; print $1 &#125;'</span> /etc/passwd</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk -F<span class="string">":"</span> <span class="string">'&#123; print $1 $3 &#125;'</span> /etc/passwd</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk -F<span class="string">":"</span> <span class="string">'&#123; print $1 " " $3 &#125;'</span> /etc/passwd</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk -F<span class="string">":"</span> <span class="string">'&#123; print "username: " $1 "\t\tuid:" $3" &#125;'</span> /etc/passwd</span></span><br></pre></td></tr></table></figure>
<p><code>-F</code>参数：指定分隔符，可指定一个或多个</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> awk -F<span class="string">":"</span> <span class="string">'&#123; if (NR &gt; 5 &amp;&amp; NR &lt;= 10) print $1 &#125;'</span> /etc/passwd</span></span><br><span class="line">mail</span><br><span class="line">ftp</span><br><span class="line">http</span><br><span class="line">systemd-journal-remote</span><br><span class="line">systemd-network</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">awk -F '[ ,]+' '&#123;print $3" "$7&#125;' test.txt</span><br></pre></td></tr></table></figure>
<p>统计<code>/etc/passwd</code>的账户人数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'&#123;count++&#125; END&#123; print "user count is",count&#125;'</span> /etc/passwd</span></span><br><span class="line">user count is 30</span><br></pre></td></tr></table></figure>
<p>统计某个文件夹下的文件占用的字节数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l | awk <span class="string">'BEGIN&#123;size=0;&#125; &#123;size=size+$5&#125; END&#123;print "[end]size is",size&#125;'</span></span></span><br><span class="line">[end]size is 36268220</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -l | awk <span class="string">'BEGIN&#123;size=0;&#125; &#123;size=size+$5&#125; END&#123;print "[end]size is",size/1024/1024,"M"&#125;'</span></span></span><br><span class="line">[end]size is 34.5881 M</span><br></pre></td></tr></table></figure>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>= += -= <em>= /= %= ^= *</em>=</td>
<td>赋值语句</td>
</tr>
<tr>
<td>\</td>
<td>\</td>
<td>&amp;&amp;</td>
<td>逻辑运算符</td>
</tr>
<tr>
<td>~  !~</td>
<td>正则运算符</td>
</tr>
<tr>
<td>&lt; &lt;= &gt; &gt;= != ==</td>
<td>关系运算符</td>
</tr>
<tr>
<td>+ - * / &amp; ++ — ！</td>
<td>算术运算符 &amp;求余</td>
</tr>
<tr>
<td>$ ?: 空格 ln</td>
<td>其他运算符</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'BEGIN&#123;a=5;a+=5;print a&#125;'</span>                                         </span></span><br><span class="line">10</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'BEGIN&#123;a=1;b=2; print (a&gt;1&amp;&amp;b==2,a&gt;=0 || b&gt;1)&#125;'</span></span></span><br><span class="line">0 1</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'BEGIN&#123;a="1234gwx";if(a~/4g/) &#123;print "ok"&#125;&#125;'</span>   </span></span><br><span class="line">ok</span><br></pre></td></tr></table></figure>
<h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><div class="table-container">
<table>
<thead>
<tr>
<th>变量名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>$0</td>
<td>当前记录</td>
</tr>
<tr>
<td>$1-$n</td>
<td>当前记录的第n个字段</td>
</tr>
<tr>
<td>FS</td>
<td>输入字段分隔符，默认空格</td>
</tr>
<tr>
<td>RS</td>
<td>输入记录分隔符，默认换行符</td>
</tr>
<tr>
<td>NF</td>
<td>当前记录的字段数目</td>
</tr>
<tr>
<td>NR</td>
<td>以及读出记录数，从1开始</td>
</tr>
<tr>
<td>OFS</td>
<td>输出字段分隔符</td>
</tr>
<tr>
<td>ORS</td>
<td>输出记录分隔符</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'BEGIN&#123;FS=":"&#125;&#123;print $1 &#125;'</span> /etc/passwd      </span></span><br><span class="line">root</span><br><span class="line">nobody</span><br><span class="line">dbus</span><br><span class="line">bin</span><br><span class="line">daemon</span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'BEGIN&#123;FS=":";OFS="#";ORS="\\\n"&#125;&#123;print $1,$2&#125;'</span> /etc/passwd</span></span><br><span class="line"><span class="meta">root#</span><span class="bash">x\</span></span><br><span class="line"><span class="meta">nobody#</span><span class="bash">x\</span></span><br><span class="line"><span class="meta">dbus#</span><span class="bash">x\</span></span><br><span class="line"><span class="meta">bin#</span><span class="bash">x\</span></span><br><span class="line"><span class="meta">daemon#</span><span class="bash">x\</span></span><br><span class="line"><span class="meta">mail#</span><span class="bash">x\</span></span><br></pre></td></tr></table></figure>
<h2 id="其他表达式"><a href="#其他表达式" class="headerlink" title="其他表达式"></a>其他表达式</h2><ol>
<li><p>规则表达式<code>awk &#39;/REG/{action} &#39; file</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> awk -F: <span class="string">'$1~/root/&#123;print $0&#125;'</span> /etc/passwd</span></span><br><span class="line">root:x:0:0::/root:/bin/bash</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>布尔表达式<code>awk &#39;布尔表达式{action}&#39; file</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> awk -F: <span class="string">'$1=="root"&#123;print $0&#125;'</span> /etc/passwd</span></span><br><span class="line">root:x:0:0::/root:/bin/bash</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="awk-的-if、循环和数组"><a href="#awk-的-if、循环和数组" class="headerlink" title="awk 的 if、循环和数组"></a>awk 的 if、循环和数组</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>.</span><br><span class="line">&#123;</span><br><span class="line">　　<span class="keyword">if</span> ( <span class="variable">$0</span> !~ <span class="regexp">/matchme/</span> ) &#123;</span><br><span class="line">　　　　print <span class="variable">$1</span> <span class="variable">$3</span> <span class="variable">$4</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span>.</span><br><span class="line">&#123;</span><br><span class="line">    count=<span class="number">1</span><span class="keyword">do</span> &#123;</span><br><span class="line">        print <span class="string">"I get printed at least once no matter what"</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ( count !=<span class="number">1</span> )</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span>.</span><br><span class="line"><span class="keyword">for</span> ( initial assignment; comparison; increment ) &#123;</span><br><span class="line">    code block</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>.</span><br><span class="line">x=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">　　print <span class="string">"iteration"</span>, x</span><br><span class="line">　　<span class="keyword">if</span> ( x==<span class="number">10</span> ) &#123;</span><br><span class="line">　　　　<span class="keyword">break</span></span><br><span class="line">　　&#125;</span><br><span class="line">　　x++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>.</span><br><span class="line">&#123;</span><br><span class="line">    cities[<span class="number">1</span>]=”beijing”</span><br><span class="line">    cities[<span class="number">2</span>]=”shanghai”</span><br><span class="line">    cities[“three”]=”guangzhou”</span><br><span class="line">    <span class="keyword">for</span>( c <span class="keyword">in</span> cities) &#123;</span><br><span class="line">        print cities[c]</span><br><span class="line">    &#125;</span><br><span class="line">    print cities[<span class="number">1</span>]</span><br><span class="line">    print cities[“<span class="number">1</span>”]</span><br><span class="line">    print cities[“three”]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 awk 中查看服务器连接状态并汇总</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> netstat -an|awk <span class="string">'/^tcp/&#123;++s[$NF]&#125;END&#123;for(a in s)print a,s[a]&#125;'</span></span></span><br><span class="line"></span><br><span class="line">LISTEN 8</span><br><span class="line">ESTABLISHED 8</span><br><span class="line">SYN_SENT 3</span><br></pre></td></tr></table></figure>
<h2 id="常用字符串函数"><a href="#常用字符串函数" class="headerlink" title="常用字符串函数"></a>常用字符串函数</h2><p><img src="/images/awk_string_func.jpg" alt=""></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'BEGIN&#123;info="this is a test2010test!";gsub(/[0-9]+/,"!",info);print info&#125;'</span></span></span><br><span class="line">this is a test!test!</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'BEGIN&#123;info="this is a test2010test!";print index(info,"test")?"ok":"no found";&#125;'</span></span></span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">awk 'BEGIN&#123;info="this is a test2010test!";print match(info,/[0-9]+/)?"ok":"no found";&#125;'</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line">awk 'BEGIN&#123;info="this is a test2010test!";print substr(info,4,10);&#125;'</span><br><span class="line">s is a tes</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">'BEGIN&#123;info="this is a test";split(info,tA," ");print length(tA);for(k in tA)&#123;print k,tA[k];&#125;&#125;'</span></span></span><br><span class="line">4</span><br><span class="line">1 this</span><br><span class="line">2 is</span><br><span class="line">3 a</span><br><span class="line">4 test</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/ginvip/p/6352157.html" target="_blank" rel="noopener">https://www.cnblogs.com/ginvip/p/6352157.html</a></p>
]]></content>
      <categories>
        <category>技能</category>
      </categories>
  </entry>
  <entry>
    <title>C++快速教程</title>
    <url>/2019/11/02/CPP%E5%BF%AB%E9%80%9F%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="The-Tutorial-about-C"><a href="#The-Tutorial-about-C" class="headerlink" title="The Tutorial about C++"></a>The Tutorial about C++</h1><a id="more"></a>
<h2 id="Part-One"><a href="#Part-One" class="headerlink" title="Part One"></a>Part One</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This is a comment</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Multi-line comment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Tells the compiler iostream library which contains the function cout</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allows us to use vectors</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allows us to use strings</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow us to work with files</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allows functions in the std namespace to be used without their prefix</span></span><br><span class="line"><span class="comment">// std::cout becomes cout</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------- FUNCTIONS ----------</span></span><br><span class="line"><span class="comment">// The function has return type, function name and attributes with </span></span><br><span class="line"><span class="comment">// their data types</span></span><br><span class="line"><span class="comment">// The attribute data types must match the value passed in</span></span><br><span class="line"><span class="comment">// This data is passed by value</span></span><br><span class="line"><span class="comment">// You can define default values to attributes as long as they come last</span></span><br><span class="line"><span class="comment">// This is known as a function prototype</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addNumbers</span><span class="params">(<span class="keyword">int</span> firstNum, <span class="keyword">int</span> secondNum = <span class="number">0</span>)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> combinedValue = firstNum + secondNum;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> combinedValue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An overloaded function has the same name, but different attributes</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addNumbers</span><span class="params">(<span class="keyword">int</span> firstNum, <span class="keyword">int</span> secondNum, <span class="keyword">int</span> thirdNum)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> firstNum + secondNum + thirdNum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A recursive function is one that calls itself</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFactorial</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> sum;</span><br><span class="line">	<span class="keyword">if</span>(number == <span class="number">1</span>) sum = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> sum = (getFactorial(number - <span class="number">1</span>) * number);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// getFactorial(2) [Returns 2] * 3</span></span><br><span class="line">	<span class="comment">// getFactorial(1) [Returns 1] * 2 &lt;This value goes above&gt;</span></span><br><span class="line">	<span class="comment">// 2 * 3 = 6</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Doesn't have a return type so use void</span></span><br><span class="line"><span class="comment">// Since I'm getting a pointer use int*</span></span><br><span class="line"><span class="comment">// Refer to the referenced variable with *age</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeMeYoung</span><span class="params">(<span class="keyword">int</span>* age)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"I used to be "</span> &lt;&lt; *age &lt;&lt; <span class="built_in">endl</span>;	</span><br><span class="line">	*age = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A function that receives a reference can manipulate the value globally</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">actYourAge</span><span class="params">(<span class="keyword">int</span>&amp; age)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	age = <span class="number">39</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------- END OF FUNCTIONS ----------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------- CLASSES ----------</span></span><br><span class="line"><span class="comment">// classes start with the name class</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// private variables are only available to methods in the class</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">	<span class="keyword">int</span> weight;</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A static variable shares the same value with every object in the class</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> numOfAnimals;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Public variables can be accessed by anything with access to the object</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="built_in">height</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> weight;&#125;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">getName</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> cm)</span></span>&#123; <span class="built_in">height</span> = cm; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> kg)</span></span>&#123; weight = kg; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="built_in">string</span> dogName)</span></span>&#123; name = dogName; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Declared as a prototype</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setAll</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="built_in">string</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Declare the constructor</span></span><br><span class="line">	Animal(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Declare the deconstructor</span></span><br><span class="line">	~Animal();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// An overloaded constructor called when no data is passed</span></span><br><span class="line">	Animal();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// protected members are available to members of the same class and </span></span><br><span class="line">	<span class="comment">// sub classes</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Static methods aren't attached to an object and can only access</span></span><br><span class="line">	<span class="comment">// static member variables</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNumOfAnimals</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> numOfAnimals; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This method will be overwritten in Dog</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Animal::numOfAnimals = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the protoype method setAll</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Animal::setAll</span><span class="params">(<span class="keyword">int</span> <span class="built_in">height</span>, <span class="keyword">int</span> weight, <span class="built_in">string</span> name)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This is used to refer to an object created of this class type</span></span><br><span class="line">	<span class="keyword">this</span> -&gt; <span class="built_in">height</span> = <span class="built_in">height</span>;</span><br><span class="line">	<span class="keyword">this</span> -&gt; weight = weight;</span><br><span class="line">	<span class="keyword">this</span> -&gt; name = name;</span><br><span class="line">	Animal::numOfAnimals++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A constructor is called when an object is created</span></span><br><span class="line">Animal::Animal(<span class="keyword">int</span> <span class="built_in">height</span>, <span class="keyword">int</span> weight, <span class="built_in">string</span> name) &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span> -&gt; <span class="built_in">height</span> = <span class="built_in">height</span>;</span><br><span class="line">	<span class="keyword">this</span> -&gt; weight = weight;</span><br><span class="line">	<span class="keyword">this</span> -&gt; name = name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The destructor is called when an object is destroyed</span></span><br><span class="line">Animal::~Animal() &#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Animal "</span> &lt;&lt; <span class="keyword">this</span> -&gt; name &lt;&lt; <span class="string">" destroyed"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A constructor called when no attributes are passed</span></span><br><span class="line">Animal::Animal() &#123;</span><br><span class="line">	numOfAnimals++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This method prints object info to screen and will be overwritten</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Animal::toString</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> -&gt; name &lt;&lt; <span class="string">" is "</span> &lt;&lt; <span class="keyword">this</span> -&gt; <span class="built_in">height</span> &lt;&lt; <span class="string">" cms tall and "</span></span><br><span class="line">		&lt;&lt; <span class="keyword">this</span> -&gt; weight &lt;&lt; <span class="string">" kgs in weight"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We can inherit the variables and methods of other classes</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="built_in">string</span> sound = <span class="string">"Woof"</span>;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">getSound</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; sound &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Declare the constructor</span></span><br><span class="line">		Dog(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="built_in">string</span>, <span class="built_in">string</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Declare the default constructor and call the default superclass</span></span><br><span class="line">		<span class="comment">// constructor</span></span><br><span class="line">		Dog() : Animal()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Overwrite toString</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog constructor passes the right attributes to the superclass</span></span><br><span class="line"><span class="comment">// constructor and then handles the attribute bark that remains</span></span><br><span class="line">Dog::Dog(<span class="keyword">int</span> <span class="built_in">height</span>, <span class="keyword">int</span> weight, <span class="built_in">string</span> name, <span class="built_in">string</span> bark) : </span><br><span class="line">Animal(<span class="built_in">height</span>, weight, name)&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">this</span> -&gt; sound = bark;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// toString method overwritten</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dog::toString</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Because the attributes were private in Animal they must be retrieved </span></span><br><span class="line">	<span class="comment">// by called the get methods</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> -&gt; getName() &lt;&lt; <span class="string">" is "</span> &lt;&lt; <span class="keyword">this</span> -&gt; getHeight() &lt;&lt; </span><br><span class="line">		<span class="string">" cms tall and "</span> &lt;&lt; <span class="keyword">this</span> -&gt; getWeight() &lt;&lt; <span class="string">" kgs in weight and says "</span> &lt;&lt; </span><br><span class="line">		<span class="keyword">this</span> -&gt; sound &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------- END OF CLASSES ----------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// This is where execution begins. Attributes can be sent to main</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// cout outputs text and a carriage return with endl</span></span><br><span class="line">	<span class="comment">// Statements must end with a semicolon</span></span><br><span class="line">	<span class="comment">// Strings must be surrounded by "</span></span><br><span class="line">	<span class="comment">// &lt;&lt; sends the text via standard output to the screen</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello Internet"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- VARIABLES / DATA TYPES ----------</span></span><br><span class="line">	<span class="comment">// Variables start with a letter and can contain letters, numbers and _</span></span><br><span class="line">	<span class="comment">// They are case sensitive</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// A value that won't change is a constant</span></span><br><span class="line">	<span class="comment">// Starts with const and it should be uppercase</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.1415926535</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// chars can contain 1 character that are surrounded with ' and is one byte in size</span></span><br><span class="line">	<span class="keyword">char</span> myGrade = <span class="string">'A'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// bools have the value of (true/1) or (false/0)</span></span><br><span class="line">	<span class="keyword">bool</span> isHappy = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ints are whole numbers</span></span><br><span class="line">	<span class="keyword">int</span> myAge = <span class="number">39</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// floats are floating point numbers accurate to about 6 decimals</span></span><br><span class="line">	<span class="keyword">float</span> favNum = <span class="number">3.141592</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// doubles are floating point numbers accurate to about 15 digits</span></span><br><span class="line">	<span class="keyword">double</span> otherFavNum = <span class="number">1.6180339887</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can output a variable value like this</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Favorite Number "</span> &lt;&lt; favNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Other types include</span></span><br><span class="line">	<span class="comment">// short int : At least 16 bits</span></span><br><span class="line">	<span class="comment">// long int : At least 32 bits</span></span><br><span class="line">	<span class="comment">// long long int : At least 64 bits</span></span><br><span class="line">	<span class="comment">// unsigned int : Same size as signed version</span></span><br><span class="line">	<span class="comment">// long double : Not less then double</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can get the number of bytes for a data type with sizeof</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of int "</span> &lt;&lt; <span class="keyword">sizeof</span>(myAge) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of char "</span> &lt;&lt; <span class="keyword">sizeof</span>(myGrade) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of bool "</span> &lt;&lt; <span class="keyword">sizeof</span>(isHappy) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of float "</span> &lt;&lt; <span class="keyword">sizeof</span>(favNum) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of double "</span> &lt;&lt; <span class="keyword">sizeof</span>(otherFavNum) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> largestInt = <span class="number">2147483647</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Largest int "</span> &lt;&lt; largestInt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- ARITHMETIC ----------</span></span><br><span class="line">	<span class="comment">// The arithmetic operators are +, -, *, /, %, ++, --</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 + 2 = "</span> &lt;&lt; <span class="number">5</span>+<span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 - 2 = "</span> &lt;&lt; <span class="number">5</span><span class="number">-2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 * 2 = "</span> &lt;&lt; <span class="number">5</span>*<span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 / 2 = "</span> &lt;&lt; <span class="number">5</span>/<span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"5 % 2 = "</span> &lt;&lt; <span class="number">5</span>%<span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> five = <span class="number">5</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"5++ = "</span> &lt;&lt; five++ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"++5 = "</span> &lt;&lt; ++five &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"5-- = "</span> &lt;&lt; five-- &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"--5 = "</span> &lt;&lt; --five &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Shorthand assignment operators</span></span><br><span class="line">	<span class="comment">// a += b == a = a + b</span></span><br><span class="line">	<span class="comment">// There is also -=, *=, /=, %=</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Order of Operation states * and / is performed before + and -</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"1 + 2 - 3 * 2 = "</span> &lt;&lt; <span class="number">1</span> + <span class="number">2</span> - <span class="number">3</span> * <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"(1 + 2 - 3) * 2 = "</span> &lt;&lt; (<span class="number">1</span> + <span class="number">2</span> - <span class="number">3</span>) * <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- CASTING ----------</span></span><br><span class="line">	<span class="comment">// You convert from one data type to another by casting</span></span><br><span class="line">	<span class="comment">// char, int, float, double</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"4 / 5 = "</span> &lt;&lt; <span class="number">4</span> / <span class="number">5</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"4 / 5 = "</span> &lt;&lt; (<span class="keyword">float</span>) <span class="number">4</span> / <span class="number">5</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- IF STATEMENT ----------</span></span><br><span class="line">	<span class="comment">// Executes different code depending upon a condition</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Comparison operators include ==, !=, &gt;, &lt;, &gt;=, &lt;=</span></span><br><span class="line">	<span class="comment">// Will return true (1) if the comparison is true, or false (0)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Logical operators include &amp;&amp;, ||, !</span></span><br><span class="line">	<span class="comment">// Used to test 2 or more conditionals</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> age = <span class="number">70</span>;</span><br><span class="line">	<span class="keyword">int</span> ageAtLastExam = <span class="number">16</span>;</span><br><span class="line">	<span class="keyword">bool</span> isNotIntoxicated = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>((age &gt;= <span class="number">1</span>) &amp;&amp; (age &lt; <span class="number">16</span>))&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"You can't drive"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(!isNotIntoxicated)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"You can't drive"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(age &gt;= <span class="number">80</span> &amp;&amp; ((age &gt; <span class="number">100</span>) || ((age - ageAtLastExam) &gt; <span class="number">5</span>)))&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"You can't drive"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"You can drive"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- SWITCH STATEMENT ----------</span></span><br><span class="line">	<span class="comment">// switch is used when you have a limited number of possible options</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> greetingOption = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(greetingOption)&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"bonjour"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span> :</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hola"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span> :</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hallo"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">default</span> :</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- TERNARY OPERATOR ----------</span></span><br><span class="line">	<span class="comment">// Performs an assignment based on a condition</span></span><br><span class="line">	<span class="comment">// variable = (condition) ? if true : if false</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> largestNum = (<span class="number">5</span> &gt; <span class="number">2</span>) ? <span class="number">5</span> : <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The biggest number is "</span> &lt;&lt; largestNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- ARRAYS ----------</span></span><br><span class="line">	<span class="comment">// Arrays store multiple values of the same type</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// You must provide a data type and the size of the array</span></span><br><span class="line">	<span class="keyword">int</span> myFavNums[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can declare and add values in one step</span></span><br><span class="line">	<span class="keyword">int</span> badNums[<span class="number">5</span>] = &#123;<span class="number">4</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">24</span>, <span class="number">34</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The first item in the array has the label (index) of 0</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bad Number 1: "</span> &lt;&lt; badNums[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can create multidimensional arrays</span></span><br><span class="line">	<span class="keyword">char</span> myName[<span class="number">5</span>][<span class="number">5</span>] = &#123;&#123;<span class="string">'D'</span>,<span class="string">'e'</span>,<span class="string">'r'</span>,<span class="string">'e'</span>,<span class="string">'k'</span>&#125;,&#123;<span class="string">'B'</span>,<span class="string">'a'</span>,<span class="string">'n'</span>,<span class="string">'a'</span>,<span class="string">'s'</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"2nd Letter in 2nd Array: "</span> &lt;&lt; myName[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can change a value in an array using its index</span></span><br><span class="line">	myName[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">'e'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"New Value "</span> &lt;&lt; myName[<span class="number">0</span>][<span class="number">2</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- FOR LOOP ----------</span></span><br><span class="line">	<span class="comment">// Continues to execute code as long as a condition is true</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can also cycle through an array by nesting for loops</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">5</span>; k++)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; myName[j][k];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- WHILE LOOP ----------</span></span><br><span class="line">	<span class="comment">// Use a while loop when you don't know ahead of time when a loop will end</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Generate a random number between 1 and 100</span></span><br><span class="line">	<span class="keyword">int</span> randNum = (rand() % <span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(randNum != <span class="number">100</span>)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; randNum &lt;&lt; <span class="string">", "</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Used to get you out of the loop</span></span><br><span class="line">		randNum = (rand() % <span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can do the same as the for loop like this</span></span><br><span class="line">	<span class="comment">// Create an index to iterate out side the while loop</span></span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(index &lt;= <span class="number">10</span>)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; index &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Increment inside the loop</span></span><br><span class="line">		index++;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- DO WHILE LOOP ----------</span></span><br><span class="line">	<span class="comment">// Used when you want to execute what is in the loop at least once</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Used to store a series of characters</span></span><br><span class="line">	<span class="built_in">string</span> numberGuessed;</span><br><span class="line">	<span class="keyword">int</span> intNumberGuessed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">	    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Guess between 1 and 10: "</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// Allows for user input</span></span><br><span class="line">	    <span class="comment">// Pass the source and destination of the input</span></span><br><span class="line">	    getline (<span class="built_in">cin</span>,numberGuessed);</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// stoi converts the string into an integer</span></span><br><span class="line">	    intNumberGuessed = stoi(numberGuessed);</span><br><span class="line">	    <span class="built_in">cout</span> &lt;&lt; intNumberGuessed &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// We'll continue looping until the number entered is 4</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (intNumberGuessed != <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">	  <span class="built_in">cout</span> &lt;&lt; <span class="string">"You Win"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- STRINGS ----------</span></span><br><span class="line">	<span class="comment">// The string library class provides a string object</span></span><br><span class="line">	<span class="comment">// You must always surround strings with "</span></span><br><span class="line">	<span class="comment">// Unlike the char arrays in c, the string object automatically resizes</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The C way of making a string</span></span><br><span class="line">	<span class="keyword">char</span> happyArray[<span class="number">6</span>] = &#123;<span class="string">'H'</span>, <span class="string">'a'</span>, <span class="string">'p'</span>, <span class="string">'p'</span>, <span class="string">'y'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The C++ way</span></span><br><span class="line">	<span class="built_in">string</span> birthdayString = <span class="string">" Birthday"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can combine / concatenate strings with +</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; happyArray + birthdayString &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> yourName;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"What is your name? "</span>;</span><br><span class="line">	getline (<span class="built_in">cin</span>,yourName);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello "</span> &lt;&lt; yourName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> eulersConstant = <span class="number">.57721</span>;</span><br><span class="line">	<span class="built_in">string</span> eulerGuess;</span><br><span class="line">	<span class="keyword">double</span> eulerGuessDouble;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"What is Euler's Constant? "</span>;</span><br><span class="line">	getline (<span class="built_in">cin</span>,eulerGuess);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Converts a string into a double</span></span><br><span class="line">	<span class="comment">// stof() for floats</span></span><br><span class="line">	eulerGuessDouble = stod(eulerGuess);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(eulerGuessDouble == eulersConstant)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"You are right"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"You are wrong"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Size returns the number of characters</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of string "</span> &lt;&lt; eulerGuess.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// empty tells you if string is empty or not</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Is string empty "</span> &lt;&lt; eulerGuess.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// append adds strings together</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; eulerGuess.append(<span class="string">" was your guess"</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> dogString = <span class="string">"dog"</span>;</span><br><span class="line">	<span class="built_in">string</span> catString = <span class="string">"cat"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Compare returns a 0 for a match, 1 if less than, -1 if greater then</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dogString.compare(catString) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; dogString.compare(dogString) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; catString.compare(dogString) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// assign copies a value to another string </span></span><br><span class="line">	<span class="built_in">string</span> wholeName = yourName.assign(yourName);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; wholeName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can get a substring as well by defining the starting index and the</span></span><br><span class="line">	<span class="comment">// number of characters to copy</span></span><br><span class="line">	<span class="built_in">string</span> firstName = wholeName.assign(wholeName, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; firstName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// find returns the index for the string your searching for starting</span></span><br><span class="line">	<span class="comment">// from the index defined</span></span><br><span class="line">	<span class="keyword">int</span> lastNameIndex = yourName.<span class="built_in">find</span>(<span class="string">"Banas"</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Index for last name "</span> &lt;&lt; lastNameIndex &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// insert places a string in the index defined</span></span><br><span class="line">	yourName.insert(<span class="number">5</span>, <span class="string">" Justin"</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; yourName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// erase will delete 6 characters starting at index 7</span></span><br><span class="line">	yourName.erase(<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; yourName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// replace 5 characters starting at index 6 with the string Maximus</span></span><br><span class="line">	yourName.replace(<span class="number">6</span>,<span class="number">5</span>,<span class="string">"Maximus"</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; yourName &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- VECTORS ----------</span></span><br><span class="line">	<span class="comment">// Vectors are like arrays, but their size can change</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; lotteryNumVect(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> lotteryNumArray[<span class="number">5</span>] = &#123;<span class="number">4</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">24</span>, <span class="number">34</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Add the array to the vector starting at the beginning of the vector</span></span><br><span class="line">	lotteryNumVect.insert(lotteryNumVect.<span class="built_in">begin</span>(), lotteryNumArray, lotteryNumArray+<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Insert a value into the 5th index</span></span><br><span class="line">	lotteryNumVect.insert(lotteryNumVect.<span class="built_in">begin</span>()+<span class="number">5</span>, <span class="number">44</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// at gets the value in the specified index</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Value in 5 "</span> &lt;&lt; lotteryNumVect.at(<span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// push_back adds a value at the end of a vector</span></span><br><span class="line">	lotteryNumVect.push_back(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// back gets the value in the final index</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Final Value "</span> &lt;&lt; lotteryNumVect.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pop_back removes the final element</span></span><br><span class="line">	lotteryNumVect.pop_back();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// front returns the first element</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"First Element "</span> &lt;&lt; lotteryNumVect.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// back returns the last element</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Last Element "</span> &lt;&lt; lotteryNumVect.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// empty tells you if the vector is empty</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Vector Empty "</span> &lt;&lt; lotteryNumVect.empty() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// size returns the total number of elements</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of Vector Elements "</span> &lt;&lt; lotteryNumVect.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- FUNCTIONS ----------</span></span><br><span class="line">	<span class="comment">// Functions allow you to reuse and better organize your code</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; addNumbers(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can't access values created in functions (Out of Scope)</span></span><br><span class="line">	<span class="comment">// cout &lt;&lt; combinedValue &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; addNumbers(<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The factorial of 3 is "</span> &lt;&lt; getFactorial(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- FILE I/O ----------</span></span><br><span class="line">	<span class="comment">// We can read and write to files using text or machine readable binary</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">string</span> steveQuote = <span class="string">"A day without sunshine is like, you know, night"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create an output filestream and if the file doesn't exist create it</span></span><br><span class="line">	<span class="function">ofstream <span class="title">writer</span><span class="params">(<span class="string">"stevequote.txt"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Verify that the file stream object was created</span></span><br><span class="line">	<span class="keyword">if</span>(! writer)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error opening file"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Signal that an error occurred</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Write the text to the file</span></span><br><span class="line">		writer &lt;&lt; steveQuote &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Close the file</span></span><br><span class="line">		writer.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Open a stream to append to whats there with ios::app</span></span><br><span class="line">	<span class="comment">// ios::binary : Treat the file as binary</span></span><br><span class="line">	<span class="comment">// ios::in : Open a file to read input</span></span><br><span class="line">	<span class="comment">// ios::trunc : Default</span></span><br><span class="line">	<span class="comment">// ios::out : Open a file to write output</span></span><br><span class="line">	<span class="function">ofstream <span class="title">writer2</span><span class="params">(<span class="string">"stevequote.txt"</span>, ios::app)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(! writer2)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error opening file"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Signal that an error occurred</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		writer2 &lt;&lt; <span class="string">"\n- Steve Martin"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		writer2.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> letter;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Read characters from a file using an input file stream</span></span><br><span class="line">	<span class="function">ifstream <span class="title">reader</span><span class="params">(<span class="string">"stevequote.txt"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(! reader)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Error opening file"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Read each character from the stream until end of file</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; ! reader.eof(); i++)&#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Get the next letter and output it</span></span><br><span class="line">			reader.<span class="built_in">get</span>(letter);</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; letter;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		reader.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- EXCEPTION HANDLING ----------</span></span><br><span class="line">	<span class="comment">// You can be prepared for potential problems with exception handling</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(number != <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; <span class="number">2</span>/number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">throw</span>(number);</span><br><span class="line"></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">catch</span>(<span class="keyword">int</span> number)&#123;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; number &lt;&lt; <span class="string">" is not valid input"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- POINTERS ----------</span></span><br><span class="line">	<span class="comment">// When data is stored it is stored in an appropriately sized box based</span></span><br><span class="line">	<span class="comment">// on its data type </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> myAge = <span class="number">39</span>;</span><br><span class="line">	<span class="keyword">char</span> myGrade = <span class="string">'A'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of int "</span> &lt;&lt; <span class="keyword">sizeof</span>(myAge) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of char "</span> &lt;&lt; <span class="keyword">sizeof</span>(myGrade) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can reference the box (memory address) where data is stored with </span></span><br><span class="line">	<span class="comment">// the &amp; reference operator</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"myAge is located at "</span> &lt;&lt; &amp;myAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A pointer can store a memory address</span></span><br><span class="line">	<span class="comment">// The data type must be the same as the data referenced and it is followed</span></span><br><span class="line">	<span class="comment">// by a *</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>* agePtr = &amp;myAge;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can access the memory address and the data </span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Address of pointer "</span> &lt;&lt; agePtr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// * is the dereference or indirection operator</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Data at memory address "</span> &lt;&lt; *agePtr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> badNums[<span class="number">5</span>] = &#123;<span class="number">4</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">24</span>, <span class="number">34</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span>* numArrayPtr = badNums;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can increment through an array using a pointer with ++ or --</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Address "</span> &lt;&lt; numArrayPtr &lt;&lt; <span class="string">" Value "</span> &lt;&lt; *numArrayPtr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	numArrayPtr++; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Address "</span> &lt;&lt; numArrayPtr &lt;&lt; <span class="string">" Value "</span> &lt;&lt; *numArrayPtr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// An array name is just a pointer to the array</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Address "</span> &lt;&lt; badNums &lt;&lt; <span class="string">" Value "</span> &lt;&lt; *badNums &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// When you pass a variable to a function you are passing the value</span></span><br><span class="line">	<span class="comment">// When you pass a pointer to a function you are passing a reference</span></span><br><span class="line">	<span class="comment">// that can be changed</span></span><br><span class="line"></span><br><span class="line">	makeMeYoung(&amp;myAge);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm "</span> &lt;&lt; myAge &lt;&lt; <span class="string">" years old now"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &amp; denotes that ageRef will be a reference to the assigned variable</span></span><br><span class="line">	<span class="keyword">int</span>&amp; ageRef = myAge;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"ageRef : "</span> &lt;&lt; ageRef &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// It can manipulate the other variables data</span></span><br><span class="line">	ageRef++; </span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"myAge : "</span> &lt;&lt; myAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// You can pass the reference to a function</span></span><br><span class="line">	actYourAge(ageRef);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"myAge : "</span> &lt;&lt; myAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// When deciding on whether to use pointers or references</span></span><br><span class="line">	<span class="comment">// Use Pointers if you don't want to initialize at declaration, or if</span></span><br><span class="line">	<span class="comment">// you need to assign another variable</span></span><br><span class="line">	<span class="comment">// otherwise use a reference</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// ---------- CLASSES &amp; OBJECTS ----------</span></span><br><span class="line">	<span class="comment">// Classes are the blueprints for modeling real world objects</span></span><br><span class="line">	<span class="comment">// Real world objects have attributes, classes have members / variables</span></span><br><span class="line">	<span class="comment">// Real world objects have abilities, classes have methods / functions</span></span><br><span class="line">	<span class="comment">// Classes believe in hiding data (encapsulation) from outside code</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Declare a Animal type object</span></span><br><span class="line">	Animal fred;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set the values for the Animal</span></span><br><span class="line">	fred.setHeight(<span class="number">33</span>);</span><br><span class="line">	fred.setWeight(<span class="number">10</span>);</span><br><span class="line">	fred.setName(<span class="string">"Fred"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get the values for the Animal</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; fred.getName() &lt;&lt; <span class="string">" is "</span> &lt;&lt; fred.getHeight() &lt;&lt; <span class="string">" cms tall and "</span></span><br><span class="line">		&lt;&lt; fred.getWeight() &lt;&lt; <span class="string">" kgs in weight"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	fred.setAll(<span class="number">34</span>, <span class="number">12</span>, <span class="string">"Fred"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; fred.getName() &lt;&lt; <span class="string">" is "</span> &lt;&lt; fred.getHeight() &lt;&lt; <span class="string">" cms tall and "</span></span><br><span class="line">		&lt;&lt; fred.getWeight() &lt;&lt; <span class="string">" kgs in weight"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Creating an object using the constructor</span></span><br><span class="line">	<span class="function">Animal <span class="title">tom</span><span class="params">(<span class="number">36</span>, <span class="number">15</span>, <span class="string">"Tom"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; tom.getName() &lt;&lt; <span class="string">" is "</span> &lt;&lt; tom.getHeight() &lt;&lt; <span class="string">" cms tall and "</span></span><br><span class="line">		&lt;&lt; tom.getWeight() &lt;&lt; <span class="string">" kgs in weight"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Demonstrate the inheriting class Dog</span></span><br><span class="line">	<span class="function">Dog <span class="title">spot</span><span class="params">(<span class="number">38</span>, <span class="number">16</span>, <span class="string">"Spot"</span>, <span class="string">"Woof"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// static methods are called by using the class name and the scope operator</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of Animals "</span> &lt;&lt; Animal::getNumOfAnimals() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	spot.getSound();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Test the toString method that will be overwritten</span></span><br><span class="line">	tom.toString();</span><br><span class="line">	spot.toString();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We can call the superclass version of a method with the class name </span></span><br><span class="line">	<span class="comment">// and the scope operator</span></span><br><span class="line">	spot.Animal::toString();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// When a function finishes it must return an integer value</span></span><br><span class="line">	<span class="comment">// Zero means that the function ended with success</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Part-Two"><a href="#Part-Two" class="headerlink" title="Part Two"></a>Part Two</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Virtual Methods and Polymorphism</span></span><br><span class="line"><span class="comment">// Polymorpism allows you to treat subclasses as their superclass and yet</span></span><br><span class="line"><span class="comment">// call the correct overwritten methods in the subclass automatically</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">getFamily</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"We are Animals"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// When we define a method as virtual we know that Animal</span></span><br><span class="line">		<span class="comment">// will be a base class that may have this method overwritten</span></span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">getClass</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm an Animal"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">getClass</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm a Dog"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GermanShepard</span> :</span> <span class="keyword">public</span> Dog&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">getClass</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm a German Shepard"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">getDerived</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"I'm an Animal and Dog"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">whatClassAreYou</span><span class="params">(Animal *animal)</span></span>&#123; </span><br><span class="line">	animal -&gt; getClass(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	Animal *animal = <span class="keyword">new</span> Animal;</span><br><span class="line">	Dog *dog = <span class="keyword">new</span> Dog;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If a method is marked virtual or not doesn't matter if we call the method</span></span><br><span class="line">	<span class="comment">// directly from the object</span></span><br><span class="line">	animal-&gt;getClass();</span><br><span class="line">	dog-&gt;getClass();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If getClass is not marked as virtual outside functions won't look for </span></span><br><span class="line">	<span class="comment">// overwritten methods in subclasses however</span></span><br><span class="line">	whatClassAreYou(animal);</span><br><span class="line">	whatClassAreYou(dog);</span><br><span class="line"></span><br><span class="line">	Dog spot;</span><br><span class="line">	GermanShepard <span class="built_in">max</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// A base class can call derived class methods as long as they exist </span></span><br><span class="line">	<span class="comment">// in the base class</span></span><br><span class="line">	Animal* ptrDog = &amp;spot;</span><br><span class="line">	Animal* ptrGShepard = &amp;<span class="built_in">max</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Call the method not overwritten in the super class Animal</span></span><br><span class="line">	ptrDog -&gt; getFamily();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Since getClass was overwritten in Dog call the Dog version</span></span><br><span class="line">	ptrDog -&gt; getClass();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Call to the super class</span></span><br><span class="line">	ptrGShepard -&gt; getFamily();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Call to the overwritten GermanShepard version</span></span><br><span class="line">	ptrGShepard -&gt; getClass();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Part-Three"><a href="#Part-Three" class="headerlink" title="Part Three"></a>Part Three</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Polymorpism allows you to treat subclasses as their superclass and yet</span></span><br><span class="line"><span class="comment">// call the correct overwritten methods in the subclass automatically</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">makeSound</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"The Animal says grrrr"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// The Animal class could be a capability class that exists</span></span><br><span class="line">		<span class="comment">// only to be derived from by containing only virtual methods</span></span><br><span class="line">		<span class="comment">// that do nothing</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span> <span class="keyword">public</span> Animal&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">makeSound</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"The Cat says meow"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span> <span class="keyword">public</span> Animal&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">makeSound</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"The Dog says woof"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An abstract data type is a class that acts as the base to other classes</span></span><br><span class="line"><span class="comment">// They stand out because its methods are initialized with zero</span></span><br><span class="line"><span class="comment">// A pure virtual method must be overwritten by subclasses</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>&#123;</span></span><br><span class="line">	<span class="keyword">public</span> : </span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getNumWheels</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getNumDoors</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StationWagon</span> :</span> <span class="keyword">public</span> Car&#123;</span><br><span class="line">	<span class="keyword">public</span> :</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">getNumWheels</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Station Wagon has 4 Wheels"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">getNumDoors</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Station Wagon has 4 Doors"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">		StationWagon() &#123; &#125;</span><br><span class="line">		~StationWagon();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	Animal* pCat = <span class="keyword">new</span> Cat;</span><br><span class="line">	Animal* pDog = <span class="keyword">new</span> Dog;</span><br><span class="line"></span><br><span class="line">	pCat -&gt; makeSound();</span><br><span class="line">	pDog -&gt; makeSound();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Create a StationWagon using the abstract data type Car</span></span><br><span class="line">	Car* stationWagon = <span class="keyword">new</span> StationWagon();</span><br><span class="line"></span><br><span class="line">	stationWagon -&gt; getNumWheels();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
  </entry>
  <entry>
    <title>CRF</title>
    <url>/2020/05/07/CRF/</url>
    <content><![CDATA[<h1 id="CRF-原理和实现"><a href="#CRF-原理和实现" class="headerlink" title="CRF 原理和实现"></a>CRF 原理和实现</h1><blockquote>
<p>条件随机场(Conditional Random Field,CRF)，<br>给定一组输入随机变量条件下另一组输出随机变量的条件概率分布模型，其特点是假设输出随机变量构成马尔可夫随机场。</p>
</blockquote>
<p>CRF可以用于不同的预测问题，比如序列标注问题。</p>
<p>序列标注问题，因此主要是线性链条件随机场，问题变成了由输入序列对输出序列预测的判别模型。</p>
<p>学习方法通常是：极大似然估计或正则化的极大似然估计</p>
<a id="more"></a>
<h2 id="概率无向图模型"><a href="#概率无向图模型" class="headerlink" title="概率无向图模型"></a>概率无向图模型</h2><p>probabilistic undirected graphical model，又称马尔可夫随机场(Markov Random Field)，是一个可以使用无向图表示的联合概率分布。</p>
<p>定义：概率无向图<br>设有联合概率分布$P(Y)$,由无向图$\mathbf{G=(V,E)}$表示，在图中，结点表示随机变量，边表示随机变量之间的依赖关系。如果联合概率分布$P(Y)$满足成对、局部或全局马尔可夫性，则称此联合概率分布为概率无向图模型或马尔可夫随机场。</p>
<p>定义：团和最大团</p>
<p>无向图$\mathbf{G}$中中任何两个结点均有边连接的结点子集称为团，若$\mathbf{C}$是无向图$\mathbf{G}$中的一个团，并且不能再加进任何一个$\mathbf{G}$的结点使其成为一个更大的团，则称$\mathbf{C}$为最大团。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line"> D1((Y1))</span><br><span class="line"> D2((Y2))</span><br><span class="line"> D3((Y3))</span><br><span class="line"> D4((Y4))</span><br><span class="line"> D1---D2</span><br><span class="line"> D1---D3</span><br><span class="line"> D2---D4</span><br><span class="line"> D2---D3</span><br><span class="line"> D3---D4</span><br></pre></td></tr></table></figure>
<p>概率无向图模型的因子分解：将概率无向图模型的联合概率分布表示为其最大团上的随机变量的函数的乘积形式。</p>
<script type="math/tex; mode=display">
\begin{align}& \mathbf{P(Y)}=\frac{1}{Z}\prod_C{\varPsi_c(Y_c)} \\& Z = \sum_Y\prod_C{\varPsi_c(Y_c)}\end{align}</script><p>其中函数$\varPsi_c(Y_c)$称为势函数，一般要求是严格正的，通常定义为指数函数</p>
<script type="math/tex; mode=display">
\begin{align}\varPsi_c(Y_c) = \exp\{-E(Y_c)\}\end{align}</script><h2 id="条件随机场"><a href="#条件随机场" class="headerlink" title="条件随机场"></a>条件随机场</h2><p>条件随机场：给定随机变量$\mathbf{X}$条件下，随机变量$\mathbf{Y}$的马尔可夫随机场。</p>
<p>定义：条件随机场</p>
<p>设$\mathbf{X}$和$\mathbf{Y}$是随机变量，$\mathbf{P(Y|X)}$是在给定$\mathbf{X}$条件下$\mathbf{Y}$的条件概率分布。若随机变量$\mathbf{Y}$构成一个由无向图$\mathbf{G=(V,E)}$表示的马尔可夫随机场，即</p>
<script type="math/tex; mode=display">
\begin{align}P(Y_v|X,Y_w,w\neq v) = P(Y_v|X,Y_w,w \sim v)\end{align}</script><p>对任意结点$v$成立，则条件概率分布$\mathbf{P(Y|X)}$为条件随机场。其中，$w \sim v$表示在图中和结点$v$连接的所有结点$w$,$w \neq v$表示结点$v$之外的所有节点。$\mathbf{Y_v,Y_u,Y_w}$为结点$\mathbf{v,u,w}$对应的随机变量。</p>
<p>定义中没有假设，$\mathbf{X}$和$\mathbf{Y}$具有相同的结构。现实中，一般假设它们图结构相同。</p>
<p>定义：线性链条件随机场</p>
<p>设$\mathbf{X=(X_1,X_2,\cdots,X_n)}，\mathbf{Y=(Y_1,Y_2,\cdots,Y_n)}$均为线性链表示的随机变量序列，若在给定随机变量序列$\mathbf{X}$的条件下，随机变量序列$\mathbf{Y}$的条件概率分布构成条件随机场。</p>
<script type="math/tex; mode=display">
\begin{align}& P(Y_i|X,Y_1,\cdots,Y_{i-1},Y_{i+1},\cdots,Y_n) = P(Y_i|X,Y_{i-1},Y_{i+1}) \; i=1,2,\cdots,n\end{align}</script><p>在标注问题中，$\mathbf X$表示输入观测序列，$\mathbf Y$表示对应的输出标记序列或状态序列。</p>
<h3 id="CRF的参数化形式"><a href="#CRF的参数化形式" class="headerlink" title="CRF的参数化形式"></a>CRF的参数化形式</h3><p>线性链CRF的参数化形式，设$\mathbf{P(Y|X)}$为线性链CRF，则在随机变量$\mathbf  X$取值为$\mathbf x$的条件下，随机变量$\mathbf Y$取值为$\mathbf y$的条件概率具有以下形式：</p>
<script type="math/tex; mode=display">
\begin{align}& P(\mathbf y|\mathbf x) = \frac{1}{Z(\mathbf x)} \exp(\sum_{i,k}\lambda_kt_k(\mathbf y_{i-1},\mathbf y_i,\mathbf x,i)+\sum_{i,l}\mu_ls_l(\mathbf y_i,\mathbf x,i)) \\& Z(\mathbf x) = \sum_{\mathbf y}\exp(\sum_{i,k}\lambda_kt_k(\mathbf y_{i-1},\mathbf y_i,\mathbf x,i)+\sum_{i,l}\mu_ls_l(\mathbf y_i,\mathbf x,i)) \end{align}</script><p>其中，$t_k和s_l$是特征函数，$\lambda_k和\mu_l$是对应的权值，$Z(\mathbf x)$是规范化因子。</p>
<h3 id="CRF的简化形式"><a href="#CRF的简化形式" class="headerlink" title="CRF的简化形式"></a>CRF的简化形式</h3><p>将局部特征函数转化为全局特征函数，CRF则可以写成权值向量和特征向量的内积形式。</p>
<p>将转移特征和状态特征机器权值用统一的符号表示。</p>
<p>设有$K_1$个转移特征，$K_2$个状态特征，$K=K_1+K_2$</p>
<script type="math/tex; mode=display">
f_k(\mathbf y_{i-1},\mathbf y_i,\mathbf x,i) = \begin{cases}t_k(\mathbf y_{i-1},\mathbf y_i,\mathbf x,i) \quad k=1,2,\cdots,K_1\\s_l(\mathbf y_i,\mathbf x,i) \quad k=K_1+l,l=1,2,\cdots,K_2\end{cases}</script><p>然后对转移和状态特征在各个位置i求和，记作：</p>
<script type="math/tex; mode=display">
f_k(\mathbf y,\mathbf x)=\sum_{i=1}^n f_k(\mathbf y_{i-1},\mathbf y_i,\mathbf x,i) k=1,2,\cdots,K</script><p>用$\mathbf w_k$表示特征$f_k(\mathbf y,\mathbf x)$的权值，即</p>
<script type="math/tex; mode=display">
\mathbf w_k = \begin{cases}\lambda_k, \quad k=1,2,\cdots,K_1 \\\mu_l, \quad k=K_1+l,l=1,2,\cdots,K_2\end{cases}</script><p>因此，条件随机场可以表示为：</p>
<script type="math/tex; mode=display">
\begin{align}& P(\mathbf y|\mathbf x)= \frac{1}{Z(\mathbf x)}\exp \sum_{k=1}^K\mathbf w_k f_k(\mathbf y,\mathbf x) \\& Z(x) = \sum_{\mathbf y}\exp\sum_{k=1}^K\mathbf w_k f_k(\mathbf y,\mathbf x)\end{align}</script><p>若$\mathbf w$表示权值向量，$F(\mathbf y,\mathbf x)$表示全局特征向量：</p>
<script type="math/tex; mode=display">
\begin{align}& \mathbf w = (w_1,w_2,\cdots,w_k)^T \\& F(\mathbf y,\mathbf x) = (f_1(\mathbf y,\mathbf x),f_2(\mathbf y,\mathbf x),\cdots,f_K(\mathbf y,\mathbf x),)^T\end{align}</script><p>则CRF可以写成内积的形式：</p>
<script type="math/tex; mode=display">
\begin{align}& P(\mathbf y|\mathbf x)= \frac{\exp (\mathbf w \cdot F(\mathbf y,\mathbf x))}{Z(\mathbf x)} \\& Z(x) = \sum_{\mathbf y}\exp (\mathbf w \cdot F(\mathbf y,\mathbf x))\end{align}</script><h3 id="CRF的矩阵形式-（略）"><a href="#CRF的矩阵形式-（略）" class="headerlink" title="CRF的矩阵形式 （略）"></a>CRF的矩阵形式 （略）</h3><h2 id="CRF的概率计算问题"><a href="#CRF的概率计算问题" class="headerlink" title="CRF的概率计算问题"></a>CRF的概率计算问题</h2><p>给定CRF $\mathbf{P(Y|X)}$，输入序列$\mathbf x$和输出序列$\mathbf y$，计算条件概率$\mathbf{P(Y<em>i=y_i|x),P(Y</em>{i-1}=y_{i-1},Y_i=y_i|x)}$以及相应的数学期望的问题。</p>
<h3 id="前向-后向算法"><a href="#前向-后向算法" class="headerlink" title="前向-后向算法"></a>前向-后向算法</h3><p>像HMM一样，递归的计算以上概率及其期望值。</p>
<p>对于每个指标$i=0,1,\cdots,n+1$，定义前向向量$\alpha_i(\mathbf x)$:</p>
<script type="math/tex; mode=display">
\alpha_0(y|x)=\begin{cases}1,\quad y=start \\0,\quad other\end{cases}</script><p>递推公式为</p>
<script type="math/tex; mode=display">
\alpha_i^T(y_i|x)=\alpha_{i-1}^T(y_{i-1}|x)M_i(y_{i-1},y_i|x), \quad i=1,2,\cdots,n+1</script>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>动态时间调整</title>
    <url>/2019/11/26/DTW%E5%8A%A8%E6%80%81%E6%97%B6%E9%97%B4%E8%B0%83%E6%95%B4/</url>
    <content><![CDATA[<h1 id="动态时间调整"><a href="#动态时间调整" class="headerlink" title="动态时间调整"></a>动态时间调整</h1><blockquote>
<p><code>DTW</code>能够衡量这两个序列的相似程度，或者说两个序列的距离。同时<code>DTW</code>能够对两个序列的延展或者压缩能够有一定的适应性，举个例子，不同人对同一个词语的发音会有细微的差别，特别在时长上，有些人的发音会比标准的发音或长或短，<code>DTW</code>对这种序列的延展和压缩不敏感，所以给定标准语音库，<code>DTW</code>能够很好得识别单个字词，这也是为什么<code>DTW</code>一直被认为是语音处理方面的专门算法。实际上，<code>DTW</code>虽然老，但简单且灵活地实现模板匹配，能解决很多离散时间序列匹配的问题，视频动作识别，生物信息比对等等诸多领域都有应用。</p>
</blockquote>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><ol>
<li>根据给定样本序列和比对序列，计算序列点之间的欧式距离，生成序列距离矩阵。</li>
<li>根据距离矩阵生成损失矩阵（累积距离矩阵）<ol>
<li>第一行第一列元素为 距离矩阵的第一行第一列元素；</li>
<li>其他位置的元素 $(M_c(i,j)M_c(i,j))$的值则需要逐步计算，具体值的计算方法为 $M_c(i,j)=M(i,j)+\min(M_c(i−1,j−1),M_c(i−1,j),M_c(i,j−1))$。</li>
<li>两个序列的距离为损失矩阵最后一行最后一列给出。</li>
</ol>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 动态时间调整</span></span><br><span class="line">X = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">1</span>]</span><br><span class="line">Y = [<span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">n, m = len(X), len(Y)</span><br><span class="line"></span><br><span class="line">matrix = [[<span class="number">0</span>]*m <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">        matrix[i][j] = abs(X[i]-Y[j])</span><br><span class="line">        </span><br><span class="line">mat_coss = [[<span class="number">0</span>]*m <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    mat_coss[i][<span class="number">0</span>] = matrix[i][<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">    mat_coss[<span class="number">0</span>][j] = matrix[<span class="number">0</span>][j]</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,m):</span><br><span class="line">        mat_coss[i][j] = matrix[i][j] + min(mat_coss[i<span class="number">-1</span>][j<span class="number">-1</span>],mat_coss[i<span class="number">-1</span>][j],mat_coss[i][j<span class="number">-1</span>])</span><br><span class="line">        </span><br><span class="line">print(<span class="string">f'X和Y之间的距离为:<span class="subst">&#123;mat_coss[n<span class="number">-1</span>][m<span class="number">-1</span>]&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title>ELMo算法</title>
    <url>/2020/03/14/ELMo%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="ELMo算法"><a href="#ELMo算法" class="headerlink" title="ELMo算法"></a>ELMo算法</h1><p>ELMo,(Embeddings from Language Models)</p>
<p><a href="https://arxiv.org/pdf/1802.05365.pdf" target="_blank" rel="noopener">Paper</a></p>
<p>Paper的author认为对词语进行表征应该兼顾的问题：</p>
<ul>
<li>词语在语义和语法上用法的特点</li>
<li>随着语言环境的变化，用法也能够改变。</li>
</ul>
<p>这种算法的特点：每个词语的表征是整个输入语句的函数。</p>
<p>通过在大语料上以language model（$p(text)$）为目标来训练Bidirectional LSTM模型，再利用LSTM产生词语的表征。</p>
<p>在下游的NLP任务中，一般使用下游任务的Corpus（ignore label）对language model进行 微调，这种做法相当于到domain transfer，然后利用label的信息进行监督学习。</p>
<p>ELMo对词语的表征是“深”的，它们是BiLSTM中所有层的内部表征的函数。因此可以产生丰富的词语特征。</p>
<p>高层的LSTM的status可以捕捉到词语语义和语境相关的特征，因此可以来进行语义消歧，而底层的LSTM可以捕捉到语法方面的特征，可以做词性标注。将这两个结合起来，可以在下游的NLP Task中获得优势。</p>
<a id="more"></a>
<h2 id="Bidirectional-language-model"><a href="#Bidirectional-language-model" class="headerlink" title="　Bidirectional language model"></a>　Bidirectional language model</h2><p>ELMo从意思上是从语言模型中得到的嵌入。具体而言就是 双向语言模型</p>
<script type="math/tex; mode=display">
\begin{align}
& forward\;LM: \quad p(t_1,t_2,\cdots,t_N) = \prod_{k=1}^N p(t_k|t_1,t_2,\cdots,t_k-1) \\ 
& backward\;LM: \quad p(t_1,t_2,\cdots,t_N) = \prod_{k=1}^N p(t_k|t_{k+1},t_{k+2},\cdots,t_N)
\end{align}</script><p>其中$t$表示各种token。</p>
<p>对语言模型通常使用多层LSTM进行建模，ELMo的语言模型采用这种方式，使用叠加的双向LSTM来表示。</p>
<p>假设，输入的符号记为  $\mathbf{x}<em>k^{LM}$ （通过token embedding 或 a CNN over characters生成），然后将它输入到$L$ layers of LSTMs。每个位置$k$，每一层的LSTM都产生对应的<code>context-dependent</code>的表征$\vec{h}</em>{k,j}^{LM}，where\;j=1,2,\cdots,L$。这里的$j$表示第几层上的表征。顶层的LSTM的输出表示为$\vec{h}<em>{k,L}^{LM}$，最后使用Softmax归一化来预测下一个token $t</em>{k+1}$。对于<code>backward LSTMs</code>，给定$(t<em>{k+1},\cdots,t_N)$，每一层$j$产生表示$\overleftarrow{h}</em>{k,j}^{LM}，where\;j=1,2,\cdots,L$。</p>
<p>biLM将forward 和 backward 的LM集合起来。目标函数就是最大化前向和反向的对数似然函数。</p>
<script type="math/tex; mode=display">
\sum_{k=1}^N [\log p(t_k|t_1,\cdots,t_{k-1};\Theta_x,\overrightarrow{\Theta}_{LSTM},\Theta_s) + \log p(t_k|t+1,\cdots,t_{N};\Theta_x,\overleftarrow{\Theta}_{LSTM},\Theta_s)]</script><p>其中$\Theta_x$作为token表征，$\Theta_s$表示Softmax layer。</p>
<h2 id="ELMo"><a href="#ELMo" class="headerlink" title="ELMo"></a>ELMo</h2><p>在biLM中，ELMo的任务是将中间层进行特定的组合。</p>
<p>对于每个token $t_k$，$L-layer$的biLM需要计算出$2L+1$个表示</p>
<script type="math/tex; mode=display">
\begin{align}
R_k &= \{\mathbf{x}_k^{LM},\overrightarrow{h}_{k,j}^{LM},\overleftarrow{h}_{k,j}^{LM}|j=1,\cdots,L\} \\
& = \{h_{k,j}^{LM}|j=0,\cdots,L\}
\end{align}</script><p>其中$h<em>{k,0}^{LM}$是token layer，$h</em>{k,j}^{LM} = [\overrightarrow{h}<em>{k,j}^{LM},\overleftarrow{h}</em>{k,j}^{LM}]$对应每一个biLSTM layer。</p>
<p>对于下游的模型，ELMo 将$R$中的所有层合成一个单个向量，$\mathbf{ELMo}<em>k = E(R_k;\Theta_e)$。在TageLM和CoVe中只是简单的选择了高层的表示$E(R_k)=h</em>{k,L}^{LM}$。</p>
<p>通常，ELMo根据具体任务计算出所有层的权重：</p>
<script type="math/tex; mode=display">
\mathbf{ELMo}_k^{task} = E(R_k;\Theta^{task}) = \gamma^{task} \sum_{j=0}^L s_j^{task} h_{k,j}^{LM}</script><p>其中，$s^{task}$是softmax标准化的权重，$\gamma^{task}$是一个标量，使得任务模型能够放缩整个ELMo向量。</p>
<h2 id="Using-biLMs-for-supervised-NLP-task"><a href="#Using-biLMs-for-supervised-NLP-task" class="headerlink" title="Using biLMs for supervised NLP task"></a>Using biLMs for supervised NLP task</h2><p>给定一个预训练的biLM和对应NLP任务的监督学习模型。使用biLM来改善任务模型是一个简单的过程。只需要运行biLM然后记录下每个词的所有layer 表征。然后让任务模型学习所有表征的线性组合。</p>
<p>首先考虑没有使用biLM最低层的监督学习模型，大部分NLP监督模型在最底层使用通用的架构，能够以一般的方式增加ELMo到模型中去。</p>
<p>给定符号序列$(t_1,\cdots,t_N)$，使用预训练的词嵌入来对每个位置token构造上下文独立的符号表示$\mathbf{x}_k$。然后，这个模型将会产生上下文敏感的表示$\mathbf{h}_k$。</p>
<p>增加ELMo到监督模型中，我们首先需要冻结biLM的权重参数，然后将$\mathbf{x}_k$和$\mathbf{ELMo}_k^{task}$连接起来，将ELMo的增强后表征$[\mathbf{x}_k;\mathbf{ELMo}_k^{task}]$输入到任务的网络中。</p>
<p>作者发现，通过增加一定的Dropout到ELMo和通过$\lambda ||\mathbf{w}||_2^2$到loss正则化ELMo的权重。</p>
<blockquote>
<p>This imposes an inductive bias on the ELMo weights to<br>stay close to an average of all biLM layers.</p>
</blockquote>
<h2 id="Pre-trained-bidirectional-language-model-architecture"><a href="#Pre-trained-bidirectional-language-model-architecture" class="headerlink" title="Pre-trained bidirectional language model architecture"></a>Pre-trained bidirectional language model architecture</h2><p>特点：</p>
<ul>
<li>支持双向联合训练</li>
<li>在LSTM layers之间增加了 residual connection</li>
</ul>
<p>最终，模型使用了4096 units L=2的 biLSTM，512-D的投影以及第一层到第二层使用residual connention。上下文不敏感表示使用 2048 character n-gram Conv filters。一个线性映射层将它下降到512-D的表示。</p>
<p>结果，biLM为每个输入符号提供了三层表示。和传统词嵌入只提供一层的表示相反。</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title>DSP基础知识</title>
    <url>/2019/11/26/DSP%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="数字信号处理"><a href="#数字信号处理" class="headerlink" title="数字信号处理"></a>数字信号处理</h1><blockquote>
<p>记录DSP的一些概念和理论知识</p>
</blockquote>
<ul>
<li><p>信号：随着时间、空间或其他自变量而变化的物理量。</p>
<p>数学描述：</p>
<script type="math/tex; mode=display">
s_1(t) = 5t \\
s_2(t)=20t^2 \\
s(x,y)=3x+2xy+10y^2</script><p>可以存在多个自变量，如表示平面空间上的坐标。</p>
<p>上面描述的信号属于一类准确定义的信号，指定了对于自变量的函数依赖关系。</p>
<p>但是有些情况下的函数关系是未知的或太复杂以至于难以使用。</p>
<p>例如，某种语音信号无法用上面的表达式函数进行描述。</p>
<p>一般来说，一段语音可被高精度的表示为几种不同幅度和频率的总和，即</p>
<script type="math/tex; mode=display">
\sum_{i=1}^N A_i(t) \sin[2\pi F_i(t)t+\theta_i(t)]</script><p>其中，$|A_i(t)|,|F_i(t)|,|\theta_i(t)|$分别是正弦信号的(可能时变的)幅度、频率和相位的集合。</p>
</li>
<li><p>生成信号：通常和某系统相关联，以对某些刺激或压力作出响应。</p>
</li>
<li><p>信号处理的含义从有用信号中对噪声和干扰信号进行滤波。</p>
</li>
<li><p>模数(A/D)转换器：模拟信号和数字处理器之间的接口，输出数字信号，作为数字处理器的输入。</p>
</li>
<li><p>数模(D/A)转换器：数字域到模拟域的接口，将信号以模拟的形式提供给用户。</p>
</li>
<li><p>数字信号处理的优点：灵活配置、精度高、存储方便、价格便宜。</p>
</li>
<li><p>数字处理的局限性：受限于A/D转换器和数字信号处理器的运算速度。</p>
</li>
<li><p>多通道信号：采用矢量表示信号。</p>
</li>
<li><p>多维信号：多个自变量的函数。单个自变量的函数称为一维信号。</p>
</li>
<li><p>连续时间信号：模拟信号，在每个时间值上有定义且在一个连续的区间内取值的信号。数学上可采用一个连续变量的函数描述。</p>
</li>
<li><p>离散时间信号：定义在某些特定的时间值上，时间点不需要是等距的，实际上为了简单和数学易于处理，通常等间隔取值。</p>
</li>
<li><p>采样：在离散时间点上选择模拟信号值。</p>
</li>
<li><p>连续值信号：信号的值是连续的。信号在一个有限或无限范围内取所有可能的值。</p>
</li>
<li><p>离散值信号：信号的值是离散的。信号只在可能取值的有限集上取值。</p>
</li>
<li><p>量化：将连续值信号转化为离散值信号的过程，基本上是一个近似过程。量化可以只通过四舍五入或截断完成。</p>
</li>
<li><p>确定性信号：任何可以被一个显式数学表达式、一个数据表或者一个定义好的规则所唯一描述的信号。强调信号的过去、现在、将来的所有取值可以准确知道，不存在任何不确定性。</p>
</li>
<li><p>随机信号：无法被数学公式显式表达到一个合理的精度或这描述太复杂以至于没有实际用处，在时间轴上以不可知的方式展开。例如噪声生成器的输出、地震信号、语音信号。</p>
</li>
<li><p>随机信号的理论分析基于概率论和随机过程。</p>
</li>
<li><p>欧拉公式：$e^{ix}=\cos x + i\sin x$，i是复数单位。</p>
</li>
<li><p>能量信号和功率信号</p>
<ul>
<li>离散时间信号$x(n)$的能量$E \equiv \sum_{n=-\infty}^\infty |x(n)|^2$</li>
<li>离散时间信号的平均功率：$P=\lim<em>{N \rightarrow \infty} \frac{1}{2N+1} \sum</em>{n=-N}^N |x(n)|^2$</li>
<li>有限区间$-N \le n \le N$内定义的信号能量$E<em>N= \sum</em>{n=-N}^N |x(n)|^2$</li>
</ul>
</li>
<li><p>周期信号和非周期信号</p>
<ul>
<li>信号$x(n)$是周期为$N(N\gt 0)$的周期信号当且仅当$x(n+N)=x(n)$</li>
</ul>
</li>
<li><p>对称(偶)和反对称(奇)信号</p>
<ul>
<li>$x(-n)=x(n)$</li>
<li>$x(-n)=-x(n)$</li>
</ul>
</li>
<li><p>因果系统和非因果系统</p>
</li>
<li><p>稳定系统与不稳定系统</p>
</li>
</ul>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>Find命令使用</title>
    <url>/2020/01/08/Find%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="find命令的使用"><a href="#find命令的使用" class="headerlink" title="find命令的使用"></a>find命令的使用</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find [起始目录] 寻找条件 操作</span><br><span class="line">find PATH OPTION [-exec COMMAND &#123; &#125; \;]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Option-寻找条件"><a href="#Option-寻找条件" class="headerlink" title="Option 寻找条件"></a>Option 寻找条件</h2><p>寻找条件可以是一个用逻辑运算符 not、and、or 组成的复合条件。逻辑运 算符 and、or、not 的含义为：</p>
<ol>
<li><code>and</code>：逻辑与，在命令中用<code>-a</code>表示，是系统缺省的选项，表示只有当所给的条 件都满足时，寻找条件才算满足。例如：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find path –name 'tmp' –xtype c -user 'inin'</span><br></pre></td></tr></table></figure>
<p>该命令寻找三个给定条件都满足的所有文件</p>
<ol>
<li><code>or</code>：逻辑或，在命令中用<code>-o</code>表示。该运算符表示只要所给的条件中有一个满足 时，寻找条件就算满足。例如：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find path –name 'tmp' –o –name 'mina*'</span><br></pre></td></tr></table></figure>
<p>该命令查询文件名为’tmp’或是匹配’mina*’的所有文件。</p>
<ol>
<li><code>not</code>：逻辑非，在命令中用<code>!</code>表示。该运算符表示查找不满足所给条件的文件 。例如：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find ! –name 'tmp'</span><br></pre></td></tr></table></figure>
<p>该命令查询文件名不是’tmp’的所有文件。</p>
<p>Tips:当使用很多的逻辑选项时，可以用括号把这些选项括起来。为了避免Shell本身对括号引起误解，在话号前需要加转义字符“\”来去除括号的意义。例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find \(–name 'tmp' –xtype c -user 'inin' \)</span><br></pre></td></tr></table></figure>
<ol>
<li>具体参数：</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>-name ’字串’</td>
<td>查找文件名匹配所给字串的所有文件，字串内可用通配符 *、?、[ ]。</td>
</tr>
<tr>
<td>-lname ’字串’</td>
<td>查找文件名匹配所给字串的所有符号链接文件，字串内可用通配符 *、?、[ ]。</td>
</tr>
<tr>
<td>-gid n</td>
<td>查找属于ID号为 n 的用户组的所有文件。</td>
</tr>
<tr>
<td>-uid n</td>
<td>查找属于ID号为 n 的用户的所有文件。</td>
</tr>
<tr>
<td>-group ’字串’</td>
<td>查找属于用户组名为所给字串的所有的文件。</td>
</tr>
<tr>
<td>-user ’字串’</td>
<td>查找属于用户名为所给字串的所有的文件。</td>
</tr>
<tr>
<td>-empty</td>
<td>查找大小为 0的目录或文件。</td>
</tr>
<tr>
<td>-path ’字串’</td>
<td>查找路径名匹配所给字串的所有文件，字串内可用通配符*、?、[ ]。</td>
</tr>
<tr>
<td>-perm 权限</td>
<td>查找具有指定权限的文件和目录，权限的表示可以如711，644。</td>
</tr>
<tr>
<td>-size n[bckw]</td>
<td>查找指定文件大小的文件，n 后面的字符表示单位，缺省为 b，代表512字节的块。</td>
</tr>
<tr>
<td>-type x</td>
<td>查找类型为 x 的文件，x 为下列字符之一：b 块设备文件;c 字符设备文件;d 目录文件;p 命名管道(FIFO);f 普通文件;l 符号链接文件(symbolic links);s socket文件</td>
</tr>
<tr>
<td>-amin n</td>
<td>查找n分钟以前被访问过的所有文件。</td>
</tr>
<tr>
<td>-atime n</td>
<td>查找n天以前被访问过的所有文件。</td>
</tr>
<tr>
<td>-cmin n</td>
<td>查找n分钟以前文件状态被修改过的所有文件。</td>
</tr>
<tr>
<td>-ctime n</td>
<td>查找n天以前文件状态被修改过的所有文件。</td>
</tr>
<tr>
<td>-mmin n</td>
<td>查找n分钟以前文件内容被修改过的所有文件。</td>
</tr>
<tr>
<td>-mtime n</td>
<td>查找n天以前文件内容被修改过的所有文件。</td>
</tr>
<tr>
<td>-print：</td>
<td>将搜索结果输出到标准输出。</td>
</tr>
</tbody>
</table>
</div>
<p>例子：在root以及子目录查找不包括目录/root/bin的，greek用户的，文件类型为普通文件的，3天之前的名为test-find.c的文件，并将结构输出，find命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -name "test-find.c" -type f -mtime +3 -user greek -prune /root/bin -print</span><br></pre></td></tr></table></figure>
<p>当然在这其中，-print是一个默认选项，我们不必刻意去配置它。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>-exec：对搜索的结构指令指定的shell命令。注意格式要正确：”-exec 命令 {} \;”</p>
<p>在}和\之间一定要有空格才行;</p>
<p>{}表示命令的参数即为所找到的文件;命令的末尾必须以“ \;”结束。</p>
<p>例子：对上述例子搜索出来的文件进行删除操作，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find / -name "test-find.c" -type f -mtime +3 -user greek -prune /root/bin -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p>find命令指令实例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . -name ‘main*’ -exec more &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p>查找当前目录中所有以main开头的文件，并显示这些文件的内容。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find . \(-name a.out - o -name ‘*.o’\) -atime +7 -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p>删除当前目录下所有一周之内没有被访问过的a .out或*.o文件。</p>
<p>命令中的“.”表示当前目录，此时 find 将从当前目录开始，逐个在其子目录中查找满足后面指定条件的文件。</p>
<p> “(” 和 “)” 表示括号()，其中的 “\” 称为转义符。之所以这样写是由于对 Shell 而言，(和)另有不同的含义，而不是这里的用于组合条件的用途。</p>
<p>“-name a.out” 是指要查找名为a.out的文件;</p>
<p> “-name ‘*.o’” 是指要查找所有名字以 .o 结尾的文件。</p>
<p>这两个 -name 之间的 -o 表示逻辑或(or)，即查找名字为a.out或名字以 .o结尾的文件。</p>
<p> find命令在当前目录及其子目录下找到这佯的文件之后，再进行判断，看其最后访问时间 是否在7天以前(条件 -atime +7)，若是，则对该文件执行命令 rm(-exec rm {} \;)。</p>
<p>其中 {} 代表当前查到的符合条件的文件名，\;则是语法所要求的。</p>
<p> 上述命令中第一行的最后一个 \ 是续行符。当命令太长而在一行写不下时，可输入一个 \，之后系统将显示一个 &gt;，指示用户继续输入命令。</p>
<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>链接：<a href="https://www.chinaz.com/server/2009/0807/85796.shtml" target="_blank" rel="noopener">https://www.chinaz.com/server/2009/0807/85796.shtml</a> </p>
]]></content>
      <categories>
        <category>技能</category>
      </categories>
  </entry>
  <entry>
    <title>GNN模型</title>
    <url>/2020/05/04/GNN%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="GNN-模型"><a href="#GNN-模型" class="headerlink" title="GNN 模型"></a>GNN 模型</h1><blockquote>
<p>GNN原始模型及其变种</p>
</blockquote>
<p>GNN的目标是学习一个状态嵌入$\mathbf{h}_v \in \mathbb{R}^s$，它包含每个节点相邻的信息，这个状态嵌入是节点v的s维度的向量表示，能够用来产生一个输出$\mathbf{o}_v$，这个输出可以是节点标签。$f$是一个参数化的函数，也叫做 $local\;transition\;function$，这个函数被所有节点共享，根据输入的相邻信息来更新节点状态。$g$是$local\;output\;function$，用来描述如何产生输出。</p>
<a id="more"></a>
<script type="math/tex; mode=display">
\begin{align}
& \mathbf{h}_v = f(\mathbf{x}_v,\mathbf{x}_{co[v]},\mathbf{h}_{ne[v]},\mathbf{x}_{ne[v]}) \\
& \mathbf{o}_v=g(\mathbf{h}_v,\mathbf{x}_v)
\end{align}</script><p>其中$\mathbf{x}<em>v,\mathbf{x}</em>{co[v]},\mathbf{h}<em>{ne[v]},\mathbf{x}</em>{ne[v]}$分别是节点$v$的特征、它的边的特征、$v$的邻居节点的状态和特征。</p>
<p>通过堆叠所有的状态、输出、特征和节点特征来构造$\mathbf{H},\mathbf{O},\mathbf{X},\mathbf{X}_N$。这样可以得到一个紧密的格式</p>
<script type="math/tex; mode=display">
\begin{align}
& \mathbf{H} = F(\mathbf{H},\mathbf{X}) \\
& \mathbf{O} = G(\mathbf{H},\mathbf{X}_N)
\end{align}</script><p>其中$F$是$global\;transition\;function$，$G$是$global\;output\;function$，它们将图中所有节点上的$f$和$g$叠加而成。</p>
<p>GNN使用下面经典的迭代格式来计算状态</p>
<script type="math/tex; mode=display">
\begin{align}
& \mathbf{H}^{t+1} = F(\mathbf{H}^t,\mathbf{X})
\end{align}</script><p>$\mathbf{H}^t$记作第t次迭代的$\mathbf{H}$。</p>
<p>$f$和$g$的计算可以描述为前向神经网络。</p>
<p>当在监督学习中，有着明确的目标值，loss可以被定义为如下：</p>
<script type="math/tex; mode=display">
\begin{align}
& loss = \sum_{i=1}^p (\mathbf{t}_i-\mathbf{o}_i)
\end{align}</script><p>其中p是被监督的节点的数量，学习算法是基于梯度下降的策略的。</p>
<p>限制</p>
<ol>
<li>对固定点来迭代的更新节点的隐藏状态是无效的，如果放宽固定点的假设，可以设计一个多层的GNN来获得节点和相邻的稳定表示。</li>
<li>GNN在迭代中使用一样的参数，然而大多数流行的神经网络在不同的层使用不同的参数，这被认为是一种分层特征提取方法。同时，节点隐藏状态的更新是一种顺序过程。</li>
<li>在原始的GNN中，边的一些信息无法被有效的建模。比如知识图谱中的边有关系的类型和传播的信息。</li>
<li>如何学习边的隐藏状态也是一个问题。</li>
<li>如果关注节点的表示而不是图的表示，使用固定点是不合适的，因为固定点的表示值更加平滑，只有较少的信息来区分每个节点。</li>
</ol>
<h2 id="Graph-Types"><a href="#Graph-Types" class="headerlink" title="Graph Types"></a>Graph Types</h2><blockquote>
<p>原始的GNN中，输入的图具有标签信息的节点和没有方向的边组成，这是最简单的图的格式。</p>
</blockquote>
<h3 id="Directed-Graphs"><a href="#Directed-Graphs" class="headerlink" title="Directed Graphs"></a>Directed Graphs</h3><p>无向的边可以额被看成两个有向的边，表示了两个即结点之间的联系。然而，有向边比无向边具有更多的信息。例如，在知识图谱中，有向边的起点是头节点，结尾是尾节点，表示信息的传播过程是有向的。</p>
<p>DGP使用两种权值矩阵$\mathbf{W}_p,\mathbf{W}_c$来表示更详细的结构信息。传播规则能够采用如下的方式表示：</p>
<script type="math/tex; mode=display">
\begin{align}
& \mathbf{H} = \sigma(\mathbf{D}_p^{-1}\mathbf{A}_P\sigma(\mathbf{D}_c^{-1}\mathbf{A}_c\mathbf{H}^{t-1}\mathbf{W}_c)\mathbf{W}_p)
\end{align}</script><p>其中$\mathbf{D}_p^{-1}\mathbf{A}_P,\mathbf{D}_c^{-1}\mathbf{A}_c$分别是头节点和尾节点的标准化的邻接矩阵。</p>
<h3 id="Heterogeneous-Graphs"><a href="#Heterogeneous-Graphs" class="headerlink" title="Heterogeneous Graphs"></a>Heterogeneous Graphs</h3><p>异质图，有多种类型节点。</p>
<p>处理异质图最简单的方式是将每个节点的类型转为 one-hot特征向量，将它和原始的特征合在一起。GraphInception将元路径的概念引入了异构图的传播中。借助元路径，我们可以根据节点的类型和距离对邻居进行分组。</p>
<h3 id="Graph-with-Edge-Information"><a href="#Graph-with-Edge-Information" class="headerlink" title="Graph with Edge Information"></a>Graph with Edge Information</h3><p>每条边有额外的信息，比如权重和边的类型，主要有两种方法来处理这类的图</p>
<ol>
<li><p>可以将图转换成一个二分图，图中原始的边变成节点，一条原始的边被分成两个新的边，这表示在新的边节点和原来的开始／结束节点有两条新的边。G2S中的encoder对邻居使用了下面的聚合函数：</p>
<script type="math/tex; mode=display">
\begin{align}
\mathbf{h}_v^t = \rho(\frac{1}{|\mathcal{N}_v|}\sum_{u\in \mathcal{N}_v } \mathbf{W}_r(\mathbf{r}_v^t\odot\mathbf{h}_u^{t-1})+\mathbf{b}_r)
\end{align}</script><p>其中$\mathbf{W}_r，\mathbf{b}_r$是不同类型的边的传播参数。</p>
</li>
<li><p>对不同类型节点上的传播使用不同的权值矩阵。当关系的数目非常大的时候，R-GCN介绍了两种正则化来减少对关系建模的参数的数量，这两种分别是：$basis/block-diagonal-decomposition$（对角分解和块对角分解）。</p>
<p>使用基础的对角分解，每个$\mathbf{W}_r$被定义成如下：</p>
<script type="math/tex; mode=display">
\begin{align}
& \mathbf{W}_r = \sum_1^{B} a_{rb}\mathbf{V}_b
\end{align}</script><p>其中，每个$\mathbf{W}<em>r$都是系数为$a</em>{rb}$的基础变换$\mathbf{V}<em>b \in \mathbb{R}^{d</em>{in} \times d_{out}} $的线性组合。</p>
<p>对于块对角分解，R-GCN定义$\mathbf{W}_r$为一系列低维矩阵的和，这就比基础分解需要更多的参数。</p>
</li>
</ol>
<h3 id="Dynamic-Graphs"><a href="#Dynamic-Graphs" class="headerlink" title="Dynamic Graphs"></a>Dynamic Graphs</h3><p>动态图有着静态的图结构和动态的输入信息。</p>
<p>为了捕捉信息的种类，DCRNN和STGCN首先通过GNN来手机空间信息，然后，将得到的输出输入到序列模型中，比如在seq-2-seq模型或者CNNs。不同的是，Structural-RNN 和ST-GCN同时收集空间信息和时间信息。它们使用时间上的连接来扩展静态图，因此可以用传统的GNNs。</p>
<p><img src="/images/GNN/GraphType.png" alt="GraphType"></p>
<p><img src="/images/GNN/TrainingMethods.png" alt="TrainingMethods"></p>
<p><img src="/images/GNN/PropagationSteps.png" alt="PropagationSteps"></p>
<p><a href="https://arxiv.org/abs/1812.08434" target="_blank" rel="noopener">https://arxiv.org/abs/1812.08434</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>Ement</title>
    <url>/2019/06/28/Ement/</url>
    <content><![CDATA[<h2 id="Ement-语法"><a href="#Ement-语法" class="headerlink" title="Ement 语法"></a>Ement 语法</h2><ol>
<li><p>生成 html 框架</p>
<ul>
<li>使用<code>!</code> 或者 <code>html:5</code> 生成 html5基本代码</li>
<li>使用 <code>html:xt</code> 和 <code>html:4s</code> 生成html4过渡型和严格型</li>
</ul>
</li>
<li><p>生成帯<code>class</code> 和 <code>id</code>的标签</p>
<ul>
<li>生成<code>class</code>的标签 标签名<code>.class</code>名。例：<code>div.aaa</code></li>
<li>生成<code>id</code>的标签 标签名<code>#id</code>名。<code>div#aaa</code></li>
</ul>
</li>
<li><p>生成后代：<code>&gt;</code></p>
<ul>
<li><code>div.aaa&gt;ul&gt;li</code></li>
</ul>
</li>
<li><p>生成兄弟：<code>+</code></p>
<blockquote>
<p>同级的标签</p>
</blockquote>
<ul>
<li><code>div.aaa+div.bbb</code></li>
</ul>
</li>
<li><p>生成上级: <code>^</code></p>
<ul>
<li><code>div&gt;ul&gt;li^span</code></li>
</ul>
</li>
<li><p>生成多个元素：<code>*</code></p>
<ul>
<li><code>div&gt;ul&gt;li*5</code></li>
</ul>
</li>
<li><p>生成分组：<code>()</code></p>
<blockquote>
<p>用括号进行分组，这样可以更加明确要生成的结构，特别是层次关系，例如：</p>
<ul>
<li><code>div&gt;(header&gt;ul&gt;li*2&gt;a)+footer&gt;p</code></li>
</ul>
</blockquote>
</li>
<li><p>生成自定义属性：<code>[attr]</code></p>
<ul>
<li><code>a[href=&quot;www.taobao.com&quot; title=&quot;淘宝&quot;]</code></li>
</ul>
</li>
<li><p>对生成内容编号：<code>$</code></p>
<ul>
<li><code>ul&gt;li.item$*5</code></li>
<li><code>ul&gt;li.item$$$*5</code></li>
<li>指定倒序排序，加<code>@-</code>: <code>ul&gt;li.item$@-*5</code></li>
<li>制定开始的编号，加<code>@N</code>: <code>ul&gt;li.item$@2*5</code></li>
<li>倒序和制定编号合体：<code>ul&gt;li.item$@-3*5</code></li>
</ul>
</li>
<li><p>生成文本内容：<code>{}</code></p>
<ul>
<li><code>a{click}+span{text}</code></li>
</ul>
</li>
<li><p><strong>注： 不要有空格</strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>技能</category>
      </categories>
  </entry>
  <entry>
    <title>Go语言学习</title>
    <url>/2020/01/18/Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Go语言学习"><a href="#Go语言学习" class="headerlink" title="Go语言学习"></a>Go语言学习</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ol>
<li>布尔型<br>布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。</li>
<li>数字类型<br>整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</li>
<li>字符串类型:<br>字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。</li>
<li>派生类型:<br>包括：<ul>
<li>指针类型（Pointer）</li>
<li>数组类型</li>
<li>结构化类型(struct)</li>
<li>Channel 类型</li>
<li>函数类型</li>
<li>切片类型</li>
<li>接口类型（interface）</li>
<li>Map 类型</li>
</ul>
</li>
</ol>
<h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h2><p><a href="https://blog.csdn.net/xiaoyida11/article/details/51554022" target="_blank" rel="noopener">参考链接</a></p>
<h2 id="变量-variance"><a href="#变量-variance" class="headerlink" title="变量 variance"></a>变量 variance</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span> = <span class="string">"string"</span></span><br><span class="line"><span class="keyword">var</span> vname vtype <span class="comment">//自动赋初始值 </span></span><br><span class="line">vname = value</span><br><span class="line"><span class="keyword">var</span> v_name = value <span class="comment">// 自动判断类型</span></span><br><span class="line">v_name := value <span class="comment">// 声明新的变量，v_name 不是新变量编译出错</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>数值类型（包括complex64/128）为 0</p>
</li>
<li><p>布尔类型为 false</p>
</li>
<li><p>字符串为 “”（空字符串）</p>
</li>
<li><p>以下几种类型为 nil：</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> a <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="keyword">var</span> a error <span class="comment">// error 是接口</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型相同多个变量, 非全局变量</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span></span><br><span class="line">vname1, vname2, vname3 = v1, v2, v3</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 = v1, v2, v3 <span class="comment">// 和 python 很像,不需要显示声明类型，自动推断</span></span><br><span class="line"></span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3 <span class="comment">// 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种因式分解关键字的写法一般用于声明全局变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    vname1 v_type1</span><br><span class="line">    vname2 v_type2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>值类型和引用类型</p>
<blockquote>
<p>所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值：</p>
</blockquote>
<p>通过 <code>&amp;i</code> 来获取变量 <code>i</code> 的内存地址</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> identifier [<span class="keyword">type</span>] = value</span><br><span class="line"><span class="keyword">const</span> c_name1, c_name2 = value1, value2</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Unknown = <span class="number">0</span></span><br><span class="line">    Female = <span class="number">1</span></span><br><span class="line">    Male = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>iota</p>
<blockquote>
<p>iota，特殊常量，可以认为是一个可以被编译器修改的常量。<br>iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a = <span class="literal">iota</span>   <span class="comment">//0</span></span><br><span class="line">	b          <span class="comment">//1</span></span><br><span class="line">	c          <span class="comment">//2</span></span><br><span class="line">	d = <span class="string">"ha"</span>   <span class="comment">//独立值，iota += 1</span></span><br><span class="line">	e          <span class="comment">//"ha"   iota += 1</span></span><br><span class="line">	f = <span class="number">100</span>    <span class="comment">//iota +=1</span></span><br><span class="line">	g          <span class="comment">//100  iota +=1</span></span><br><span class="line">	h = <span class="literal">iota</span>   <span class="comment">//7,恢复计数</span></span><br><span class="line">	i          <span class="comment">//8</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>赋值运算符</li>
<li>其他运算符</li>
</ul>
<p>运算符优先级</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>* / % &lt;&lt; &gt;&gt; &amp; &amp;^</td>
</tr>
<tr>
<td>4</td>
<td>+ - \</td>
<td>\^</td>
</tr>
<tr>
<td>3</td>
<td>== != &lt; &lt;= &gt; &gt;=</td>
</tr>
<tr>
<td>2</td>
<td>&amp;&amp;</td>
</tr>
<tr>
<td>1</td>
<td>\</td>
<td>\</td>
</tr>
</tbody>
</table>
</div>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 布尔表达式 &#123;</span><br><span class="line">   <span class="comment">/* 在布尔表达式为 true 时执行 */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/* 在布尔表达式为 false 时执行 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s);      </span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s); </span><br><span class="line">    <span class="comment">/* 你可以定义任意个数的case */</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 fallthrough 会强制执行后面的 case 语句，fallthrough 不会判断下一条 case 的表达式结果是否为 true。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">            fmt.Println(<span class="string">"1、case 条件语句为 false"</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">            fmt.Println(<span class="string">"2、case 条件语句为 true"</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">            fmt.Println(<span class="string">"3、case 条件语句为 false"</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">            fmt.Println(<span class="string">"4、case 条件语句为 true"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">            fmt.Println(<span class="string">"5、case 条件语句为 false"</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">"6、默认 case"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。</p>
<p>select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s);      </span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s);</span><br><span class="line">    <span class="comment">/* 你可以定义任意数量的 case */</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每个 case 都必须是一个通信</li>
<li>所有 channel 表达式都会被求值</li>
<li>所有被发送的表达式都会被求值</li>
<li>如果任意某个通信可以进行，它就执行，其他被忽略。</li>
<li>如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。</li>
<li>否则：<ul>
<li>如果有 default 子句，则执行该语句。</li>
<li>如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。</li>
</ul>
</li>
</ul>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> [condition |  ( init; condition; increment ) | Range]</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span> [condition |  ( init; condition; increment ) | Range]</span><br><span class="line">   &#123;</span><br><span class="line">      statement(s);</span><br><span class="line">   &#125;</span><br><span class="line">   statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>break</li>
<li>continue</li>
<li>goto</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span> [<span class="title">return_types</span>]</span> &#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>func：函数由 func 开始声明</li>
<li>function_name：函数名称，函数名和参数列表一起构成了函数签名。</li>
<li>parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li>
<li>return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</li>
<li>函数体：函数定义的代码集合。</li>
</ul>
<p>函数参数</p>
<ul>
<li><p>值传递</p>
<blockquote>
<p>默认</p>
</blockquote>
</li>
<li><p>引用传递</p>
<blockquote>
<p>引用传递指针参数传递到函数内</p>
</blockquote>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义交换值函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x *<span class="keyword">int</span>, y *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="keyword">int</span></span><br><span class="line">   temp = *x    <span class="comment">/* 保持 x 地址上的值 */</span></span><br><span class="line">   *x = *y      <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">   *y = temp    <span class="comment">/* 将 temp 值赋给 y */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数用法</p>
<ul>
<li>函数作为另外一个函数的实参：函数定义后可作为另外一个函数的实参数传入</li>
<li>闭包：闭包是匿名函数，可在动态编程中使用</li>
<li><p>方法：方法就是一个包含了接受者的函数</p>
<blockquote>
<p>Go 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。</p>
</blockquote>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(variable_name variable_data_type)</span> <span class="title">function_name</span><span class="params">()</span> [<span class="title">return_type</span>]</span>&#123;</span><br><span class="line">   <span class="comment">/* 函数体*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>变量声明的位置</p>
<ul>
<li><p>函数内定义的变量称为局部变量</p>
<blockquote>
<p>作用域只在函数体内，参数和返回值变量也是局部变量。</p>
</blockquote>
</li>
<li><p>函数外定义的变量称为全局变量</p>
<blockquote>
<p>全局变量可以在整个包甚至外部包（被导出后）使用。</p>
</blockquote>
</li>
<li>函数定义中的变量称为形式参数<blockquote>
<p>形式参数会作为函数的局部变量来使用。</p>
</blockquote>
</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>声明数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE] variable_type</span><br></pre></td></tr></table></figure>
<p>初始化数组<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> balance = [<span class="number">5</span>]<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line"><span class="keyword">var</span> balance = [...]<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line">balance[<span class="number">4</span>] = <span class="number">50.0</span></span><br></pre></td></tr></table></figure></p>
<p>多维数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE1][SIZE2]...[SIZEN] variable_type</span><br><span class="line">a = [<span class="number">3</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;  </span><br><span class="line"> &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ,   <span class="comment">/*  第一行索引为 0 */</span></span><br><span class="line"> &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; ,   <span class="comment">/*  第二行索引为 1 */</span></span><br><span class="line"> &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;,   <span class="comment">/* 第三行索引为 2 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组参数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">void myFunction(param [<span class="number">10</span>]<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void myFunction(param []<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> var_name *<span class="keyword">var</span>-<span class="keyword">type</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span>= <span class="number">20</span>   <span class="comment">/* 声明实际变量 */</span></span><br><span class="line">   <span class="keyword">var</span> ip *<span class="keyword">int</span>        <span class="comment">/* 声明指针变量 */</span></span><br><span class="line"></span><br><span class="line">   ip = &amp;a  <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line"></span><br><span class="line">   fmt.Printf(<span class="string">"a 变量的地址是: %x\n"</span>, &amp;a  )</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line">   fmt.Printf(<span class="string">"ip 变量储存的指针地址: %x\n"</span>, ip )</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 使用指针访问值 */</span></span><br><span class="line">   fmt.Printf(<span class="string">"*ip 变量的值: %d\n"</span>, *ip )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> struct_variable_type <span class="keyword">struct</span> &#123;</span><br><span class="line">   member definition</span><br><span class="line">   member definition</span><br><span class="line">   ...</span><br><span class="line">   member definition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">variable_name := structure_variable_type &#123;value1, value2...valuen&#125;</span><br><span class="line">或</span><br><span class="line">variable_name := structure_variable_type &#123; key1: value1, key2: value2..., keyn: valuen&#125;</span><br></pre></td></tr></table></figure>
<p>访问成员：<code>结构体.成员名</code></p>
<p>结构体指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> struct_pointer *Books</span><br></pre></td></tr></table></figure>
<h2 id="切片-Slice"><a href="#切片-Slice" class="headerlink" title="切片 Slice"></a>切片 Slice</h2><p>声明一个未指定大小的数组来定义切片<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier []<span class="keyword">type</span></span><br></pre></td></tr></table></figure></p>
<p>使用make()函数来创建切片:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">make</span>([]T, length, capacity)</span><br></pre></td></tr></table></figure>
<ul>
<li>length 初始长度</li>
<li>capacity 容量</li>
</ul>
<p>初始化切片</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s :=[] <span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125; </span><br><span class="line">s := arr[:] </span><br><span class="line">s := arr[startIndex:endIndex] </span><br><span class="line">s := arr[startIndex:] </span><br><span class="line">s := arr[:endIndex] </span><br><span class="line">s1 := s[startIndex:endIndex] </span><br><span class="line">s :=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>)</span><br></pre></td></tr></table></figure>
<p>len() 和 cap() 函数</p>
<ul>
<li>切片是可索引的，并且可以由 len() 方法获取长度。</li>
<li>切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。</li>
</ul>
<p>一个切片在未初始化之前默认为 nil，长度为 0，实例如下：</p>
<p>切片截取<br>设置下限及上限来设置截取切片 <code>[lower-bound:upper-bound]</code></p>
<p>append() 和 copy() 函数</p>
<ul>
<li>拷贝切片的 copy 方法</li>
<li>向切片追加新元素的 append 方法</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers []<span class="keyword">int</span></span><br><span class="line"><span class="comment">/* 允许追加空切片 */</span></span><br><span class="line">numbers = <span class="built_in">append</span>(numbers, <span class="number">0</span>)</span><br><span class="line"><span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line"><span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span></span><br><span class="line">numbers1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(numbers), (<span class="built_in">cap</span>(numbers))*<span class="number">2</span>)</span><br><span class="line"><span class="comment">/* 拷贝 numbers 的内容到 numbers1 */</span></span><br><span class="line"><span class="built_in">copy</span>(numbers1,numbers)</span><br></pre></td></tr></table></figure>
<h2 id="Range-范围"><a href="#Range-范围" class="headerlink" title="Range 范围"></a>Range 范围</h2><blockquote>
<p>Go 语言中 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对。</p>
</blockquote>
<h2 id="Map-集合"><a href="#Map-集合" class="headerlink" title="Map(集合)"></a>Map(集合)</h2><blockquote>
<p>Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。<br>Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。</p>
</blockquote>
<p>定义 Map</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明变量，默认 map 是 nil */</span></span><br><span class="line"><span class="keyword">var</span> map_variable <span class="keyword">map</span>[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 make 函数 */</span></span><br><span class="line">map_variable := <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">   fmt.Println(country, <span class="string">"首都是"</span>, countryCapitalMap [country])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*查看元素在集合中是否存在 */</span></span><br><span class="line">capital, ok := countryCapitalMap [ <span class="string">"American"</span> ] <span class="comment">/*如果确定是真实的,则存在,否则不存在 */</span></span><br><span class="line"><span class="keyword">if</span> (ok) &#123;</span><br><span class="line">    fmt.Println(<span class="string">"American 的首都是"</span>, capital)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"American 的首都不存在"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>delete() 函数</p>
<blockquote>
<p>delete() 函数用于删除集合的元素, 参数为 map 和其对应的 key。实例如下：</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delete</span>(countryCapitalMap, <span class="string">"Key"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">type_name(expression)</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> sum <span class="keyword">int</span> = <span class="number">17</span></span><br><span class="line">   <span class="keyword">var</span> count <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line">   <span class="keyword">var</span> mean <span class="keyword">float32</span></span><br><span class="line">   </span><br><span class="line">   mean = <span class="keyword">float32</span>(sum)/<span class="keyword">float32</span>(count)</span><br><span class="line">   fmt.Printf(<span class="string">"mean 的值为: %f\n"</span>,mean)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义接口 */</span></span><br><span class="line"><span class="keyword">type</span> interface_name <span class="keyword">interface</span> &#123;</span><br><span class="line">   method_name1 [return_type]</span><br><span class="line">   method_name2 [return_type]</span><br><span class="line">   method_name3 [return_type]</span><br><span class="line">   ...</span><br><span class="line">   method_namen [return_type]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体 */</span></span><br><span class="line"><span class="keyword">type</span> struct_name <span class="keyword">struct</span> &#123;</span><br><span class="line">   <span class="comment">/* variables */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 实现接口方法 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span> <span class="title">method_name1</span><span class="params">()</span> [<span class="title">return_type</span>]</span> &#123;</span><br><span class="line">   <span class="comment">/* 方法实现 */</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(struct_name_variable struct_name)</span> <span class="title">method_namen</span><span class="params">()</span> [<span class="title">return_type</span>]</span> &#123;</span><br><span class="line">   <span class="comment">/* 方法实现*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>Go 语言通过内置的错误接口提供了非常简单的错误处理机制。</p>
<p>error类型是一个接口类型，这是它的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(f <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">"math: square root of negative number"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>Go 语言支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。</p>
<p>goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。</p>
<p>goroutine 语法格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> 函数名( 参数列表 )</span><br></pre></td></tr></table></figure>
<p>通道（channel）:是用来传递数据的一个数据结构。</p>
<blockquote>
<p>通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 &lt;- 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// 把 v 发送到通道 ch</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从 ch 接收数据</span></span><br><span class="line">           <span class="comment">// 并把值赋给 v</span></span><br></pre></td></tr></table></figure>
<p>声明一个通道很简单，我们使用chan关键字即可，通道在使用前必须先创建：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p>通道缓冲区<br>Channel buffer<br>通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。</p>
<p>不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。</p>
<p>注意：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</p>
<p>Go 遍历通道与关闭通道</p>
<p>通过 <code>range</code> 关键字来实现遍历读取到的数据，类似于与数组或切片。格式如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v, ok := &lt;-ch</span><br></pre></td></tr></table></figure>
<p>如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 close() 函数来关闭。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">                c &lt;- x</span><br><span class="line">                x, y = y, x+y</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">        <span class="comment">// range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个</span></span><br><span class="line">        <span class="comment">// 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据</span></span><br><span class="line">        <span class="comment">// 之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不</span></span><br><span class="line">        <span class="comment">// 会结束，从而在接收第 11 个数据的时候就阻塞了。</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">                fmt.Println(i)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
  </entry>
  <entry>
    <title>Keras初体验</title>
    <url>/2019/11/29/Keras%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="Keras-初体验"><a href="#Keras-初体验" class="headerlink" title="Keras 初体验"></a>Keras 初体验</h1><h2 id="使用内置struct加载mnist手写字符数据集"><a href="#使用内置struct加载mnist手写字符数据集" class="headerlink" title="使用内置struct加载mnist手写字符数据集"></a>使用内置<code>struct</code>加载<code>mnist</code>手写字符数据集</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load mnist dataset</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadImageSet</span><span class="params">(filename)</span>:</span></span><br><span class="line">    imgfile = open(filename, <span class="string">'rb'</span>)</span><br><span class="line">    buffers = imgfile.read()</span><br><span class="line"></span><br><span class="line">    head = struct.unpack_from(<span class="string">'&gt;IIII'</span>, buffers, <span class="number">0</span>)<span class="comment"># 读取前四个int，解析返回列表</span></span><br><span class="line">    offset = struct.calcsize(<span class="string">'&gt;IIII'</span>) <span class="comment"># 计算前四个int大小</span></span><br><span class="line"></span><br><span class="line">    imgNum = head[<span class="number">1</span>]</span><br><span class="line">    width = head[<span class="number">2</span>]</span><br><span class="line">    height = head[<span class="number">3</span>]</span><br><span class="line">    bits = imgNum*width*height</span><br><span class="line">    bitstr = <span class="string">'&gt;'</span>+str(bits)+<span class="string">'B'</span></span><br><span class="line">    print(bitstr)</span><br><span class="line">    data = struct.unpack_from(bitstr, buffers, offset)</span><br><span class="line">    data = np.reshape(data, (imgNum, width*height))</span><br><span class="line">    imgfile.close()</span><br><span class="line">    <span class="keyword">return</span> data, head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadLabel</span><span class="params">(filename)</span>:</span></span><br><span class="line">    imgfile = open(filename, <span class="string">'rb'</span>)</span><br><span class="line">    buffers = imgfile.read()</span><br><span class="line"></span><br><span class="line">    head = struct.unpack_from(<span class="string">'&gt;II'</span>, buffers, <span class="number">0</span>)</span><br><span class="line">    offset = struct.calcsize(<span class="string">'&gt;II'</span>)</span><br><span class="line"></span><br><span class="line">    imgNum = head[<span class="number">1</span>]</span><br><span class="line">    bits = imgNum</span><br><span class="line">    bitstr = <span class="string">'&gt;'</span>+str(bits)+<span class="string">'B'</span></span><br><span class="line">    print(bitstr)</span><br><span class="line">    data = struct.unpack_from(bitstr, buffers, offset)</span><br><span class="line">    data = np.reshape(data, (imgNum, <span class="number">1</span>))</span><br><span class="line">    imgfile.close()</span><br><span class="line">    <span class="keyword">return</span> data, head</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">train_data, train_head = loadImageSet(<span class="string">'./mnist/train-images.idx3-ubyte'</span>)</span><br><span class="line">label_data, label_head = loadLabel(<span class="string">'./mnist/train-labels-idx1-ubyte'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Train\n"</span>)</span><br><span class="line">print(<span class="string">f'Head information:<span class="subst">&#123;train_head&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'Shape:<span class="subst">&#123;train_data.shape&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Label\n"</span>)</span><br><span class="line">print(<span class="string">f'Head information:<span class="subst">&#123;label_head&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'Shape:<span class="subst">&#123;label_data.shape&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="构建模型并训练"><a href="#构建模型并训练" class="headerlink" title="构建模型并训练"></a>构建模型并训练</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one_hot</span><span class="params">(data,n)</span>:</span></span><br><span class="line">    num = data.shape[<span class="number">0</span>]</span><br><span class="line">    res = np.zeros((num,n))</span><br><span class="line">    <span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(data):</span><br><span class="line">        res[i,v]= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">label_data = one_hot(label_data,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line"></span><br><span class="line">model.add(Dense(input_dim=<span class="number">28</span>*<span class="number">28</span>, units=<span class="number">500</span>,activation=<span class="string">'sigmoid'</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">500</span>,activation=<span class="string">'sigmoid'</span>))</span><br><span class="line">model.add(Dense(units=<span class="number">10</span>,activation=<span class="string">'softmax'</span>))</span><br><span class="line"></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,</span><br><span class="line">              optimizer=<span class="string">'adam'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line"></span><br><span class="line">model.fit(train_data, label_y, batch_size=<span class="number">100</span>, epochs=<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<h2 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test_data = loadImageSet(<span class="string">'./mnist/t10k-images-idx3-ubyte'</span>)[<span class="number">0</span>]</span><br><span class="line">test_label = one_hot(loadLabel(<span class="string">'./mnist/t10k-labels-idx1-ubyte'</span>)[<span class="number">0</span>],<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">score = model.evaluate(test_data,test_label)</span><br><span class="line">print(<span class="string">'Total loss on Testing Set:'</span>,score[<span class="number">0</span>])</span><br><span class="line">print(<span class="string">'Accuracy of  Testing Set:'</span>,score[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>LSTM的前世今生未来</title>
    <url>/2020/03/03/LSTM%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F%E6%9C%AA%E6%9D%A5/</url>
    <content><![CDATA[<h1 id="LSTM的理解、推导、扩展"><a href="#LSTM的理解、推导、扩展" class="headerlink" title="LSTM的理解、推导、扩展"></a>LSTM的理解、推导、扩展</h1><p><a href="https://r2rt.com/written-memories-understanding-deriving-and-extending-the-lstm.html" target="_blank" rel="noopener">https://r2rt.com/written-memories-understanding-deriving-and-extending-the-lstm.html</a></p>
<h2 id="RNN-Recurrent-neural-networks-回归神经网络"><a href="#RNN-Recurrent-neural-networks-回归神经网络" class="headerlink" title="RNN(Recurrent neural networks) 回归神经网络"></a>RNN(Recurrent neural networks) 回归神经网络</h2><p>从一个时刻到下一个时刻，我们的大脑像一个功能在不停运作：接受外在的信息，产生内在的想法，并采取行动和产生新的想法。当我们看到熊的图片，我们可能会想到“熊”这个单词。这种行为可以用Feedforward neural network来模拟。</p>
<p>但是我们的大脑并不只是一次的运行，它在不停的反复运行，根据之前的经验，不断产生新的想法。这是一个循环的过程。因此我们可以用RNN来建模。</p>
<p>RNN由相同的前馈神经网络组成，每个时间刻或时间步长，我们将其称为RNN cell。这是RNN的最为广泛的定义。</p>
<p>单个RNN Cell</p>
<p><img src="/images/LSTM/NH_SingleRNNcell.png" alt=""></p>
<p>三个RNN Cells</p>
<p><img src="/images/LSTM/NH_ComposedRNNcells.png" alt=""></p>
<p>我们将周期性的输出看作可以传到下一个timestep的“状态”，因此RNN Cell接受先前的转台和当前的输入。</p>
<p>RNN Cell数学描述</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
S_t \\
O_t
\end{pmatrix}
=f
\begin{pmatrix}
S_{t-1} \\
x_t
\end{pmatrix}</script><ul>
<li>$s<em>t\;and\;s</em>{t-1}$是当前的状态和之前的转台</li>
<li>$o_t$是我们当前的输出</li>
<li>$x_t$是当前的输入（可以为空的）</li>
<li>$f$是我们的循环函数</li>
</ul>
<p>我们的大脑就是类似的运作，当前的活动取代之前的活动。因为每个RNN Cell是相同的，它们被看作一样的，每个timestep的RNN Cell的状态被覆盖。</p>
<p><img src="/images/LSTM/NH_StateLoop.png" alt=""></p>
<h2 id="RNNs能够做什么；选择timestep"><a href="#RNNs能够做什么；选择timestep" class="headerlink" title="RNNs能够做什么；选择timestep"></a>RNNs能够做什么；选择timestep</h2><p>RNN的结构非常的常见的，理论上，它可以做任何事。如果我们给这个NN内部的每个Cell至少一个隐含层，每个Cell就变成了一个通用的函数近似器。这就意味着 RNN Cell 能够模拟任何函数。理论上可以模拟大脑。但是实际上训练和设计一个RNN完成这样的任务是完全不同的。</p>
<p>通过将RNN和大脑进行类比，我们可以将使用RNN处理任务就是一个人类来处理同样的任务。</p>
<p>比如，当考虑英语到发育的翻译。一个人读一个句子<code>the cate sat on the mat</code>，停顿一个然后写出了法语的<code>le chat s&#39;assit sur le tapis</code>。为了使用RNN模拟这个行为，我们唯一的选择就决定每个timestep应该做了什么，它决定输入和输出的形式以及如何和外部的世界相互作用。</p>
<p>其中一个选择，根据内容设置timestep，也就是将完整的句子作为一个timestep，这种情况下，RNN变成了 FNN。</p>
<p><img src="/images/LSTM/NH_SentenceTimeStep.png" alt=""></p>
<p>当翻译句子的时候，最后状态并不重要，但是如果当前句子只是段落的一个部分的话，它也许是重要的，因为它可能包含前面句子的信息。上面的初始状态是空白，但是当评估单个序列的时候，将初始状态作为变量训练是游泳的，最好的初始状态可能不是空白状态。</p>
<p>我们可以将每个单词甚至每个字符当成一个timestep。</p>
<p><img src="/images/LSTM/NH_WordTimeStep.png" alt=""></p>
<p>在第一个timestep后，状态包含了<code>the</code>的内部表示，第二个timestep，内部表示变成<code>the cat</code>，类似这样，网络的前三个步骤不产生任何输出，当接受到空白输入可以产生输出，因为它知道输入已经停止。当完成输出后，产生一个空白输出表示输出完成。</p>
<p>实际上，想深度LSTMs这样的RNN架构也无法很好的执行多任务，比如阅读和翻译。因此为了解决这个问题，可以将网络分成多个RNN，每个RNN专门用于一个任务。在上面的任务中，我们可以用英文（蓝色）的Encoder和一个用法文(红色)读取Decoder网络组合。</p>
<p><img src="/images/LSTM/NH_WordTimeStep_SeparateRNNs.png" alt=""></p>
<p>关于<a href="https://arxiv.org/pdf/1406.1078v3.pdf" target="_blank" rel="noopener">RNN  Encoder-Decoder model</a></p>
<p>虽然有两个独立的网络，但是它仍然符合RNN的定义：我们将循环函数定义成一个分裂函数，这个函数除了其他输入外，还需要一个输入来判断使用那个分裂函数。</p>
<p>timestep不一定基于内容，也可以基于实际的时间单位，比如时间步长为1秒，每秒强制读取5个字符。</p>
<p>我们也可以让RNN决定什么时候准备好进入下一个输入，甚至决定输入应该是什么。这就类似人类如何在一段较长的时间内专注于某些单词或短语来翻译它们。为此，我们能够使用RNN的输出动态的确定下一个输入。例如，RNN可能有这样的输出动作，比如再次读取最后一个输入，回溯5个timestep等等。基于注意力的翻译模型就是一个成功的例子：在每个timestep接受整个英语序列，并且由RNN Cell决定哪些部分和当前生成的法语单词相关性最高。</p>
<p>英译法的例子没有任何特别，无论我们选择什么样的人工任务，我们都可以选择不同的timestep来建立RNN 模型，甚至可以重构手写数字识别这样的事情，启动一次性函数（single timestep）是典型的方法。</p>
<h2 id="The-vanilla-RNN"><a href="#The-vanilla-RNN" class="headerlink" title="The vanilla RNN"></a>The vanilla RNN</h2><p>我们已经从大局上了解了RNN，现在让我看看那RNN Cell 的内部结构。最简单那的RNN Cell 是一个单层的神经网络，其输出即作为单元的当前的输出，也作为RNN当前的状态。</p>
<p><img src="/images/LSTM/NH_VanillaRNNcell.png" alt=""></p>
<p>注意，钱一个状态vector和当前的状态vector的大小是相同的。</p>
<p>下面vanilla RNN Cell的数学描述</p>
<script type="math/tex; mode=display">
s_t=\phi(Ws_{t-1}+Ux_t+b)</script><p>在这里：</p>
<ul>
<li>$\phi$是一个激活函数，例如 <code>Sigmod,tanh,ReLU</code></li>
<li>$s_t\in \mathbb{R}^n$是当前状态（和当前输出）</li>
<li>$s_{t-1}\in \mathbb{R}^n$是先前的状态</li>
<li>$x_t \in \mathbb{R}^m$是当前的输入</li>
<li>$W \in \mathbb{R}^{n \times n},U \in \mathbb{R}^{m \times n},b \in \mathbb{R}^n$是权重和偏差</li>
<li>$n,m$是状态和输入的大小</li>
</ul>
<p>这个基本的 RNN Cell是非常强大的，虽然没有满足singel cell内通用函数逼近的标准。但是，一系列组合的vanilla RNN是 Turing complete，因此能够实现任何算法。但是在实践中存在一个问题：用BP训练普通的RNN是非常困难的。原因是由于重复使用同一个非线性函数引起的信息变形、消失和爆炸的敏感性问题。</p>
<h2 id="Information-morphing-and-vanishing-and-exploding-sensitivity（信息变形、消息和爆炸敏感性）"><a href="#Information-morphing-and-vanishing-and-exploding-sensitivity（信息变形、消息和爆炸敏感性）" class="headerlink" title="Information morphing and vanishing and exploding sensitivity（信息变形、消息和爆炸敏感性）"></a>Information morphing and vanishing and exploding sensitivity（信息变形、消息和爆炸敏感性）</h2><p>与其描述大脑，不如将整个世界使用RNN建模：从每个时刻到下一个时刻，世界的状态被极其复杂的循环函数修改。</p>
<p>正如爱因斯坦的相对论可得过去的改变是新信息的引入。直接说，这种新信息的引入是循环函数（时间流动）的结果。因此我们可以认为信息本身是一种变化。它被循环函数影响，造成信息的消失、爆炸或者是波动。</p>
<ol>
<li><p>信息变形</p>
<p>如果信息不变化，当我们很难利用过去的信息。信息的最佳可用状态可能发生在过去的某个时刻。除了需要学习如何利用当前的信息，我们还需要从当前状态获取到最初的状态。如果这可能的话，这会导致学习困难或差的结果。</p>
<p>易得，信息变形发生在普通的RNN中。实际上，假设一个RNN Cell可以在没有外部输入的情况下完全保持先前的状态。$F(x)=\phi(Ws<em>{t-1}+b)$是一个关于$s</em>{t-1}$的恒等函数。但是这个恒等函数是线性的，$F(x)$是非线性的。所以存在矛盾。因此，RNN无法避免的从一个timestep到下一个timestep。对于普通的RNN，即使输出$s_t=x_t$这种任务也是不可能的。</p>
</li>
<li><p>梯度消失和梯度爆炸</p>
<p>当利用BP训练RNNs。BP是基于梯度的算法，如果梯度爆炸我们就无法训练模型，如果梯度消失，就无法学习长期的依赖，因此BP对最近的干扰非常敏感，以至于非常难训练。</p>
</li>
</ol>
<h2 id="消失敏感度的数学充分条件"><a href="#消失敏感度的数学充分条件" class="headerlink" title="消失敏感度的数学充分条件"></a>消失敏感度的数学充分条件</h2><p>这里将展示一个证明普通RNN梯度消息的充分条件的数学证明。</p>
<p>假设：$s_t$是时间$t$的状态向量，$\Delta v$是在时间$t$由状态变化向量$\Delta s_t$引起的向量$v$的变化。我们的目标是提供一个数学上的充分条件。使得当$k \to \infty $在时间 $t+k$  的状态变化导致在时间$t$的状态消失。也就是证明：</p>
<script type="math/tex; mode=display">
\lim_{k \to \infty} \frac{\Delta s_{t+k}}{\Delta s_t} = 0</script><p>首先，根据对普通RNN Cell的定义，我们有：</p>
<script type="math/tex; mode=display">
s_{t+1}=\phi(z_t)\quad where \quad z_t=Ws_t+Ux_{t+1}+b</script><p>使用多变量的中值定理，我们得到$\exists c \in [z_t, z_t+\Delta z_t]$</p>
<script type="math/tex; mode=display">
\begin{align}
\Delta S_{t+1} &  = [\phi'(c)]\Delta z_t\\ 
&= [\phi'(c)]\Delta(Ws_t)\\
&= [\phi'(c)]W\Delta s_t
\end{align}</script><p>$||A||$表示矩阵2范数，$|v|$表示Euclidean 向量范数。并定义：</p>
<script type="math/tex; mode=display">
\gamma = \sup_{c \in [z_t, z_t+\Delta z_t] } ||[\phi'(c)]||</script><p>注意，对于sigmod, $\gamma \le \frac{1}{4}$对于 tanh，$\gamma \le 1$。</p>
<p>考虑两边的向量番薯，我们可以得到，第一个不等式来源2范数（使用两次），第二个来源于上界的定义：</p>
<script type="math/tex; mode=display">
\begin{align}
|\Delta S_{t+1}| &= |[\phi'(c)]W\Delta s_t| \\
& \le [\phi'(c)]||W|||\Delta s_t| \\
& \le \gamma||W|||\Delta s_t| \\
& = ||\gamma W|||\Delta s_t|
\end{align}</script><p>将上面的等式在k个时间步长上展开，我们可以得到$|\Delta s_{t+k}| \le ||\gamma W||^k|\Delta s_t|$，因此：</p>
<script type="math/tex; mode=display">
\frac{|\Delta s_{t+k}|}{|\Delta s_t|} \le ||\gamma W||^k</script><p>所以，如果$||\gamma W||^k \lt 1$。我们可以得到$\frac{|\Delta s_{t+k}|}{|\Delta s_t|}$随时间指数衰减的充分条件。</p>
<p>因为对于logistic sigmod 和 tanh分别有界于 $\frac{1}{4}$和$1$，这说明，当$||W||$小于4或1是梯度消失的充分条件。</p>
<p>最直接的教训，如果我们权重初始化$W$太小的话，RNN则可能由于消失的梯度导致无法学习。</p>
<h2 id="避免梯度消失的最小权重初始化"><a href="#避免梯度消失的最小权重初始化" class="headerlink" title="避免梯度消失的最小权重初始化"></a>避免梯度消失的最小权重初始化</h2><p>找到一个合适的权重初始化对于避免梯度消失是非常由于那个的。扩展上面的分析，找到$W$的初始化使得我们经可能相等，从而得到一个好的结果。</p>
<p>首先，假设$\phi = \tanh \; and \; \gamma = 1$ ，也可以假设$\phi = \sigma \; and \; \gamma = \frac{1}{4}$ 得到一个不同的结果。</p>
<p>我们的目标是找到$W$的初始化，其中：</p>
<ol>
<li>$||\gamma W|| = 1$</li>
<li>我们尽可能接近上面的等式。</li>
</ol>
<p>从点1开始，因为我们将$\gamma = 1$，我得到$||W||=1$。从点2开始，我们应该尝试将$W$的<a href="[https://baike.baidu.com/item/%E5%A5%87%E5%BC%82%E5%80%BC](https://baike.baidu.com/item/奇异值">奇异值</a>)设置为1,而不仅仅是最大值，如果$W$的奇异值等于1,因为着$W$的每列范数都等于1，这意味这对于$j$列我们有：</p>
<script type="math/tex; mode=display">
\sum_iw^2_{ij}=1</script><p>$j$列有$n$个条目，我们从相同的随机分布中选择每个条目，所以我们能找到一个随机权重$w$的分布：</p>
<script type="math/tex; mode=display">
n\mathbb{E}(w^2) = 1</script><p>现在假设我们想在区间$[-R,R]$内均匀的初始化$w$，所以$w$的均值为0。所以，根据定义，$\mathbb{E}(w^2)$是它的方差$\mathbb{V}(w)$。在区间$[a,b]$内的均匀分布的方差是$\frac{(b-a)^2}{12}$。所以我们得到$\mathbb{V}(w)=\frac{R^2}{3}$。将这个带入到我们的方程中得到：</p>
<script type="math/tex; mode=display">
n\frac{R^2}{3}=1</script><p>所以：</p>
<script type="math/tex; mode=display">
R=\frac{\sqrt 3}{\sqrt n}</script><p>这表明我们使用区间为$[- \frac{\sqrt 3}{\sqrt n},\frac{\sqrt 3}{\sqrt n}]$的均匀分布来初始化权重，</p>
<h2 id="处理梯度消失和爆炸"><a href="#处理梯度消失和爆炸" class="headerlink" title="处理梯度消失和爆炸"></a>处理梯度消失和爆炸</h2><p>如果梯度爆炸，BP将变得无效，因为我们在前面的层得到NaN值。一个简单的解决方案是修剪梯度到最大值。这样在实践中可以预防 NaN 值，从而能够继续训练。</p>
<p>梯度消失和普通RNN会出现的情况，从上面看，好的初始权重是很重要的，但这只会影响训练的开始，那训练的中间部分呢。Pascanu等人（2013）提出了一个方法——引入正则化项(regularization term)。</p>
<h2 id="LSTM背后的直觉"><a href="#LSTM背后的直觉" class="headerlink" title="LSTM背后的直觉"></a>LSTM背后的直觉</h2><p>信息被RNN Cell变形导致原始信息的丢失，可能对最终信息产生各种各样的影响，甚至导致完全不同的结果。</p>
<p>如何保证信息的完整性，这是LSTMs的基本原则：为了确保真实时间的信息完整性，我们会将它记录下来。书写是对当前状态的增加：它是一种创造和破坏的行为，当你记录下它，主题本身不会变形，并且反向传递的误差梯度是恒定的。</p>
<p>避免信息变形：对LSTM状态的改变通过不明确的加减法显式的写入，便于在没有外界的干预下，状态的每个元素保持稳定。</p>
<p>LSTM的原则是写下来。实际上，这意味着任何状态改变都是增量，因此：</p>
<script type="math/tex; mode=display">
s_{t+1} = s_t+\Delta s_{t+1}</script><p>LSTM的基本挑战：无法控制和无法协调的写入会导致混乱和溢出，并且很难恢复。</p>
<h2 id="选择性的控制和协调写入"><a href="#选择性的控制和协调写入" class="headerlink" title="选择性的控制和协调写入"></a>选择性的控制和协调写入</h2><p>LSTM的基本挑战和保持状态的关键是：写入什么，读取什么，忘记什么（干扰信息）</p>
<p>选择性的形式：有选择的写、有选择的读、有选择的忘记</p>
<p>在上面的基础上，增加两个步骤，得到LSTM：</p>
<ul>
<li>确定一种选择机制</li>
<li>将碎片粘和起来</li>
</ul>
<h2 id="门选择机制"><a href="#门选择机制" class="headerlink" title="门选择机制"></a>门选择机制</h2><p>利用状态大小的读、写和忘记向量来做这些决定，这些决定置于0-1之间，指定每个状态元素读、写和忘记的百分比。虽然读、写和忘记看作二元决定更加自然，但是我们需要一个可微函数来实现我们的决定，logisic sigmod是一个自然而然的选择，它是可微的，并产生0-1之间的连续值。</p>
<p>我们读、写和忘记向量称为”门”，我们可以用简单的函数来计算它们，就像我们对RNN所做的一样：single NN。我们在时间 time step t事的三个门表示为$i_t$ 输入门（写）；$o_t$ 输出门（读）$f_t$遗忘门（记忆）。</p>
<p>可以发现这里有两个相矛盾的地方：</p>
<ul>
<li>有点像先有鸡还是先有蛋，通常建议先读后写——在写入状态前，读取先前的状态，这样即使开始是空白状态，我们也可以从中读取，输入门和输出门表明了相反的时间关系。</li>
<li>遗忘门是用来遗忘的，实际上有着记忆门的作用，如1表示记住一切，而不是遗忘一切。</li>
</ul>
<p>下面是这些门的数学定义：（注意它们的相似之处）</p>
<script type="math/tex; mode=display">
\begin{align}
& i_t = \sigma(W_is_{t-1}+U_ix_t+b_i) \\
& o_t = \sigma(W_os_{t-1}+U_ox_t+b_o) \\
& f_t = \sigma(W_fs_{t-1}+U_fx_t+b_f) 
\end{align}</script><p>当然也可以使用更加复杂的函数。</p>
<h2 id="将门组合在得到LSTM原型"><a href="#将门组合在得到LSTM原型" class="headerlink" title="将门组合在得到LSTM原型"></a>将门组合在得到LSTM原型</h2><p>如果没有输入门，是用输出门应该先读取先前的状态，以产生下一次写的状态。输出门自然在输入门之前。</p>
<p>LSTM的基本原则是：我们的写入应该增加到之前的状态。因此，我们应该计算$\Delta s_t$，而不是$s_t$。因此候选写入的可能是$\Delta s_t$。把它记作$\bar{s}_t$。</p>
<p>我们采用和在普通RNN上计算状态的一样的方式计算$\bar{s}<em>t$。首先通过输出门乘先前的状态$o_t \odot s</em>{t-1}$。</p>
<script type="math/tex; mode=display">
\bar{s}_t = \phi(W(o_t \odot s_{t-1})+ Ux_t+b)</script><p>注意$\odot$表示逐元素相乘，$o_t$是我们的输出门。</p>
<p>$\bar{s}_t$只是一个候选写作，因为我们使用的是选择行写入和输入门。因此我们使用$\bar{s}_t$和输入门$i_t$逐元素相乘，来获得我们真正的写入。$i_t \odot \bar{s}_t$</p>
<p>最后一部是将这个增加到我们之前的状态上，但是我们需要有一个遗忘机制。因此，在增加任何到我们之前的状态之前，我们通过遗忘门进行逐乘操作。最后的LSTM原型的公式为：</p>
<script type="math/tex; mode=display">
s_t = f_t \odot s_{t-1}+i_t\odot \bar{s}_t</script><p>我们将所有的公式整合起来，就可以得到LSTM Cell的全部信息。</p>
<h2 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h2><script type="math/tex; mode=display">
\begin{align}
& i_t = \sigma(W_is_{t-1}+U_ix_t+b_i) \\
& o_t = \sigma(W_os_{t-1}+U_ox_t+b_o) \\
& f_t = \sigma(W_fs_{t-1}+U_fx_t+b_f) \\

\\
& \bar{s}_t = \phi(W(o_t \odot s_{t-1})+Ux_t+b) \\
& s_t = f_t \odot s_{t-1}+i_t \odot \bar{s}_t
\end{align}</script><p>下面是图示的样子：</p>
<p><img src="/images/LSTM/NH_PrototypeLSTMCell.png" alt=""></p>
<p>理论上，这个原型可以工作，但是在实践中。采取的选择措施无法克服LSTM的基本问题：选择性遗忘和选择性写入在开始训练时的不协调，可能导致状态的迅速变大和混乱。由于状态可能是无界的，门和候选写入经常会变得饱和。</p>
<h2 id="三种模型：归一化模型、GRU、伪LSTM"><a href="#三种模型：归一化模型、GRU、伪LSTM" class="headerlink" title="三种模型：归一化模型、GRU、伪LSTM"></a>三种模型：归一化模型、GRU、伪LSTM</h2><p>由于上面的LSTM原型采取的选择性措施不够强大，无法克服LSTM的基本问题。</p>
<h3 id="归一化原型：规范化的软界限"><a href="#归一化原型：规范化的软界限" class="headerlink" title="归一化原型：规范化的软界限"></a>归一化原型：规范化的软界限</h3><p>我们可以通过状态归一化来增加一个软约束。初步测试中一个有用的方法是将$s_t$除以$\sqrt{Var(s_t)+1}$。这里增加1来防止初始的零状态。我们也可以在除以方差之前减去平均状态。但在初步测试中似乎没有帮助。然后，我们也考虑为表达性增加规模和移位因素，即层标准化。但该模型冒险进入了层标准化LSTM的范围。</p>
<h3 id="GRU-通过写-遗忘耦合或覆盖的硬约束"><a href="#GRU-通过写-遗忘耦合或覆盖的硬约束" class="headerlink" title="GRU:通过写-遗忘耦合或覆盖的硬约束"></a>GRU:通过写-遗忘耦合或覆盖的硬约束</h3><p>与其进行选择性的写入和遗忘，不如放弃一些表达性，将我们的遗忘门设置为1减去输入门来进行选择性的重写。</p>
<script type="math/tex; mode=display">
s_t=(1-i_t)\odot s_{t-1}+i_t\odot \bar{s}_t</script><p>它将$s<em>t$变成了$s</em>{t-1}$和$\bar{s}<em>t$的加权平均数。当$s</em>{t-1}$和$\bar{s}_t$被约束，那它也是被约束的。如果我们使用$\phi= \tanh$（它的输出被限制在$(-1,1)$）。</p>
<p>这就是<code>GRU(gated recurrent unit)</code>。为了符合GRU中的术语，我们将覆盖门成为更新门，并记作$z_t$。虽然叫做更新门，它的操作是通过指出之前状态我们不想更新的百分比来不更新。因此，更新门和原型LSTM中的遗忘门$f_t$是一样的，并且输入门通过$1-z_t$计算得到。</p>
<script type="math/tex; mode=display">
\begin{align}
& r_t = \sigma(W_rs_{t-1}+U_rx_t+b_r)\\
& z_t = \sigma(W_zs_{t-1}+U_zx_t+b_z)\\
\\
& \bar{s}_t = \phi(W(r_t \odot s_{t-1})+Ux_t+b)\\
& s_t = z_t \odot s_{t-1}+(1-z_t) \odot \bar{s}_t

\end{align}</script><p><img src="/images/LSTM/NH_GRUCell.png" alt=""></p>
<h3 id="伪-LSTM-基于非线性压缩的硬约束"><a href="#伪-LSTM-基于非线性压缩的硬约束" class="headerlink" title="伪 LSTM: 基于非线性压缩的硬约束"></a>伪 LSTM: 基于非线性压缩的硬约束</h3><script type="math/tex; mode=display">
\begin{align}
& i_t = \sigma(W_i(\phi(s_{t-1}))+U_ix_t+b_i)\\
& o_t = \sigma(W_o(\phi(s_{t-1}))+U_ox_t+b_o)\\
& f_t = \sigma(W_f(\phi(s_{t-1}))+U_fx_t+b_f)\\
\\
& \bar{s}_t = \phi(W(o_t \odot \phi(s_{t-1}))+Ux_t+b)\\
& s_t = f_t \odot s_{t-1}+ i_t \odot \bar{s}_t\\
\\
& rnn_{out}=\phi(s_t)
\end{align}</script><p><img src="/images/LSTM/NH_PseudoLSTMCell.png" alt=""></p>
<h2 id="推导LSTM"><a href="#推导LSTM" class="headerlink" title="推导LSTM"></a>推导LSTM</h2><p>上面有许多LSTM变体，真正的LSTM将读操作放在写操作之后。</p>
<p>写入操作放在RNN单元读取操作之前，我们需要在正常状态下从一个time step 到下一个 time step传递一个预先门的“阴影状态”。</p>
<p>为了符合描述LSTM常用的字母，我们需要将主状态$s<em>t$变成$c_t$（c表示cell）。我们对候选写入作一个相应的变动$\bar{c}_t$。我们还需要一个单独的隐藏状态$h_t$(h是隐藏状态)。他的状态和我们的常规状态相同，$h</em>{t-1}$类似我们原型LSTM中的门控先验状态$o<em>t \odot s</em>{t-1}$。，除此它还被一个非线性函数压缩。因此，我们的LSTM在 $t$得到是一组紧密相关的向量：$(c<em>{t-1}, h</em>{t-1}) \quad where \quad h<em>{t-1}=o</em>{t-1} \odot \phi(c_{t-1})$</p>
<p>$h_{t-1}$的产生导致了和我们的伪LSTM两个不同</p>
<ul>
<li>标准的LSTM使用$h<em>{t-1}=o</em>{t-1} \odot \phi(c<em>{t-1})$来计算门，而不是使用$\phi(c</em>{t-1})$来计算门。</li>
<li>标准的LSTM使用$h_t=o_t \odot \phi (c_t)$作为代替$\phi(c_t)$作为外部输出，它受到输出门的控制</li>
</ul>
<p>基本的LSTM</p>
<script type="math/tex; mode=display">
\begin{align}
& i_t = \sigma(W_ih_{t-1}+U_ix_t+b_i)\\
& o_t = \sigma(W_oh_{t-1}+U_ox_t+b_o)\\
& f_t = \sigma(W_fh_{t-1}+U_fx_t+b_f)\\
\\
& \bar{c}_t = \phi(Wh_{t-1}+Ux_t+b)\\
& s_t = f_t \odot c_{t-1}+ i_t \odot \bar{c}_t\\
\\
& h_t = o_t \odot \phi(c_t)\\
\\
& rnn_{out}=h_t
\end{align}</script><p><img src="/images/LSTM/NH_BasicLSTMCell.png" alt=""></p>
<h2 id="The-LSTM-with-peepholes"><a href="#The-LSTM-with-peepholes" class="headerlink" title="The LSTM with peepholes"></a>The LSTM with peepholes</h2><script type="math/tex; mode=display">
\begin{equation}
\begin{split}
i_t &= \sigma(W_ih_{t-1} + U_ix_t + P_ic_{t-1} + b_i) \\
f_t &= \sigma(W_fh_{t-1} + U_fx_t + P_fc_{t-1} + b_f) \\
\\
\tilde{c_t}& = \phi(Wh_{t-1} + Ux_t + b)\\
c_t &= f_t \odot c_{t-1} + i_t \odot \tilde{c}_t\\
\\
o_t &= \sigma(W_oh_{t-1} + U_ox_t + P_oc_{t} + b_o) \\
\\
h_t &= o_t \odot \phi(c_t)\\
\\
\text{rnn}_{out} & = h_t
\end{split}
\end{equation}</script>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>找两个和为目标值且不重叠的子数组</title>
    <url>/2020/06/14/LeetCode5423/</url>
    <content><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个整数数组 <code>arr</code> 和一个整数值 <code>target</code> 。</p>
<p>请你在 arr 中找 两个互不重叠的子数组 且它们的和都等于 target 。可能会有多种方案，请你返回满足要求的两个子数组长度和的 最小值 。</p>
<p>请返回满足要求的最小长度和，如果无法找到这样的两个子数组，请返回 -1 。</p>
<a id="more"></a>
<ul>
<li><p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [3,2,2,4,3], target &#x3D; 3</span><br><span class="line">输出：2</span><br><span class="line">解释：只有两个子数组和为 3 （[3] 和 [3]）。它们的长度和为 2 。</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例 2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [7,3,4,7], target &#x3D; 7</span><br><span class="line">输出：2</span><br><span class="line">解释：尽管我们有 3 个互不重叠的子数组和为 7 （[7], [3,4] 和 [7]），但我们会选择第一个和第三个子数组，因为它们的长度和 2 是最小值。</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例 3：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [4,3,2,6,2,3,4], target &#x3D; 6</span><br><span class="line">输出：-1</span><br><span class="line">解释：我们只有一个和为 6 的子数组。</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例 4：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [5,5,4,4,5], target &#x3D; 3</span><br><span class="line">输出：-1</span><br><span class="line">解释：我们无法找到和为 3 的子数组。</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例 5：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：arr &#x3D; [3,1,1,1,5,1,2,1], target &#x3D; 3</span><br><span class="line">输出：3</span><br><span class="line">解释：注意子数组 [1,2] 和 [2,1] 不能成为一个方案因为它们重叠了。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &lt;&#x3D; arr.length &lt;&#x3D; 10^5</span><br><span class="line">1 &lt;&#x3D; arr[i] &lt;&#x3D; 1000</span><br><span class="line">1 &lt;&#x3D; target &lt;&#x3D; 10^8</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>哈希表 + 前缀和 + 动态规划</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minSumOfLengths</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       Map&lt;Integer, Integer&gt; fuck = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 保存前缀和 &lt;和，下标&gt;</span></span><br><span class="line">       fuck.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> curPreSum = <span class="number">0</span>; <span class="comment">// 保存当前位置前缀和 </span></span><br><span class="line">       <span class="keyword">int</span> mi = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> ans = <span class="number">0x7fffffff</span>;</span><br><span class="line">       List&lt;Integer&gt; m_f = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 长度为arr.length ,当前位置前面满足target的子数组长度</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           curPreSum += arr[i]; <span class="comment">// 计算当前前缀和，并保存</span></span><br><span class="line">           fuck.put(curPreSum, i);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (fuck.containsKey(curPreSum - target)) &#123;</span><br><span class="line">               <span class="comment">// 计算是否存在前缀和等于 curPreSum - target，存在这存在位置到当前位置和为target</span></span><br><span class="line">               <span class="keyword">int</span> l_i = fuck.get(curPreSum - target); <span class="comment">// 起点位置</span></span><br><span class="line">               <span class="keyword">int</span> ttt = i - l_i; <span class="comment">// 子数组长度</span></span><br><span class="line">               <span class="keyword">if</span> (mi == <span class="number">0</span>)</span><br><span class="line">                   <span class="comment">// 表示前面还没有满足条件子数组</span></span><br><span class="line">                   mi = ttt;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="comment">// 判断当前子数组长度和前面子数组长度那个更短</span></span><br><span class="line">                   mi = Math.min(mi, ttt);</span><br><span class="line">               m_f.add(mi);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (l_i != -<span class="number">1</span> &amp;&amp; m_f.get(l_i) != <span class="number">0</span>)</span><br><span class="line">                   <span class="comment">// 当找到的l_i之前存在哦子数组，和当前的子数组，求和</span></span><br><span class="line">                   ans = Math.min(ans, m_f.get(l_i) + ttt);</span><br><span class="line"></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               m_f.add(mi);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (ans == <span class="number">0x7fffffff</span>)</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch</title>
    <url>/2020/04/16/ElasticSearch/</url>
    <content><![CDATA[<h1 id="ElasticSearch-基础实践-Quick-Start"><a href="#ElasticSearch-基础实践-Quick-Start" class="headerlink" title="ElasticSearch 基础实践 Quick Start"></a>ElasticSearch 基础实践 Quick Start</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li>Neal Realtime(NRT)：接近实时的</li>
<li>Cluster：集群是一个或多个节点（服务器）的集合，它们一起保存数据，并且提供跨节点的联合索引和搜索功能。一个集群的名字需要唯一标识。</li>
<li>Node：节点是一个服务器，是集群的一部分，存储数据，参与集群的索引和搜索。同样需要唯一名称标识。通常是启动时候随机的UUID。</li>
<li>Index：索引是具有某些相似特征文档的集合。比如客户数据的索引，产品目录的索引。索引由一个名称标识，该名称用于在对其中的文档执行索引、搜索、更新和删除操作时引用索引。</li>
<li>Type (Deprecated)</li>
<li>Document：文档是可以被索引的基本单位。在一个索引 / 类型中，您可以存储任意多的文档。</li>
<li>Shards &amp; Replicas：索引可能存储大量数据，这些数据可能超过节点的硬件限制。为了解决这个问题，提供了将索引细分为多个部分的功能 Shards碎片。创建索引的时候，可以定义所需碎片数目。</li>
</ol>
<a id="more"></a>
<h2 id="搜索你的集群"><a href="#搜索你的集群" class="headerlink" title="搜索你的集群"></a>搜索你的集群</h2><h3 id="The-REST-API"><a href="#The-REST-API" class="headerlink" title="The REST API"></a>The REST API</h3><p>假设现在一起启动并运行了节点和集群。ES提供了强大的REST API。</p>
<ul>
<li>检查cluster、node、index的状态和统计信息</li>
<li>管理cluster、node、index data和metadata</li>
<li>对索引执行CRUD和搜索操作</li>
<li>执行高级搜索操作，比如分页，排序，过滤，聚合等等。</li>
</ul>
<h3 id="Cluster-Health"><a href="#Cluster-Health" class="headerlink" title="Cluster Health"></a>Cluster Health</h3><p>检查cluster的health</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">curl -X GET <span class="string">"localhost:9200/_cat/health?v&amp;pretty"</span></span></span><br><span class="line">epoch      timestamp cluster       status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent</span><br><span class="line">1587010145 04:09:05  elasticsearch green           1         1      0   0    0    0        0             0                  -                100.0%</span><br></pre></td></tr></table></figure>
<p>可以看到名为elasticsearch的集群的状态是green</p>
<ul>
<li>Green 一切都好</li>
<li>Yellow 所有的数据是可获得的，但是一些分片还没分配</li>
<li>Read 因为某些原因，无法获得数据。</li>
</ul>
<p>查看集群中的节点列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">curl -X GET <span class="string">"localhost:9200/_cat/nodes?v&amp;pretty"</span></span></span><br><span class="line">ip        heap.percent ram.percent cpu load_1m load_5m load_15m node.role master name</span><br><span class="line">127.0.0.1           11          96  14    0.87    0.88     0.97 dilm      *      dongxian-manjaro</span><br></pre></td></tr></table></figure>
<h3 id="列出所有索引"><a href="#列出所有索引" class="headerlink" title="列出所有索引"></a>列出所有索引</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">curl -X GET <span class="string">"localhost:9200/_cat/indices?v&amp;pretty"</span></span></span><br><span class="line">health status index uuid pri rep docs.count docs.deleted store.size pri.store.size</span><br></pre></td></tr></table></figure>
<h3 id="创建一个索引"><a href="#创建一个索引" class="headerlink" title="创建一个索引"></a>创建一个索引</h3><p>现在创建一个名为customer的索引，然后列出来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">curl -X PUT <span class="string">"localhost:9200/customer?pretty&amp;pretty"</span></span></span><br><span class="line">&#123;</span><br><span class="line">  "acknowledged" : true,</span><br><span class="line">  "shards_acknowledged" : true,</span><br><span class="line">  "index" : "customer"</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">$</span><span class="bash">curl -X GET <span class="string">"localhost:9200/_cat/indices?v&amp;pretty"</span></span></span><br><span class="line">health status index    uuid                   pri rep docs.count docs.deleted store.size pri.store.size</span><br><span class="line">yellow open   customer WYuBXNDZSxWkNfDZ4ArKLA   1   1          0            0       230b           230b</span><br></pre></td></tr></table></figure>
<p>第二个命令的结果告诉我们，现在有一个名为customer的索引，有1个主碎片和1个副本，其中包含0个文档。</p>
<p>由于当前只有一个节点在运行，状态为Yellow，因为没有办法分配副本。</p>
<h3 id="索引和查询文档"><a href="#索引和查询文档" class="headerlink" title="索引和查询文档"></a>索引和查询文档</h3><p>让我们输入一些东西到customer index中，我们使用ID 1来标识文档</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -X PUT <span class="string">"localhost:9200/customer/doc/1?pretty&amp;pretty"</span> -H <span class="string">'Content-Type: application/json'</span> -d<span class="string">'</span></span></span><br><span class="line">&#123;</span><br><span class="line">  "name": "John Doe"</span><br><span class="line">&#125;</span><br><span class="line">'</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "_index" : "customer",</span><br><span class="line">  "_type" : "doc",</span><br><span class="line">  "_id" : "1",</span><br><span class="line">  "_version" : 1,</span><br><span class="line">  "result" : "created",</span><br><span class="line">  "_shards" : &#123;</span><br><span class="line">    "total" : 2,</span><br><span class="line">    "successful" : 1,</span><br><span class="line">    "failed" : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  "_seq_no" : 0,</span><br><span class="line">  "_primary_term" : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取我们刚刚增加到索引的文档</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -X GET <span class="string">"localhost:9200/customer/doc/1?pretty&amp;pretty"</span></span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "_index" : "customer",</span><br><span class="line">  "_type" : "doc",</span><br><span class="line">  "_id" : "1",</span><br><span class="line">  "_version" : 1,</span><br><span class="line">  "_seq_no" : 0,</span><br><span class="line">  "_primary_term" : 1,</span><br><span class="line">  "found" : true,</span><br><span class="line">  "_source" : &#123;</span><br><span class="line">    "name" : "John Doe"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回的的信息中</p>
<ul>
<li>fount：表示我们找到一个ID 为 1的文档</li>
<li>_source：返回我们先前插入的整个JSON文档</li>
</ul>
<h3 id="删除一个索引"><a href="#删除一个索引" class="headerlink" title="删除一个索引"></a>删除一个索引</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">curl -X DELETE <span class="string">"localhost:9200/customer?pretty&amp;pretty"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">curl -X GET <span class="string">"localhost:9200/_cat/indices?v&amp;pretty"</span></span></span><br><span class="line">health status index uuid pri rep docs.count docs.deleted store.size pri.store.size</span><br></pre></td></tr></table></figure>
<p>通过上面我们可以发现，REST access pattern</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;REST Verb&gt; &#x2F;&lt;Index&gt;&#x2F;&lt;Type&gt;&#x2F;&lt;ID&gt;</span><br></pre></td></tr></table></figure>
<h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p>插入和替换文档</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">curl -X PUT <span class="string">"localhost:9200/customer/doc/1?pretty&amp;pretty"</span> -H <span class="string">'Content-Type: application/json'</span> -d<span class="string">'</span></span></span><br><span class="line">&#123;</span><br><span class="line">  "name": "John Doe"</span><br><span class="line">&#125;</span><br><span class="line">'</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "_index" : "customer",</span><br><span class="line">  "_type" : "doc",</span><br><span class="line">  "_id" : "1",</span><br><span class="line">  "_version" : 1,</span><br><span class="line">  "result" : "created",</span><br><span class="line">  "_shards" : &#123;</span><br><span class="line">    "total" : 2,</span><br><span class="line">    "successful" : 1,</span><br><span class="line">    "failed" : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  "_seq_no" : 0,</span><br><span class="line">  "_primary_term" : 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -X PUT <span class="string">"localhost:9200/customer/doc/1?pretty&amp;pretty"</span> -H <span class="string">'Content-Type: application/json'</span> -d<span class="string">'</span></span></span><br><span class="line">&#123;</span><br><span class="line">  "name": "Jane Doe"</span><br><span class="line">&#125;</span><br><span class="line">'</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "_index" : "customer",</span><br><span class="line">  "_type" : "doc",</span><br><span class="line">  "_id" : "1",</span><br><span class="line">  "_version" : 2,</span><br><span class="line">  "result" : "updated",</span><br><span class="line">  "_shards" : &#123;</span><br><span class="line">    "total" : 2,</span><br><span class="line">    "successful" : 1,</span><br><span class="line">    "failed" : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  "_seq_no" : 1,</span><br><span class="line">  "_primary_term" : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的操作，修改ID 为1的文档的name。如果我们使用不同的ID，将会产生新的文档，现有的文档不会变换。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -X PUT <span class="string">"localhost:9200/customer/doc/2?pretty&amp;pretty"</span> -H <span class="string">'Content-Type: application/json'</span> -d<span class="string">'</span></span></span><br><span class="line">&#123;</span><br><span class="line">  "name": "Jane Doe"</span><br><span class="line">&#125;</span><br><span class="line">'</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "_index" : "customer",</span><br><span class="line">  "_type" : "doc",</span><br><span class="line">  "_id" : "2",</span><br><span class="line">  "_version" : 1,</span><br><span class="line">  "result" : "created",</span><br><span class="line">  "_shards" : &#123;</span><br><span class="line">    "total" : 2,</span><br><span class="line">    "successful" : 1,</span><br><span class="line">    "failed" : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  "_seq_no" : 2,</span><br><span class="line">  "_primary_term" : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当indexing的时候，ID是可选的，如果显式知名，ES会自动生成一个随机ID。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -X POST <span class="string">"localhost:9200/customer/doc?pretty&amp;pretty"</span> -H <span class="string">'Content-Type: application/json'</span> -d<span class="string">'</span></span></span><br><span class="line">&#123;</span><br><span class="line">  "name": "Jane Doe"</span><br><span class="line">&#125;</span><br><span class="line">'</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "_index" : "customer",</span><br><span class="line">  "_type" : "doc",</span><br><span class="line">  "_id" : "MhxFgXEBHBe5IUAf-8U3",</span><br><span class="line">  "_version" : 1,</span><br><span class="line">  "result" : "created",</span><br><span class="line">  "_shards" : &#123;</span><br><span class="line">    "total" : 2,</span><br><span class="line">    "successful" : 1,</span><br><span class="line">    "failed" : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  "_seq_no" : 3,</span><br><span class="line">  "_primary_term" : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这边使用的POST替换PUT，因为没有指明ID。</p>
<h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><p>除了索引和替换文档，我们还可以更新文档。每当我们做一个更新，ES删除旧的文档，然后索引一个新的文档。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -X POST <span class="string">"localhost:9200/customer/doc/1/_update?pretty&amp;pretty"</span> -H <span class="string">'Content-Type: application/json'</span> -d<span class="string">'</span></span></span><br><span class="line">&#123;</span><br><span class="line">  "doc": &#123; "name": "Jane Doe" &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "_index" : "customer",</span><br><span class="line">  "_type" : "doc",</span><br><span class="line">  "_id" : "1",</span><br><span class="line">  "_version" : 2,</span><br><span class="line">  "result" : "noop",</span><br><span class="line">  "_shards" : &#123;</span><br><span class="line">    "total" : 0,</span><br><span class="line">    "successful" : 0,</span><br><span class="line">    "failed" : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  "_seq_no" : 1,</span><br><span class="line">  "_primary_term" : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新文档，并且增加字段</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -X POST <span class="string">"localhost:9200/customer/doc/1/_update?pretty&amp;pretty"</span> -H <span class="string">'Content-Type: application/json'</span> -d<span class="string">'</span></span></span><br><span class="line">&#123;</span><br><span class="line">  "doc": &#123; "name": "Jane Doe", "age": 20 &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "_index" : "customer",</span><br><span class="line">  "_type" : "doc",</span><br><span class="line">  "_id" : "1",</span><br><span class="line">  "_version" : 3,</span><br><span class="line">  "result" : "updated",</span><br><span class="line">  "_shards" : &#123;</span><br><span class="line">    "total" : 2,</span><br><span class="line">    "successful" : 1,</span><br><span class="line">    "failed" : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  "_seq_no" : 4,</span><br><span class="line">  "_primary_term" : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用脚本更新文档，使用脚本将age增加5：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -X POST <span class="string">"localhost:9200/customer/doc/1/_update?pretty&amp;pretty"</span> -H <span class="string">'Content-Type: application/json'</span> -d<span class="string">'</span></span></span><br><span class="line">&#123;</span><br><span class="line">  "script" : "ctx._source.age += 5"</span><br><span class="line">&#125;</span><br><span class="line">'</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "_index" : "customer",</span><br><span class="line">  "_type" : "doc",</span><br><span class="line">  "_id" : "1",</span><br><span class="line">  "_version" : 4,</span><br><span class="line">  "result" : "updated",</span><br><span class="line">  "_shards" : &#123;</span><br><span class="line">    "total" : 2,</span><br><span class="line">    "successful" : 1,</span><br><span class="line">    "failed" : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  "_seq_no" : 5,</span><br><span class="line">  "_primary_term" : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES提供了在查询条件下更新多个文档的能力</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/docs-update-by-query.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/6.0/docs-update-by-query.html</a></p>
<h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -X DELETE <span class="string">"localhost:9200/customer/doc/2?pretty&amp;pretty"</span></span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "_index" : "customer",</span><br><span class="line">  "_type" : "doc",</span><br><span class="line">  "_id" : "2",</span><br><span class="line">  "_version" : 2,</span><br><span class="line">  "result" : "deleted",</span><br><span class="line">  "_shards" : &#123;</span><br><span class="line">    "total" : 2,</span><br><span class="line">    "successful" : 1,</span><br><span class="line">    "failed" : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  "_seq_no" : 6,</span><br><span class="line">  "_primary_term" : 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/docs-delete-by-query.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/6.0/docs-delete-by-query.html</a></p>
<h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>除了索引、更新、删除单个文档外，ES提供了使用批处理上面的能力。</p>
<p>下面在批量操作中索引两个文档：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">curl -X POST <span class="string">"localhost:9200/customer/doc/_bulk?pretty&amp;pretty"</span> -H <span class="string">'Content-Type: application/json'</span> -d<span class="string">'</span></span></span><br><span class="line">&#123;"index":&#123;"_id":"1"&#125;&#125;</span><br><span class="line">&#123;"name": "John Doe" &#125;</span><br><span class="line">&#123;"index":&#123;"_id":"2"&#125;&#125;</span><br><span class="line">&#123;"name": "Jane Doe" &#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure>
<p>更新第一个文档，删除第二个文档：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X POST "localhost:9200/customer/doc/_bulk?pretty&amp;pretty" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;"update":&#123;"_id":"1"&#125;&#125;</span><br><span class="line">&#123;"doc": &#123; "name": "John Doe becomes Jane Doe" &#125; &#125;</span><br><span class="line">&#123;"delete":&#123;"_id":"2"&#125;&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure>
<p>批处理API不会因为单个操作失败而失败，如果单个操作因为某种原因失败，它将会继续后面的其他操作。返回时，为每一个操作提供一个状态，表示是否操作失败。</p>
<h2 id="探索数据"><a href="#探索数据" class="headerlink" title="探索数据"></a>探索数据</h2><p>样本数据集：</p>
<p>现在我们已经了解了一些基本知识，接下来让我们尝试使用一个更加真实的数据集。 我准备了一个虚构的客户银行账户信息 JSON 文档样本。 每个文档都有以下模式:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"account_number"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"balance"</span>: <span class="number">16623</span>,</span><br><span class="line">    <span class="attr">"firstname"</span>: <span class="string">"Bradshaw"</span>,</span><br><span class="line">    <span class="attr">"lastname"</span>: <span class="string">"Mckenzie"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">29</span>,</span><br><span class="line">    <span class="attr">"gender"</span>: <span class="string">"F"</span>,</span><br><span class="line">    <span class="attr">"address"</span>: <span class="string">"244 Columbus Place"</span>,</span><br><span class="line">    <span class="attr">"employer"</span>: <span class="string">"Euron"</span>,</span><br><span class="line">    <span class="attr">"email"</span>: <span class="string">"bradshawmckenzie@euron.com"</span>,</span><br><span class="line">    <span class="attr">"city"</span>: <span class="string">"Hobucken"</span>,</span><br><span class="line">    <span class="attr">"state"</span>: <span class="string">"CO"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些数据都是使用  <a href="http://www.json-generator.com/" target="_blank" rel="noopener">http://www.json-generator.com/</a>   生成的，因为是随机生成的，所以忽略数据的实际值和含义。</p>
<p>加载样本数据集</p>
<p><a href="https://github.com/elastic/elasticsearch/blob/master/docs/src/test/resources/accounts.json?raw=true" target="_blank" rel="noopener">https://github.com/elastic/elasticsearch/blob/master/docs/src/test/resources/accounts.json?raw=true</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">curl -H <span class="string">"Content-Type: application/json"</span> -XPOST <span class="string">'localhost:9200/bank/account/_bulk?pretty&amp;refresh'</span> --data-binary <span class="string">"@accounts.json"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">curl <span class="string">'localhost:9200/_cat/indices?v'</span></span></span><br><span class="line"></span><br><span class="line">health status index    uuid                   pri rep docs.count docs.deleted store.size pri.store.size</span><br><span class="line">yellow open   bank     3O23VfKaRse97IfFCLDPyA   1   1       1000            0      414kb          414kb</span><br><span class="line">yellow open   customer pcIogOc6SjyqyPlSh0vmzw   1   1          3            0        4kb            4kb</span><br></pre></td></tr></table></figure>
<p>表明已经成功将1000份文件批量索引到银行索引中下的账户下</p>
<h3 id="搜索API"><a href="#搜索API" class="headerlink" title="搜索API"></a>搜索API</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET "localhost:9200/bank/_search?q=*&amp;sort=account_number:asc&amp;pretty&amp;pretty"</span><br></pre></td></tr></table></figure>
<ul>
<li><code>q*</code>：表示ES匹配索引中所有文档</li>
<li><code>sort=account_number:asc</code>：表示使用每个文档的acount_number字段进行升序排序</li>
<li><code>pretty</code>：表示返回格式化的JSON</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"took"</span> : <span class="number">63</span>,</span><br><span class="line">  <span class="attr">"timed_out"</span> : <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"_shards"</span> : &#123;</span><br><span class="line">    <span class="attr">"total"</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"successful"</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"skipped"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"failed"</span> : <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"hits"</span> : &#123;</span><br><span class="line">    <span class="attr">"total"</span> : <span class="number">1000</span>,</span><br><span class="line">    <span class="attr">"max_score"</span> : <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"hits"</span> : [ &#123;</span><br><span class="line">      <span class="attr">"_index"</span> : <span class="string">"bank"</span>,</span><br><span class="line">      <span class="attr">"_type"</span> : <span class="string">"account"</span>,</span><br><span class="line">      <span class="attr">"_id"</span> : <span class="string">"0"</span>,</span><br><span class="line">      <span class="attr">"sort"</span>: [<span class="number">0</span>],</span><br><span class="line">      <span class="attr">"_score"</span> : <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">"_source"</span> : &#123;<span class="attr">"account_number"</span>:<span class="number">0</span>,<span class="attr">"balance"</span>:<span class="number">16623</span>,<span class="attr">"firstname"</span>:<span class="string">"Bradshaw"</span>,<span class="attr">"lastname"</span>:<span class="string">"Mckenzie"</span>,<span class="attr">"age"</span>:<span class="number">29</span>,<span class="attr">"gender"</span>:<span class="string">"F"</span>,<span class="attr">"address"</span>:<span class="string">"244 Columbus Place"</span>,<span class="attr">"employer"</span>:<span class="string">"Euron"</span>,<span class="attr">"email"</span>:<span class="string">"bradshawmckenzie@euron.com"</span>,<span class="attr">"city"</span>:<span class="string">"Hobucken"</span>,<span class="attr">"state"</span>:<span class="string">"CO"</span>&#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="attr">"_index"</span> : <span class="string">"bank"</span>,</span><br><span class="line">      <span class="attr">"_type"</span> : <span class="string">"account"</span>,</span><br><span class="line">      <span class="attr">"_id"</span> : <span class="string">"1"</span>,</span><br><span class="line">      <span class="attr">"sort"</span>: [<span class="number">1</span>],</span><br><span class="line">      <span class="attr">"_score"</span> : <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">"_source"</span> : &#123;<span class="attr">"account_number"</span>:<span class="number">1</span>,<span class="attr">"balance"</span>:<span class="number">39225</span>,<span class="attr">"firstname"</span>:<span class="string">"Amber"</span>,<span class="attr">"lastname"</span>:<span class="string">"Duke"</span>,<span class="attr">"age"</span>:<span class="number">32</span>,<span class="attr">"gender"</span>:<span class="string">"M"</span>,<span class="attr">"address"</span>:<span class="string">"880 Holmes Lane"</span>,<span class="attr">"employer"</span>:<span class="string">"Pyrami"</span>,<span class="attr">"email"</span>:<span class="string">"amberduke@pyrami.com"</span>,<span class="attr">"city"</span>:<span class="string">"Brogan"</span>,<span class="attr">"state"</span>:<span class="string">"IL"</span>&#125;</span><br><span class="line">    &#125;, ...</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>响应部分：</p>
<ul>
<li><code>took</code>：执行搜索的时间</li>
<li><code>timed_out</code>：告诉我们搜索是否超时</li>
<li><code>_shards</code>：告诉我们搜索了多少碎片，以及成功 / 失败的搜索碎片的数量</li>
<li><code>hits</code>：搜索结果</li>
<li><code>hits.total</code>：符合搜索约束的文档数量</li>
<li><code>hits.hits</code>：搜索结果的实际数组</li>
<li><code>hits.sort</code>：结果的排序key</li>
<li><code>hits._score</code>、<code>max_score</code></li>
</ul>
<p>下面是上面的替换方案</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET "localhost:9200/bank/_search?pretty" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123; "match_all": &#123;&#125; &#125;,</span><br><span class="line">  "sort": [</span><br><span class="line">    &#123; "account_number": "asc" &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure>
<p>这边的区别是，没有在URI中传递参数，而是向API提供了JSON格式的查询请求体。</p>
<h3 id="Query-Language"><a href="#Query-Language" class="headerlink" title="Query Language"></a>Query Language</h3><p>ElasticSearch提供了JSON风格的查询语言</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/query-dsl.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/6.0/query-dsl.html</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET "localhost:9200/bank/_search?pretty" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123; "match_all": &#123;&#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure>
<p><code>query</code>部分告诉查询定义是什么，<code>match_all</code>只是搜索指定索引中的所有文档。</p>
<p>除此之外，我们烟叶可以传递其他参数来影响搜索结果，在例子中使用了<code>sort</code>，这边我们可以使用<code>size</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -X GET <span class="string">"localhost:9200/bank/_search?pretty"</span> -H <span class="string">'Content-Type: application/json'</span> -d<span class="string">'</span></span></span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123; "match_all": &#123;&#125; &#125;,</span><br><span class="line">  "size": 1</span><br><span class="line">&#125;</span><br><span class="line">'</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "took" : 6,</span><br><span class="line">  "timed_out" : false,</span><br><span class="line">  "_shards" : &#123;</span><br><span class="line">    "total" : 1,</span><br><span class="line">    "successful" : 1,</span><br><span class="line">    "skipped" : 0,</span><br><span class="line">    "failed" : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  "hits" : &#123;</span><br><span class="line">    "total" : &#123;</span><br><span class="line">      "value" : 1000,</span><br><span class="line">      "relation" : "eq"</span><br><span class="line">    &#125;,</span><br><span class="line">    "max_score" : 1.0,</span><br><span class="line">    "hits" : [</span><br><span class="line">      &#123;</span><br><span class="line">        "_index" : "bank",</span><br><span class="line">        "_type" : "account",</span><br><span class="line">        "_id" : "1",</span><br><span class="line">        "_score" : 1.0,</span><br><span class="line">        "_source" : &#123;</span><br><span class="line">          "account_number" : 1,</span><br><span class="line">          "balance" : 39225,</span><br><span class="line">          "firstname" : "Amber",</span><br><span class="line">          "lastname" : "Duke",</span><br><span class="line">          "age" : 32,</span><br><span class="line">          "gender" : "M",</span><br><span class="line">          "address" : "880 Holmes Lane",</span><br><span class="line">          "employer" : "Pyrami",</span><br><span class="line">          "email" : "amberduke@pyrami.com",</span><br><span class="line">          "city" : "Brogan",</span><br><span class="line">          "state" : "IL"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果没有指定<code>size</code>，默认大小是10.</p>
<p>下面的例子匹配所有文档，返回从第十个开始的十个文档：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET "localhost:9200/bank/_search?pretty" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123; "match_all": &#123;&#125; &#125;,</span><br><span class="line">  "from": 10,</span><br><span class="line">  "size": 10</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure>
<p><code>from</code>参数指定文档从那个index开始，<code>size</code>表示从from开始返回多少个文档。</p>
<p>下面匹配所有结果，按照账户余额降序排序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">curl -X GET <span class="string">"localhost:9200/bank/_search?pretty"</span> -H <span class="string">'Content-Type: application/json'</span> -d<span class="string">'</span></span></span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123; "match_all": &#123;&#125; &#125;,</span><br><span class="line">  "sort": &#123; "balance": &#123; "order": "desc" &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure>
<h3 id="执行搜索"><a href="#执行搜索" class="headerlink" title="执行搜索"></a>执行搜索</h3><p>上面已经介绍了基础的查询参数，下面更加深入Query DSL。</p>
<p>返回文档的field。默认整个JSON 文档作为搜索查询的部分返回。这和查询语句中的<code>_source</code>有关，我们可以指定一部分fields返回。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET "localhost:9200/bank/_search?pretty" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123; "match_all": &#123;&#125; &#125;,</span><br><span class="line">  "_source": ["account_number", "balance"]</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure>
<p>上面的例子通过<code>_source</code>减少了返回的属性。</p>
<p>和SQL中的<code>SELECT FROM</code>相似</p>
<p>使用<code>match</code>来查询：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET "localhost:9200/bank/_search?pretty" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123; "match": &#123; "account_number": 20 &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure>
<p>返回了所有的账户地址中包含’mill’</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET "localhost:9200/bank/_search?pretty" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123; "match": &#123; "address": "mill" &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure>
<p>返回账户地址中包含’mill’或’lane’</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET "localhost:9200/bank/_search?pretty" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123; "match": &#123; "address": "mill lane" &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure>
<p><code>match</code>的变体<code>match_phrase</code>返回了地址包含”mill lane”的账户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET "localhost:9200/bank/_search?pretty" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123; "match_phrase": &#123; "address": "mill lane" &#125; &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure>
<p>下面是<code>bool</code> query，它能够将较小的查询组合成更大的查询</p>
<p>下面的例子组合两个<code>match</code>查询</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET "localhost:9200/bank/_search?pretty" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "must": [</span><br><span class="line">        &#123; "match": &#123; "address": "mill" &#125; &#125;,</span><br><span class="line">        &#123; "match": &#123; "address": "lane" &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure>
<p><code>bool must</code>子句表示所有的查询必须是true。</p>
<p>同样也可以满足一个条件也返回：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET "localhost:9200/bank/_search?pretty" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "should": [</span><br><span class="line">        &#123; "match": &#123; "address": "mill" &#125; &#125;,</span><br><span class="line">        &#123; "match": &#123; "address": "lane" &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure>
<p>返回两个都不满足的结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET "localhost:9200/bank/_search?pretty" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "must_not": [</span><br><span class="line">        &#123; "match": &#123; "address": "mill" &#125; &#125;,</span><br><span class="line">        &#123; "match": &#123; "address": "lane" &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure>
<p>上面提到的<code>must should must_not</code>子句可以同时用在<code>bool</code> query中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET "localhost:9200/bank/_search?pretty" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "must": [</span><br><span class="line">        &#123; "match": &#123; "age": "40" &#125; &#125;</span><br><span class="line">      ],</span><br><span class="line">      "must_not": [</span><br><span class="line">        &#123; "match": &#123; "state": "ID" &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure>
<h3 id="执行过滤"><a href="#执行过滤" class="headerlink" title="执行过滤"></a>执行过滤</h3><p>前面的章节，我们忽略了一些小细节，文档的score(在搜索结果的<code>_score</code>字段)。它用于度量文档和查询语句的匹配程度。</p>
<p>但是查询不需要总是产生score。尤其是在用户filter文档时，ES会自动优化查询，避免计算无用的score。</p>
<p>上个章节的<code>bool</code>查询支持<code>filter</code>子句。</p>
<p>下面的例子上使用<code>bool</code> query返回所有余额在20000-30000的账户：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET "localhost:9200/bank/_search?pretty" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "must": &#123; "match_all": &#123;&#125; &#125;,</span><br><span class="line">      "filter": &#123;</span><br><span class="line">        "range": &#123;</span><br><span class="line">          "balance": &#123;</span><br><span class="line">            "gte": 20000,</span><br><span class="line">            "lte": 30000</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure>
<h3 id="执行聚合"><a href="#执行聚合" class="headerlink" title="执行聚合"></a>执行聚合</h3><p>聚合提供了对数据进行分组和统计信息的能力</p>
<p>对所有账户进行分组</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET "localhost:9200/bank/_search?pretty" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "group_by_state": &#123;</span><br><span class="line">      "terms": &#123;</span><br><span class="line">        "field": "state.keyword"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure>
<p><code>size=0</code>为了不显示搜索，只希望看见聚合结构。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET "localhost:9200/bank/_search?pretty" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "group_by_state": &#123;</span><br><span class="line">      "terms": &#123;</span><br><span class="line">        "field": "state.keyword"</span><br><span class="line">      &#125;,</span><br><span class="line">      "aggs": &#123;</span><br><span class="line">        "average_balance": &#123;</span><br><span class="line">          "avg": &#123;</span><br><span class="line">            "field": "balance"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure>
<p>在分组的基础上，计算每组的平均账户余额</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET "localhost:9200/bank/_search?pretty" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "group_by_state": &#123;</span><br><span class="line">      "terms": &#123;</span><br><span class="line">        "field": "state.keyword",</span><br><span class="line">        "order": &#123;</span><br><span class="line">          "average_balance": "desc"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      "aggs": &#123;</span><br><span class="line">        "average_balance": &#123;</span><br><span class="line">          "avg": &#123;</span><br><span class="line">            "field": "balance"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure>
<p>在上面的基础上，对平均余额进行降序</p>
<p>按年龄段(20-29岁，30-39岁，40-49岁)分组，然后按性别分组，最后得到每个年龄段，每个性别的平均账户余额:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X GET "localhost:9200/bank/_search?pretty" -H 'Content-Type: application/json' -d'</span><br><span class="line">&#123;</span><br><span class="line">  "size": 0,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "group_by_age": &#123;</span><br><span class="line">      "range": &#123;</span><br><span class="line">        "field": "age",</span><br><span class="line">        "ranges": [</span><br><span class="line">          &#123;</span><br><span class="line">            "from": 20,</span><br><span class="line">            "to": 30</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            "from": 30,</span><br><span class="line">            "to": 40</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            "from": 40,</span><br><span class="line">            "to": 50</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      "aggs": &#123;</span><br><span class="line">        "group_by_gender": &#123;</span><br><span class="line">          "terms": &#123;</span><br><span class="line">            "field": "gender.keyword"</span><br><span class="line">          &#125;,</span><br><span class="line">          "aggs": &#123;</span><br><span class="line">            "average_balance": &#123;</span><br><span class="line">              "avg": &#123;</span><br><span class="line">                "field": "balance"</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">'</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.0/" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/6.0/</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>使用Numpy实现机器学习算法</title>
    <url>/2019/11/01/ML-Based-Numpy/</url>
    <content><![CDATA[<h1 id="Realize-classical-ML-Algorithm-By-Numpy"><a href="#Realize-classical-ML-Algorithm-By-Numpy" class="headerlink" title="Realize classical ML Algorithm By Numpy"></a>Realize classical ML Algorithm By Numpy</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Import packages needed for coding</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, <span class="number">50</span>)</span><br><span class="line">y = <span class="number">3</span> * x + <span class="number">3</span> + np.random.randn(x.size)</span><br><span class="line">N = len(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plt.scatter(x, y)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Parameters</span></span><br><span class="line">LR = <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line">plt.ion()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grad</span><span class="params">(w, b)</span>:</span></span><br><span class="line">    <span class="comment"># Compute Gradient</span></span><br><span class="line">    b_grad = (<span class="number">-2</span> / N * (y - (w * x + b))).sum()</span><br><span class="line">    w_grad = (<span class="number">-2</span> / N * x * (y - (w * x + b))).sum()</span><br><span class="line">    <span class="keyword">return</span> w_grad, b_grad</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimizer</span><span class="params">(w, b)</span>:</span></span><br><span class="line">    <span class="comment"># Optimizer</span></span><br><span class="line">    plt.scatter(x, y)</span><br><span class="line">    w_grad, b_grad = grad(w, b)</span><br><span class="line"></span><br><span class="line">    new_w = w - LR * w_grad</span><br><span class="line">    new_b = b - LR * b_grad</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_w, new_b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">losses = []</span><br><span class="line"></span><br><span class="line">W, B, EPOCH = <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(EPOCH):</span><br><span class="line">    W, B = optimizer(W, B)</span><br><span class="line">    P = W * x + B</span><br><span class="line"></span><br><span class="line">    plt.cla()</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    plt.scatter(x, y)</span><br><span class="line">    plt.plot(x, P, c=<span class="string">'red'</span>)</span><br><span class="line">    loss = np.abs((P - y).mean())</span><br><span class="line">    plt.xlabel(<span class="string">f"Loss: <span class="subst">&#123;loss&#125;</span>.4f"</span>)</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    losses.append(loss)</span><br><span class="line">    plt.plot(losses,<span class="string">'yo-'</span>)</span><br><span class="line">    plt.pause(<span class="number">0.01</span>)</span><br><span class="line">    print(<span class="string">f"Epoch : <span class="subst">&#123;epoch&#125;</span>, Loss : <span class="subst">&#123;loss&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">plt.ioff()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h2 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Load Data</span></span><br><span class="line">LR = <span class="number">0.01</span></span><br><span class="line">MAX_EPOCH = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">theta = np.zeros((<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># theta = np.array([-16.38, 0.1483, 0.1589]).reshape(3, 1)</span></span><br><span class="line"></span><br><span class="line">rx = np.fromfile(<span class="string">'ex4/ex4x.dat'</span>, sep=<span class="string">'\n'</span>).reshape(<span class="number">-1</span>, <span class="number">2</span>)</span><br><span class="line">x = (rx - rx.mean(<span class="number">0</span>))/rx.std(<span class="number">0</span>) <span class="comment"># z-score 归一化</span></span><br><span class="line">x = np.hstack((np.ones((<span class="number">80</span>, <span class="number">1</span>)), x))</span><br><span class="line">y = np.fromfile(<span class="string">'ex4/ex4y.dat'</span>, sep=<span class="string">'\n'</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">N = x.shape[<span class="number">0</span>]</span><br><span class="line">pos = (y == <span class="number">1</span>)[:, <span class="number">0</span>]</span><br><span class="line">neg = (y == <span class="number">0</span>)[:, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">L = list()</span><br><span class="line">L.clear()</span><br><span class="line"><span class="comment"># plt.scatter(x[pos, 1], x[pos, 2], marker='+', c='red')</span></span><br><span class="line"><span class="comment"># plt.scatter(x[neg, 1], x[neg, 2], marker='o', c='blue')</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(z)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-z))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GD</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> theta, x, y</span><br><span class="line">    h = sigmoid(x.dot(theta))</span><br><span class="line">    grad = (x.T).dot(y - h)</span><br><span class="line">    l = np.exp((np.log(h).T.dot(y) + np.log(<span class="number">1</span> - h).T.dot(<span class="number">1</span>-y)).sum()/N)</span><br><span class="line">    <span class="keyword">return</span> grad, l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SGD</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> theta, x, y</span><br><span class="line">    r = np.random.randint(<span class="number">0</span>, x.shape[<span class="number">0</span>])</span><br><span class="line">    h = sigmoid(x[r, np.newaxis].dot(theta))</span><br><span class="line">    grad = (y[r] - h)*(x[r, np.newaxis].T)</span><br><span class="line">    l = np.exp((np.log(h).T.dot(y[r]) + np.log(<span class="number">1</span> - h).T.dot(<span class="number">1</span>-y[r])).sum())</span><br><span class="line">    <span class="keyword">return</span> grad, l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NewTon</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> theta, x, y</span><br><span class="line">    h = sigmoid(x.dot(theta))</span><br><span class="line">    grad = (x.T).dot(h-y)/N</span><br><span class="line">    H = (<span class="number">1</span>/N)*x.T.dot(np.diag(np.squeeze(h))</span><br><span class="line">                      ).dot(np.diag(np.squeeze(<span class="number">1</span>-h))).dot(x)</span><br><span class="line">    d = - np.linalg.inv(H).dot(grad)</span><br><span class="line">    l = np.exp(-(np.log(h).T.dot(y) + np.log(<span class="number">1</span> - h).T.dot(<span class="number">1</span>-y)).sum()/N)</span><br><span class="line">    <span class="keyword">return</span> d, l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimizer</span><span class="params">(way)</span>:</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> way == <span class="string">'GD'</span>:</span><br><span class="line">        res, l = GD()</span><br><span class="line">    <span class="keyword">if</span> way == <span class="string">'SGD'</span>:</span><br><span class="line">        res, l = SGD()</span><br><span class="line">    <span class="keyword">if</span> way == <span class="string">'NT'</span>:</span><br><span class="line">        res, l = NewTon()</span><br><span class="line">    <span class="keyword">global</span> theta, LR, L</span><br><span class="line">    theta = theta + LR * res</span><br><span class="line">    L.append(l)</span><br><span class="line"><span class="comment">#     print(f"grad : &#123;res&#125;, theta: &#123;theta&#125;")</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = np.linspace(np.min(x[:, <span class="number">1</span>]), np.max(x[:, <span class="number">1</span>]), <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">plt.clf()</span><br><span class="line">plt.ion()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(MAX_EPOCH):</span><br><span class="line">    optimizer(<span class="string">'NT'</span>)</span><br><span class="line">    plt.figure(figsize=(<span class="number">12</span>, <span class="number">5</span>), dpi=<span class="number">80</span>)</span><br><span class="line">    plt.subplot(<span class="number">121</span>)</span><br><span class="line">    plt.xlim(np.min(x[:,<span class="number">1</span>]), np.max(x[:,<span class="number">1</span>]))</span><br><span class="line">    plt.ylim(np.min(x[:,<span class="number">2</span>]), np.max(x[:,<span class="number">2</span>]))</span><br><span class="line">    plt.scatter(x[pos, <span class="number">1</span>], x[pos, <span class="number">2</span>], marker=<span class="string">'+'</span>, label=<span class="string">"Admitted"</span>, c=<span class="string">'red'</span>)</span><br><span class="line">    plt.scatter(x[neg, <span class="number">1</span>],</span><br><span class="line">                x[neg, <span class="number">2</span>],</span><br><span class="line">                marker=<span class="string">'o'</span>,</span><br><span class="line">                label=<span class="string">'Not Admitted'</span>,</span><br><span class="line">                c=<span class="string">'blue'</span>)</span><br><span class="line">    plt.plot(d,</span><br><span class="line">             -(theta[<span class="number">0</span>, <span class="number">0</span>] + theta[<span class="number">1</span>, <span class="number">0</span>] * d) / theta[<span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">             <span class="string">'r'</span>,</span><br><span class="line">             c=<span class="string">'green'</span>,</span><br><span class="line">             label=<span class="string">'descision boundary'</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">"upper right"</span>)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">122</span>)</span><br><span class="line">    plt.plot(L)</span><br><span class="line">    plt.pause(<span class="number">0.01</span>)</span><br><span class="line">    print(<span class="string">f'Epoch: <span class="subst">&#123;epoch&#125;</span>, Loss: <span class="subst">&#123;L[<span class="number">-1</span>]&#125;</span>'</span>)</span><br><span class="line">    <span class="keyword">if</span> L[<span class="number">-1</span>] &lt; <span class="number">0.5</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">plt.ioff()</span><br><span class="line">plt.show()</span><br><span class="line">print(theta)</span><br></pre></td></tr></table></figure>
<h2 id="Softmax-Regression"><a href="#Softmax-Regression" class="headerlink" title="Softmax Regression"></a>Softmax Regression</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Load Data</span></span><br><span class="line">LR = <span class="number">0.01</span></span><br><span class="line">MAX_EPOCH = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">theta = np.zeros((<span class="number">3</span>,<span class="number">2</span> ))</span><br><span class="line"><span class="comment"># theta = np.array([-16.38, 0.1483, 0.1589]).reshape(3, 1)</span></span><br><span class="line"></span><br><span class="line">rx = np.fromfile(<span class="string">'ex4/ex4x.dat'</span>, sep=<span class="string">'\n'</span>).reshape(<span class="number">-1</span>, <span class="number">2</span>)</span><br><span class="line">x = (rx - rx.mean(<span class="number">0</span>))/rx.std(<span class="number">0</span>) <span class="comment"># z-score 归一化</span></span><br><span class="line">x = np.hstack((np.ones((<span class="number">80</span>, <span class="number">1</span>)), x))</span><br><span class="line">y = np.fromfile(<span class="string">'ex4/ex4y.dat'</span>, sep=<span class="string">'\n'</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N = x.shape[<span class="number">0</span>]</span><br><span class="line">pos = (y == <span class="number">1</span>)[:, <span class="number">0</span>]</span><br><span class="line">neg = (y == <span class="number">0</span>)[:, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">loss = list()</span><br><span class="line">loss.clear()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GD</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> theta, x, y</span><br><span class="line">    grad = np.zeros((<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(theta.shape[<span class="number">1</span>]<span class="number">-1</span>):</span><br><span class="line">        theta_k = theta[:,k]</span><br><span class="line">        grad_k = np.zeros((<span class="number">3</span>,<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> i,xi <span class="keyword">in</span> enumerate(x):</span><br><span class="line">            j = y[i,<span class="number">0</span>] <span class="comment"># the class  of current item</span></span><br><span class="line">            t = <span class="number">1</span> <span class="keyword">if</span> k==j <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            h_k = np.exp(xi.dot(theta_k))/np.exp(xi.dot(theta)).sum()</span><br><span class="line">            l += t*np.log(h_k)</span><br><span class="line">            grad_k += (xi.T*(t - h_k))[:,np.newaxis]</span><br><span class="line">        grad[:,k]= grad_k[:,<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> grad,l</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SGD</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> theta, x, y</span><br><span class="line">    grad = np.zeros((<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = np.random.randint(<span class="number">0</span>, x.shape[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(theta.shape[<span class="number">1</span>]<span class="number">-1</span>):</span><br><span class="line">        theta_k = theta[:,k]</span><br><span class="line">        xi = x[r]</span><br><span class="line">        j = y[r,<span class="number">0</span>] <span class="comment"># the class  of current item</span></span><br><span class="line">        t = <span class="number">1</span> <span class="keyword">if</span> k==j <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        h_k = np.exp(xi.dot(theta_k))/np.exp(xi.dot(theta)).sum()</span><br><span class="line">        l += t*np.log(h_k)</span><br><span class="line">        grad_k = (xi.T*(t - h_k))[:,np.newaxis]</span><br><span class="line">        grad[:,k]= grad_k[:,<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> grad,l</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">optimizer</span><span class="params">(method=<span class="string">'GD'</span>)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> theta,loss</span><br><span class="line">    <span class="keyword">if</span> method == <span class="string">'GD'</span>:</span><br><span class="line">        grad,l = GD()</span><br><span class="line">    <span class="keyword">elif</span> method == <span class="string">'SGD'</span>:</span><br><span class="line">        grad,l = SGD()</span><br><span class="line">    theta = theta + LR*grad</span><br><span class="line">    loss.append(np.exp(l))</span><br><span class="line"></span><br><span class="line">d = np.linspace(np.min(x[:, <span class="number">1</span>]), np.max(x[:, <span class="number">1</span>]), <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">plt.clf()</span><br><span class="line">plt.ion()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(MAX_EPOCH):</span><br><span class="line">    optimizer(<span class="string">'SGD'</span>)</span><br><span class="line">    plt.figure(figsize=(<span class="number">12</span>, <span class="number">5</span>), dpi=<span class="number">80</span>)</span><br><span class="line">    plt.subplot(<span class="number">121</span>)</span><br><span class="line">    plt.xlim(np.min(x[:,<span class="number">1</span>]), np.max(x[:,<span class="number">1</span>]))</span><br><span class="line">    plt.ylim(np.min(x[:,<span class="number">2</span>]), np.max(x[:,<span class="number">2</span>]))</span><br><span class="line">    plt.scatter(x[pos, <span class="number">1</span>], x[pos, <span class="number">2</span>], marker=<span class="string">'+'</span>, label=<span class="string">"Admitted"</span>, c=<span class="string">'red'</span>)</span><br><span class="line">    plt.scatter(x[neg, <span class="number">1</span>],</span><br><span class="line">                x[neg, <span class="number">2</span>],</span><br><span class="line">                marker=<span class="string">'o'</span>,</span><br><span class="line">                label=<span class="string">'Not Admitted'</span>,</span><br><span class="line">                c=<span class="string">'blue'</span>)</span><br><span class="line">    plt.plot(d,</span><br><span class="line">             -(theta[<span class="number">0</span>, <span class="number">0</span>] + theta[<span class="number">1</span>, <span class="number">0</span>] * d) / theta[<span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">             <span class="string">'r'</span>,</span><br><span class="line">             c=<span class="string">'green'</span>,</span><br><span class="line">             label=<span class="string">'descision boundary'</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">"upper right"</span>)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">122</span>)</span><br><span class="line">    plt.ylim(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">    plt.plot(loss)</span><br><span class="line">    plt.pause(<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f'Epoch: <span class="subst">&#123;epoch&#125;</span>, Loss: <span class="subst">&#123;loss[<span class="number">-1</span>]&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">plt.ioff()</span><br><span class="line">plt.show()</span><br><span class="line">print(theta)</span><br></pre></td></tr></table></figure>
<h2 id="Perceptron（感知器）"><a href="#Perceptron（感知器）" class="headerlink" title="Perceptron（感知器）"></a>Perceptron（感知器）</h2><ul>
<li>二分类<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load Data</span></span><br><span class="line">LR = <span class="number">0.5</span></span><br><span class="line">MAX_EPOCH = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">theta = np.zeros((<span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment"># theta = np.array([-16.38, 0.1483, 0.1589]).reshape(3, 1)</span></span><br><span class="line"></span><br><span class="line">rx = np.fromfile(<span class="string">'ex4/ex4x.dat'</span>, sep=<span class="string">'\n'</span>).reshape(<span class="number">-1</span>, <span class="number">2</span>)</span><br><span class="line">x = (rx - rx.mean(<span class="number">0</span>)) / rx.std(<span class="number">0</span>)  <span class="comment"># z-score 归一化</span></span><br><span class="line">x = np.hstack((np.ones((<span class="number">80</span>, <span class="number">1</span>)), x))</span><br><span class="line">rank = np.arange(<span class="number">0</span>, x.shape[<span class="number">0</span>])</span><br><span class="line">np.random.shuffle(rank)</span><br><span class="line">x = x[rank]</span><br><span class="line">y = np.fromfile(<span class="string">'ex4/ex4y.dat'</span>, sep=<span class="string">'\n'</span>).reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">y = y[rank]</span><br><span class="line">N = x.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">pos = (y == <span class="number">1</span>)[:, <span class="number">0</span>]</span><br><span class="line">neg = (y == <span class="number">0</span>)[:, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">threshold = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">d = np.linspace(np.min(x[:, <span class="number">1</span>]), np.max(x[:, <span class="number">1</span>]), <span class="number">100</span>)</span><br><span class="line">plt.ion()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(MAX_EPOCH):</span><br><span class="line">    error_count = <span class="number">0</span></span><br><span class="line">    err_idx = []</span><br><span class="line">    err_value = []</span><br><span class="line">    <span class="keyword">for</span> i, xi <span class="keyword">in</span> enumerate(x):</span><br><span class="line">        result = xi.dot(theta) &gt;= threshold</span><br><span class="line">        error_i = y[i, <span class="number">0</span>] - result</span><br><span class="line">        <span class="keyword">if</span> error_i != <span class="number">0</span>:</span><br><span class="line">            error_count += <span class="number">1</span></span><br><span class="line">            err_idx.append(i)</span><br><span class="line">            <span class="comment"># theta += LR * error_i * xi.reshape(-1, 1) #性能比较差</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 随机选取一个修改</span></span><br><span class="line">    idx = err_idx[np.random.randint(<span class="number">0</span>, len(err_idx))]</span><br><span class="line">    xr = x[idx, :]</span><br><span class="line">    result = xr.dot(theta) &gt;= threshold</span><br><span class="line">    err_i = y[idx, <span class="number">0</span>] - result</span><br><span class="line">    theta += LR * err_i * xr.reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"Epoch: <span class="subst">&#123;epoch&#125;</span>, Error Count: <span class="subst">&#123;error_count&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">if</span> epoch % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        plt.clf()</span><br><span class="line"></span><br><span class="line">        x1_min, x1_max = x[:, <span class="number">1</span>].min() - <span class="number">.5</span>, x[:, <span class="number">1</span>].max() + <span class="number">.5</span></span><br><span class="line">        x2_min, x2_max = x[:, <span class="number">2</span>].min() - <span class="number">.5</span>, x[:, <span class="number">2</span>].max() + <span class="number">.5</span></span><br><span class="line">        step = <span class="number">0.02</span></span><br><span class="line">        xx1, xx2 = np.meshgrid(np.arange(x1_min, x1_max, step), np.arange(x2_min, x2_max, step))</span><br><span class="line">        testData = np.c_[xx1.ravel(), xx2.ravel()]</span><br><span class="line">        testData = np.hstack((np.ones((testData.shape[<span class="number">0</span>], <span class="number">1</span>)), testData))</span><br><span class="line"></span><br><span class="line">        predicted = testData.dot(theta) &gt;= threshold</span><br><span class="line">        print(predicted.shape)</span><br><span class="line">        plt.pcolormesh(xx1, xx2, predicted.reshape(xx1.shape), cmap=<span class="string">'gray'</span>)</span><br><span class="line"></span><br><span class="line">        plt.scatter(x[pos, <span class="number">1</span>], x[pos, <span class="number">2</span>], marker=<span class="string">'+'</span>, label=<span class="string">"Admitted"</span>, c=<span class="string">'red'</span>)</span><br><span class="line">        plt.scatter(x[neg, <span class="number">1</span>],</span><br><span class="line">                    x[neg, <span class="number">2</span>],</span><br><span class="line">                    marker=<span class="string">'o'</span>,</span><br><span class="line">                    label=<span class="string">'Not Admitted'</span>,</span><br><span class="line">                    c=<span class="string">'blue'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># plt.scatter(x[err_idx, 1],</span></span><br><span class="line">        <span class="comment">#             x[err_idx, 2],</span></span><br><span class="line">        <span class="comment">#             marker='^',</span></span><br><span class="line">        <span class="comment">#             label='Error',</span></span><br><span class="line">        <span class="comment">#             c='orange')</span></span><br><span class="line"></span><br><span class="line">        plt.legend(loc=<span class="string">"upper left"</span>)</span><br><span class="line">        plt.pause(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> error_count == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">print(theta)</span><br><span class="line"></span><br><span class="line">plt.ioff()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>NLP模型结构</title>
    <url>/2020/05/02/NLP%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="NLP模型结构"><a href="#NLP模型结构" class="headerlink" title="NLP模型结构"></a>NLP模型结构</h1><a id="more"></a>
<h2 id="TextCNN"><a href="#TextCNN" class="headerlink" title="TextCNN"></a>TextCNN</h2><p><a href="https://www.bbsmax.com/A/kjdwWe06dN/" target="_blank" rel="noopener">https://www.bbsmax.com/A/kjdwWe06dN/</a></p>
<p><img src="/images/nlp/TextCNN.jpg" alt="TextCNN"></p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title>Chomsky文法</title>
    <url>/2019/11/06/Chomsky%E6%96%87%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Chomsky-文法"><a href="#Chomsky-文法" class="headerlink" title="Chomsky 文法"></a>Chomsky 文法</h1><p>定义：四元组 $G(V,T,P,S)$</p>
<ul>
<li>$V$: 变量的非空有穷集合，是一个语法范畴，$V$的元素叫做语法变量或非终结符。</li>
<li>$T$：终结符的非空有限集，$T$的元素叫做终结符，满足$V\cap T = \varnothing $</li>
<li>$P$：产生式的非空有穷集合，$P$中的产生式形式为$\alpha \to \beta$，产生式左部$\alpha \in (V \cup T)^+ - T^+$，产生式右部$\beta \in (V \cup T)^*$</li>
<li>$S$：文法的开始符号，也叫识别符号，$S \in V$</li>
</ul>
<a id="more"></a>
<h2 id="0型文法"><a href="#0型文法" class="headerlink" title="0型文法"></a>0型文法</h2><p>也叫短语结构文法，对应的语言叫0型语言，短语结构语言或者递归可枚举集。</p>
<h2 id="1型文法"><a href="#1型文法" class="headerlink" title="1型文法"></a>1型文法</h2><p>在0型文法的基础上，如果对于$\forall  \alpha \to \beta \in P$，且$|\beta| \ge |\alpha|$，或如果对于$\forall xUy  \to xuy \in P$，且$|xuy| \ge |xUy|$，其中$U \in V,\quad x,y \in V^*,\quad u\in V^*$，则该文法为1型文法，或上下文有关文法，对应的语言叫1型语言，或上下文有关语言。</p>
<h2 id="2型文法"><a href="#2型文法" class="headerlink" title="2型文法"></a>2型文法</h2><p>在1型文法的基础上，如果对于$\forall \alpha \to \beta \in P$，且$\alpha \in V$，则该文法为2型文法或上下文无关文法，其对应的语言为2型语言或上下文无关的语言。</p>
<h2 id="3型文法"><a href="#3型文法" class="headerlink" title="3型文法"></a>3型文法</h2><p>在2型文法的基础上，如果$\forall \alpha \to \beta \in P$，且$\alpha \to \beta$均具有形式</p>
<script type="math/tex; mode=display">
A \to w \\ A \to wB \\ A \to \varepsilon</script><p>其中，$A,B \in V,\; w \in T$，则该文法为3型文法，也称正则文法或正规文法，其对应的语言为3型语言，或正则语言或正规语言。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>0型文法无限制</li>
<li>1型文法产生式左边长度大于右边</li>
<li>2型文法产生式左边为单个非终结符</li>
</ol>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>ManjaroLinux启动问题</title>
    <url>/2020/03/25/ManjaroLinux%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="ManjaroLinux启动问题"><a href="#ManjaroLinux启动问题" class="headerlink" title="ManjaroLinux启动问题"></a>ManjaroLinux启动问题</h1><p>今早无意中更新系统失败，导致无法开机，提示无法找到linux内核模块。通过采取了一系列方式终于挽救了系统。</p>
<ul>
<li>一个使用较新版本Manjaro Linux的liveUSB</li>
<li>待修复设备需要联网环境</li>
</ul>
<p>通过liveUSB启动：</p>
<p>由于原先系统的文件保存在硬盘上，故liveUSB不会自动挂载硬盘，手动挂载硬盘到对应位置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo mkdir /mnt/manjaro</span><br><span class="line">sudo mount /dev/sda2 /mnt/manjaro <span class="comment"># sda2为/分区所在设备，可以使用lsblk查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#由于原来系统采用UEFI安装，分了一个分区作为引导分区，所以引导分区也要挂载对应位置，否则无法安装内核</span></span><br><span class="line">sudo mount /dev/sda1 /mnt/manjaro/boot/efi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于系统的虚拟目录，比如`/dev`和`/sys`,也需要手动绑定，，否则chroot后运行pacman会出错：</span></span><br><span class="line"></span><br><span class="line">sudo mount --<span class="built_in">bind</span> /dev /mnt/manjaro/dev</span><br><span class="line">sudo mount --<span class="built_in">bind</span> /proc /mnt/manjaro/proc</span><br><span class="line">sudo mount --<span class="built_in">bind</span> /sys /mnt/manjaro/sys</span><br></pre></td></tr></table></figure>
<p>在上面操作完成之后，系统文件以及准备好了，下面切换根目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /mnt/manjaro</span><br><span class="line">chroot .</span><br><span class="line">pacman -S linux <span class="comment"># 如果这一步报错，检查自己系统目录是否正确挂载，如果正确挂载则先运行pacman -S archlinux-keyring</span></span><br><span class="line"><span class="comment"># 内核重装完成后继续上次未完成的系统更新</span></span><br><span class="line">pacman -Syu</span><br></pre></td></tr></table></figure>
<p>思考：</p>
<p>对于这种方式应该可以用到其他系统，当系统因为某种原因启动失败，可以通过U盘进行启动系统进行修复。</p>
<p>参考来源：<a href="https://www.cnblogs.com/apocelipes/p/10192882.html" target="_blank" rel="noopener">https://www.cnblogs.com/apocelipes/p/10192882.html</a></p>
]]></content>
      <categories>
        <category>技能</category>
      </categories>
  </entry>
  <entry>
    <title>NestJs_Overview</title>
    <url>/2020/04/10/NestJs-Overview/</url>
    <content><![CDATA[<h1 id="NestJs"><a href="#NestJs" class="headerlink" title="NestJs"></a>NestJs</h1><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><ol>
<li><p>编程语言：TypeScript &amp; Node.js，需要使用Babel compiler.</p>
</li>
<li><p>前提条件：Node.js(&gt;=10.13.0) 被安装</p>
</li>
</ol>
<a id="more"></a>
<ol>
<li><p>设置</p>
<p>使用Nest CLI 来设置一个新项目。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">npm i -g @nestjs/cli</span></span><br><span class="line"><span class="meta">$</span><span class="bash">nest new project-name</span></span><br></pre></td></tr></table></figure>
<p>将会创建项目目录，node模块和一些其他的模板文件被安装，<code>src/</code>目录将被创建并创建核心文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">├── app.controller.spec.ts</span><br><span class="line">├── app.controller.ts</span><br><span class="line">├── app.module.ts</span><br><span class="line">├── app.service.ts</span><br><span class="line">└── main.ts</span><br></pre></td></tr></table></figure>
<ul>
<li><code>app.controller.ts</code>：单个路由的基础控制器例子</li>
<li><code>app.module.ts</code>：应用的root module</li>
<li><code>main.ts</code>：应用的入口文件，使用核心函数<code>NestFactory</code>创建一个Nest Application实例。</li>
</ul>
<p><code>main.ts</code>包含一个启动我们的应用的异步函数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NestFactory &#125; <span class="keyword">from</span> <span class="string">'@nestjs/core'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppModule &#125; <span class="keyword">from</span> <span class="string">'./app.module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create(AppModule);</span><br><span class="line">  <span class="keyword">await</span> app.listen(<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line">bootstrap();</span><br></pre></td></tr></table></figure>
</li>
<li><p>Platform</p>
<p>Nest目的是一个平台无关的框架，平台无关性使得Nest能够创建开发者能够用在不同类型应用的可重用的逻辑部分。技术上，Nest能够和任何HTTP框架一起工作，只要创建响应的adapter。有两个HTTP框架平台已经被支持：<strong>express</strong> 和 <strong>fastify</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create&lt;NestExpressApplication&gt;(AppModule);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>运行应用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">npm run start</span></span><br></pre></td></tr></table></figure>
<p>访问地址 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a></p>
</li>
</ol>
<h2 id="Controllers"><a href="#Controllers" class="headerlink" title="Controllers"></a>Controllers</h2><p>Controllers用于处理输入的请求，然后返回响应给客户端。</p>
<p>Controller的目的是接受特定的请求，路由机制控制Controller接受什么请求。每个Controller超过一个路由，不同的路由执行不同的操作。</p>
<h3 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h3><p><code>@Controller()</code>装饰器，用于定义一个基础的Controller。</p>
<p>使用下面命令创建一个Controller：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">nest g controller cats</span></span><br></pre></td></tr></table></figure>
<p><code>src/cats/cats.controller.ts</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Controller, Get &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">'cats'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CatsController &#123;</span><br><span class="line">  <span class="meta">@Get</span>()</span><br><span class="line">  findAll(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'This action returns all cats'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>@Controller()</code>装饰器熵指定路径前缀能够更加容易将一组相关的路由分组，减少重复的code。</p>
<p><code>findAll()</code>method上的<code>@Get()</code> HTTP Request method装饰器告诉Nest为一个具体的HTTP Requestschungking一个处理器。由于没有指定prefix，默认会处理<code>GEt /cat</code>请求。</p>
<p>控制响应的不同方法：</p>
<ul>
<li><p>Standard (recommended)</p>
<p>当request handler返回的是一个JavaScript对象或数组，它将会自动的序列化为JSON，当返回的是一个JavaScript基本类型，比如<code>string，number,boolean</code>，Nest发送对应的value，不会序列化。</p>
<p>进一步，响应的status code 默认总是200，除了POST requests使用201。我们也可以使用<code>@HttpCode(...)</code>装饰器来修改。</p>
</li>
</ul>
<ul>
<li><p>Library-specific</p>
<p>我们可以使用library-specific(e.g.,Express) response object，能够使用<code>@Res()</code>装饰器来注入到handler signature上，(e.g <code>findAll(@Res() response)</code>)。通过这种方式，可以使用原始的response处理方法。例如，对于Express，可以使用代码构造响应码<code>response.status(200).send()</code></p>
<p>注意：这两种方式不能同时使用。</p>
</li>
</ul>
<h3 id="Request-object"><a href="#Request-object" class="headerlink" title="Request object"></a>Request object</h3><p>Handers通常需要获得客户端request的详细情况，Nest提供了在platform下获取请求对象的方法，我们能够通过注入<code>@Req()</code>来实现</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Controller, Get, Req &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Request &#125; <span class="keyword">from</span> <span class="string">'express'</span></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">'cats'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CatsController &#123;</span><br><span class="line">    <span class="meta">@Get</span>()</span><br><span class="line">    findAll(<span class="meta">@Req</span>() request: Request) : <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This action returns all cats"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提示：为了使用<code>express</code> ,需要安装<code>@types/express</code>包</p>
<p>请求对象表示HTTP Request并且有请求查询字符串属性、参数、HTTP头、以及body等等。在大多数情况下，不需要手动获取这些属性。可以使用专用装饰器来代替，比如<code>@Body() or  @Query()</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>装饰器</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>@Request().@Res()</td>
<td>req</td>
</tr>
<tr>
<td>@Response(),@Res()</td>
<td>res</td>
</tr>
<tr>
<td>@Next()</td>
<td>next</td>
</tr>
<tr>
<td>@Session()</td>
<td>req.session</td>
</tr>
<tr>
<td>@Param(key?: string)</td>
<td>req.params / req.param[key]</td>
</tr>
<tr>
<td>@Body(key?: string)</td>
<td>req.body / req.body[key]</td>
</tr>
<tr>
<td>@Query(key?: string)</td>
<td>req.query / req.query[key]</td>
</tr>
<tr>
<td>@Headers(key?: string)</td>
<td>req.headers / req.headers[key]</td>
</tr>
<tr>
<td>@Ip()</td>
<td>req.ip</td>
</tr>
</tbody>
</table>
</div>
<p>注：当在方法使用了<code>@Res() or @Response()</code>，对于这个handler进入library-specific mode。必须手动处理响应。<code>e.g res.json(...) or res.send(...)</code>。否则HTTP Server将会宕机。</p>
<p>自定义装饰器：<a href="https://docs.nestjs.com/custom-decorators" target="_blank" rel="noopener">https://docs.nestjs.com/custom-decorators</a></p>
<h3 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h3><p>前面我们定义了endpoint来获取 cats resource (GET route)。也可以创建新的endpoint。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Controller, Get, Req, Post, Res &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Request,Response &#125; <span class="keyword">from</span> <span class="string">'express'</span></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">'cats'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CatsController &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Post</span>()</span><br><span class="line">    create() : <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"This action adds a new cat"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Get</span>()</span><br><span class="line">    findAll(<span class="meta">@Req</span>() request: Request,<span class="meta">@Res</span>() res: Response) : <span class="built_in">string</span>|<span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="comment">// return "This action returns all cats";</span></span><br><span class="line">        res.send(&#123;</span><br><span class="line">            status: <span class="literal">true</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Nest也提供了其他的标准HTTP request endpoint 装饰器 <code>@Put() @Delete() @Patch() @Options() @Head() @All()</code></p>
<h3 id="Route-wildcards-路由通配符"><a href="#Route-wildcards-路由通配符" class="headerlink" title="Route wildcards 路由通配符"></a>Route wildcards 路由通配符</h3><p>Nest也支持路由模式，比如可以使用星号作为通配符，来匹配任何字符的组合</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Get</span>(<span class="string">'ab*cd'</span>)</span><br><span class="line">test()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'This route uses a wildcar'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ab*cd</code>这个route path将匹配<code>abcd,ab_cd,abecd</code>等等。</p>
<p>符号<code>？，+，*,()</code>也可以使用在route path上，</p>
<h3 id="Status-code"><a href="#Status-code" class="headerlink" title="Status code"></a>Status code</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Post</span>()</span><br><span class="line"><span class="meta">@HttpCode</span>(<span class="number">204</span>)</span><br><span class="line">create() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'This action adds a new cat'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：<code>HttpCode</code>来源<code>@nestjs/common</code></p>
<h3 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Post</span>()</span><br><span class="line"><span class="meta">@Header</span>(<span class="string">'Cache-Control'</span>, <span class="string">'none'</span>)</span><br><span class="line">create() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'This action adds a new cat'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Redirection"><a href="#Redirection" class="headerlink" title="Redirection"></a>Redirection</h3><p>使用<code>@Redirect()</code>或者 library-specific response object 执行<code>res.redirect()</code></p>
<p><code>@Redirect()</code>需要一个<code>url</code>参数以及可选的<code>statusCode</code>参数，<code>statusCode</code>默认为<code>302</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Get</span>()</span><br><span class="line"><span class="meta">@Redirect</span>(<span class="string">'https://nestjs.com'</span>, <span class="number">301</span>)</span><br></pre></td></tr></table></figure>
<p>有时，需要动态的决定HTTP status code 或者 重定向的 URL，可以在route handler返回一个固定格式的对象</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"url"</span>: <span class="built_in">string</span>,</span><br><span class="line">  <span class="string">"statusCode"</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Get</span>(<span class="string">'docs'</span>)</span><br><span class="line"><span class="meta">@Redirect</span>(<span class="string">'https://docs.nestjs.com'</span>, <span class="number">302</span>)</span><br><span class="line">getDocs(<span class="meta">@Query</span>(<span class="string">'version'</span>) version) &#123;</span><br><span class="line">  <span class="keyword">if</span> (version &amp;&amp; version === <span class="string">'5'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; url: <span class="string">'https://docs.nestjs.com/v5/'</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Route-parameters"><a href="#Route-parameters" class="headerlink" title="Route parameters"></a>Route parameters</h3><p>当接受的动态数据是请求的一部分时，静态的路径将会无法工作。(e.g., GET /cats/1 to get cat with id 1).</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Get</span>(<span class="string">':id'</span>)</span><br><span class="line">findOne(<span class="meta">@Param</span>() params): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(params.id);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`This action returns a #<span class="subst">$&#123;params.id&#125;</span> cat`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Get</span>(<span class="string">':id'</span>)</span><br><span class="line">findOne(<span class="meta">@Param</span>(<span class="string">'id'</span>) id): <span class="built_in">string</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`This action returns a #<span class="subst">$&#123;id&#125;</span> cat`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Sub-Domain-Routing"><a href="#Sub-Domain-Routing" class="headerlink" title="Sub-Domain Routing"></a>Sub-Domain Routing</h3><p><code>@Controller()</code>的<code>host</code>选项可以匹配请求的HTTP host</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span>(&#123; host: <span class="string">'admin.example.com'</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AdminController &#123;</span><br><span class="line">  <span class="meta">@Get</span>()</span><br><span class="line">  index(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Admin page'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和路径相似，<code>host</code>也可以使用动态值</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span>(&#123; host: <span class="string">':account.example.com'</span> &#125;) <span class="keyword">export</span> <span class="keyword">class</span> AccountController </span><br><span class="line">&#123; </span><br><span class="line">    <span class="meta">@Get</span>()</span><br><span class="line"> 	getInfo(<span class="meta">@HostParam</span>(<span class="string">'account'</span>) account: <span class="built_in">string</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> account; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Scopes"><a href="#Scopes" class="headerlink" title="Scopes"></a>Scopes</h3><p><a href="https://docs.nestjs.com/fundamentals/injection-scopes" target="_blank" rel="noopener">https://docs.nestjs.com/fundamentals/injection-scopes</a></p>
<h3 id="Asynchronicity"><a href="#Asynchronicity" class="headerlink" title="Asynchronicity"></a>Asynchronicity</h3><p>数据处理大部分是异步的，这就是为什么Nest支持<code>async</code>函数</p>
<p><a href="https://kamilmysliwiec.com/typescript-2-1-introduction-async-await" target="_blank" rel="noopener">https://kamilmysliwiec.com/typescript-2-1-introduction-async-await</a></p>
<p>每个async 函数必须返回一个<code>Promise</code>，</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Get</span>()</span><br><span class="line"><span class="keyword">async</span> findAll(): <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>[]&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码是完全有效的，Nest route handle更加强大，能够返回一个 RxJS observable streams.</p>
<p><a href="http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html" target="_blank" rel="noopener">http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html</a></p>
<p>Nest将会自定订阅下面的源，一旦这个stream完成，产生最后的值</p>
<h3 id="Request-payloads"><a href="#Request-payloads" class="headerlink" title="Request payloads"></a>Request payloads</h3><p>上面的POST例子不能接受任何客户端参数，可以通过增加<code>@Body()</code>解决。</p>
<p>首先定义一个DTO (Data Transfer Object) schema。DTO用于定义数据在网络上发送。我们可以使用TypeScript 接口或类来定义。Nest推荐使用class。</p>
<p>create-cat.dto.ts</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CreateCatDto &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  breed: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Post</span>()</span><br><span class="line"><span class="keyword">async</span> create(<span class="meta">@Body</span>() createCatDto: CreateCatDto) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'This action adds a new cat'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整例子"><a href="#完整例子" class="headerlink" title="完整例子"></a>完整例子</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Controller, Get, Query, Post, Body, Put, Param, Delete &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CreateCatDto, UpdateCatDto, ListAllEntities &#125; <span class="keyword">from</span> <span class="string">'./dto'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">'cats'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CatsController &#123;</span><br><span class="line">  <span class="meta">@Post</span>()</span><br><span class="line">  create(<span class="meta">@Body</span>() createCatDto: CreateCatDto) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'This action adds a new cat'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Get</span>()</span><br><span class="line">  findAll(<span class="meta">@Query</span>() query: ListAllEntities) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`This action returns all cats (limit: <span class="subst">$&#123;query.limit&#125;</span> items)`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Get</span>(<span class="string">':id'</span>)</span><br><span class="line">  findOne(<span class="meta">@Param</span>(<span class="string">'id'</span>) id: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`This action returns a #<span class="subst">$&#123;id&#125;</span> cat`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Put</span>(<span class="string">':id'</span>)</span><br><span class="line">  update(<span class="meta">@Param</span>(<span class="string">'id'</span>) id: <span class="built_in">string</span>, <span class="meta">@Body</span>() updateCatDto: UpdateCatDto) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`This action updates a #<span class="subst">$&#123;id&#125;</span> cat`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Delete</span>(<span class="string">':id'</span>)</span><br><span class="line">  remove(<span class="meta">@Param</span>(<span class="string">'id'</span>) id: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`This action removes a #<span class="subst">$&#123;id&#125;</span> cat`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Getting-up-and-running"><a href="#Getting-up-and-running" class="headerlink" title="Getting up and running"></a>Getting up and running</h3><p>当上面的操作全部完成，Nest现在还是不知道<code>CatsController</code>存在，也不会创建相应的实例。</p>
<p>Controllers总是属于一个模块，这就是为什么<code>@Module()</code>装饰器包含<code>controllers</code>数组。因为还没有定义其他模块，除了 root <code>AppModule</code>。</p>
<p>app.module.ts</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsController &#125; <span class="keyword">from</span> <span class="string">'./cats/cats.controller'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  controllers: [CatsController],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Providers"><a href="#Providers" class="headerlink" title="Providers"></a>Providers</h2><p>Providers 是 Nest中一个基础的概念。许多基础的Nest Classes作为 provider——services,repositories,factories,helpers等等。provider的主要特征是可以注入依赖，意味这对象能够和其他对象创建各种关系。</p>
<p>一个provider能够通过<code>@Injectable()</code>来注解</p>
<p><img src="/images/nestjs/Components_1.png" alt="Components_1"></p>
<p>Controllers用于处理HTTP请求，更复杂的任务委派给 providers。providers是一个纯JavaScript Class。</p>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>创建一个简单的<code>CatsService</code>，这个service用于数据存储和检索，设计给<code>CatsController</code>使用，所以适合被定义为一个provider。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nest g service cats</span></span><br></pre></td></tr></table></figure>
<p>使用上面的命令生成：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Cat &#125; <span class="keyword">from</span> <span class="string">'./interfaces/cat.interface'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CatsService &#123;</span><br><span class="line">  <span class="keyword">private</span> readonly cats: Cat[] = [];</span><br><span class="line"></span><br><span class="line">  create(cat: Cat) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cats.push(cat);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  findAll(): Cat[] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cats;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@Injectable()</code>装饰器对<code>CatsService</code>增加了一些元数据，这些元数据告诉Nest这个类是一个 Nest Provider。</p>
<p>修改<code>CatsController</code>，使用service来检索数据</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Controller, Get, Post, Body &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CreateCatDto &#125; <span class="keyword">from</span> <span class="string">'./dto/create-cat.dto'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsService &#125; <span class="keyword">from</span> <span class="string">'./cats.service'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Cat &#125; <span class="keyword">from</span> <span class="string">'./interfaces/cat.interface'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">'cats'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CatsController &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> catsService: CatsService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Post</span>()</span><br><span class="line">  <span class="keyword">async</span> create(<span class="meta">@Body</span>() createCatDto: CreateCatDto) &#123;</span><br><span class="line">    <span class="keyword">this</span>.catsService.create(createCatDto);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Get</span>()</span><br><span class="line">  <span class="keyword">async</span> findAll(): <span class="built_in">Promise</span>&lt;Cat[]&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.catsService.findAll();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CatsService</code>通过class 构造器注入，注意private的使用。</p>
<p>这种方式允许在同一个位置立刻同时声明和初始化<code>catsService</code>成员</p>
<h3 id="Dependency-injection"><a href="#Dependency-injection" class="headerlink" title="Dependency injection"></a>Dependency injection</h3><p>Nest 使用强大的设计模式 Dependency injection。</p>
<p>We recommend reading a great article about this concept in the official <a href="https://angular.io/guide/dependency-injection" target="_blank" rel="noopener">Angular</a> documentation.</p>
<p>在Nest中，由于TypeScript的能力，很容易管理依赖，因为它们被当作Type处理。在下面的例子中，Nest通过创建返回<code>CatsService</code>实例来处理<code>catsService</code>。(在单例的情况下，如果它已经在其他地方被请求了，就会返回一个存在的实例。)这个依赖传入到controllers的构造器中。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> catsService: CatsService</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3><p>Provider也有声明周期，和应用的生命周期同步，当应用启动，每个依赖必须被处理，然后每个provider必须被实例化，相似的，当应用关闭了，每个provider将被销毁。然而，也有方法可以让provider生命周期在<strong>request-scoped</strong>。</p>
<p><a href="https://docs.nestjs.com/fundamentals/injection-scopes" target="_blank" rel="noopener">https://docs.nestjs.com/fundamentals/injection-scopes</a></p>
<h3 id="Custom-providers"><a href="#Custom-providers" class="headerlink" title="Custom providers"></a>Custom providers</h3><p>Nest拥有内置的Ioc(inversion of control)来处理providers之间的关系。这个特性依赖上面的依赖注入特性，事实上，比我们描述的更加强大。<code>@Injectable()</code>装饰器只是冰山一角，它也不是唯一的定义provider的方式。事实上，可以使用纯数值，类，其他的同步异步的工厂来生成。</p>
<p><a href="https://docs.nestjs.com/fundamentals/dependency-injection" target="_blank" rel="noopener">https://docs.nestjs.com/fundamentals/dependency-injection</a></p>
<h3 id="Optional-providers"><a href="#Optional-providers" class="headerlink" title="Optional providers"></a>Optional providers</h3><p>偶尔，有些dependencies不必须要处理。例如，某些class依赖一个<strong>configuration object</strong>，但当传入的是none，默认的值应该被使用。</p>
<p>在这样的例子中，这样的依赖变得可选的。因为失去配置provider并不会导致错误。</p>
<p>为了表明provider是可选的，需要使用<code>@Optional()</code>在构造器的参数上。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable, Optional, Inject &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> HttpService&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="meta">@Optional</span>() <span class="meta">@Inject</span>(<span class="string">'HTTP_OPTIONS'</span>) <span class="keyword">private</span> httpClient: T</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中使用了自定义provider的原因是使用了<code>HTTP_OPTION</code>自定义符号。</p>
<p><a href="https://docs.nestjs.com/fundamentals/custom-providers" target="_blank" rel="noopener">https://docs.nestjs.com/fundamentals/custom-providers</a></p>
<h3 id="Property-based-injection"><a href="#Property-based-injection" class="headerlink" title="Property-based injection"></a>Property-based injection</h3><p>上面以及使用的技术是基于构造器的注入，通过构造器方法注入provider。</p>
<p>在一些特殊情况下，基于属性的注入也许是有用的。</p>
<p>例如，如果你的顶层类依赖一个或多个provider。在构造器中子类中通过使用<code>super()</code>来获得它们是非常麻烦的。为了避免这些，可以在属性上使用<code>@Inject()</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable, Inject &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> HttpService&lt;T&gt; &#123;</span><br><span class="line">  <span class="meta">@Inject</span>(<span class="string">'HTTP_OPTIONS'</span>)</span><br><span class="line">  <span class="keyword">private</span> readonly httpClient: T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果你的类没有扩展其他的provider，最好使用基于构造器的注入。</p>
<h3 id="Provider-registration"><a href="#Provider-registration" class="headerlink" title="Provider registration"></a>Provider registration</h3><p>现在已经定义了一个provider(<code>CatService</code>)，以及使用者<code>CatsController</code>。我们需要注册这个service到Nest中去，这样才能实现注入。这就需要编辑<code>app.module.ts</code>，增加service到<code>@Module()</code>中的<code>providers</code>数组中去。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsController &#125; <span class="keyword">from</span> <span class="string">'./cats/cats.controller'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsService &#125; <span class="keyword">from</span> <span class="string">'./cats/cats.service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  controllers: [CatsController],</span><br><span class="line">  providers: [CatsService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Manual-instantiation"><a href="#Manual-instantiation" class="headerlink" title="Manual instantiation"></a>Manual instantiation</h3><p>Thus far, we’ve discussed how Nest automatically handles most of the details of resolving dependencies. In certain circumstances, you may need to step outside of the built-in Dependency Injection system and manually retrieve or instantiate providers. We briefly discuss two such topics below.</p>
<p>To get existing instances, or instantiate providers dynamically, you can use <a href="https://docs.nestjs.com/fundamentals/module-ref" target="_blank" rel="noopener">Module reference</a>.</p>
<p>To get providers within the <code>bootstrap()</code> function (for example for standalone applications without controllers, or to utilize a configuration service during bootstrapping) see <a href="https://docs.nestjs.com/standalone-applications" target="_blank" rel="noopener">Standalone applications</a>.</p>
<h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><p>module是一个使用了<code>@Module()</code>装饰器的类，<code>@Module()</code>提供元数据使得Nest组织应用架构。</p>
<p><img src="/images/nestjs/Modules_1.png" alt="Modules_1"></p>
<p>每个应用至少有一个module，即<strong>root module</strong>。root module是Nest的起点用于构建 <strong>application graph</strong>——内部的数据结构用于处理module和provider关系和依赖。理论上，非常小的应用只有root module。modules强力推荐的用于组织应用的方式。</p>
<p><code>@Module()</code>有以下属性，用于描述这个module:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>providers</td>
<td>将会被实例化的provider,在这个module共享使用</td>
</tr>
<tr>
<td>controllers</td>
<td>在这个模块内定义controllers，必须被实例化</td>
</tr>
<tr>
<td>imports</td>
<td>导出该模块所需的提供程序的导入模块的列表</td>
</tr>
<tr>
<td>exports</td>
<td>当前module提供给其他模块导入使用的providers子集</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Feature-modules"><a href="#Feature-modules" class="headerlink" title="Feature modules"></a>Feature modules</h3><p><code>CatsController</code>和<code>catsService</code>紧密关联，将它们移入到一个 feature module中是有意义的，feature module 组织相关的代码。</p>
<p>创建<code>CatModule</code></p>
<p>cats.module.ts</p>
<p>运行命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">nest g module cats</span></span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsController &#125; <span class="keyword">from</span> <span class="string">'./cats.controller'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsService &#125; <span class="keyword">from</span> <span class="string">'./cats.service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">    controllers: [CatsController],</span><br><span class="line">    providers: [CatsService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CatsModule &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上面，在<code>cats.module.ts</code>中定义了<code>CatsModule</code>，将所有相关的模块移入<code>cats</code>文件夹。最后需要做的是导入这个module到root module中(<code>AppModule in app.module.ts file</code>)。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsModule &#125; <span class="keyword">from</span> <span class="string">'./cats/cats.module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  imports: [CatsModule],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Shared-modules"><a href="#Shared-modules" class="headerlink" title="Shared modules"></a>Shared modules</h3><p>Nest中，module默认是单例的，然而可以在多个modules中共享同一个provider实例。</p>
<p><img src="/images/nestjs/Shared_Module_1.png" alt="Shared_Module_1"></p>
<p>每个module自动是一个 shared module。一旦被创建，它就可以被任何modul重用。假如我们想要分享<code>CatsService</code>给其他模块。为了实现这个，首先需要export <code>CatsService</code>，通过增加它到module的<code>exports</code>数组中。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsController &#125; <span class="keyword">from</span> <span class="string">'./cats.controller'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsService &#125; <span class="keyword">from</span> <span class="string">'./cats.service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  controllers: [CatsController],</span><br><span class="line">  providers: [CatsService],</span><br><span class="line">  exports: [CatsService]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CatsModule &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>现在，任何modue能够导入<code>CatsModule</code>来获得<code>CatsService</code>。</p>
<h3 id="Module-re-exporting"><a href="#Module-re-exporting" class="headerlink" title="Module re-exporting"></a>Module re-exporting</h3><p>正如上面，Modules能够导入它们内部的providers。此外，它们能re-export 它们导入的模块。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  imports: [CommonModule],</span><br><span class="line">  exports: [CommonModule],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CoreModule &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Dependency-injection-1"><a href="#Dependency-injection-1" class="headerlink" title="Dependency injection"></a>Dependency injection</h3><p>module类也能够注入providers。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsController &#125; <span class="keyword">from</span> <span class="string">'./cats.controller'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsService &#125; <span class="keyword">from</span> <span class="string">'./cats.service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  controllers: [CatsController],</span><br><span class="line">  providers: [CatsService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CatsModule &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> catsService: CatsService</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：模板本身不能像providers被注入<a href="https://docs.nestjs.com/fundamentals/circular-dependency" target="_blank" rel="noopener">https://docs.nestjs.com/fundamentals/circular-dependency</a></p>
<h3 id="Global-modules"><a href="#Global-modules" class="headerlink" title="Global modules"></a>Global modules</h3><p>如果，你必须在任何地方导入同样的module集合，它将会非常繁琐。和Nest不一样，Angular provider能够注册到全局范围。一旦定义，它们能够在任何地方获得。然而，Nest将provider封装在module scope内，当没有导入到当前module中，无法使用这个模块的provider。</p>
<p>当你想要提供一系列能够在任何地方获得的providers,(e.g. helpers, database connections, etc.)。我们可以使用<code>@Global()</code>实现module global。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module, Global &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsController &#125; <span class="keyword">from</span> <span class="string">'./cats.controller'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsService &#125; <span class="keyword">from</span> <span class="string">'./cats.service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Global</span>()</span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  controllers: [CatsController],</span><br><span class="line">  providers: [CatsService],</span><br><span class="line">  exports: [CatsService],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> CatsModule &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子中，<code>CatsService</code> provider 将会无处不在，module希望注入service，而不需要在imports 数组中导入<code>CatsModule</code>。</p>
<h3 id="Dynamic-modules"><a href="#Dynamic-modules" class="headerlink" title="Dynamic modules"></a>Dynamic modules</h3><p>动态模块能够让我们创建自定义的modules，这些模块能够动态注册和配置providers。<a href="https://docs.nestjs.com/fundamentals/dynamic-modules" target="_blank" rel="noopener">https://docs.nestjs.com/fundamentals/dynamic-modules</a></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module, DynamicModule &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createDatabaseProviders &#125; <span class="keyword">from</span> <span class="string">'./database.providers'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Connection &#125; <span class="keyword">from</span> <span class="string">'./connection.provider'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  providers: [Connection],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> DatabaseModule &#123;</span><br><span class="line">  <span class="keyword">static</span> forRoot(entities = [], options?): DynamicModule &#123;</span><br><span class="line">    <span class="keyword">const</span> providers = createDatabaseProviders(options, entities);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="keyword">module</span>: DatabaseModule,</span><br><span class="line">      providers: providers,</span><br><span class="line">      exports: providers,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>forRoot()</code>method返回一个动态模块</p>
<p>如果想在全局范围注册一个动态模块，设置<code>global</code>属性为<code>true</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  global: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">module</span>: DatabaseModule,</span><br><span class="line">  providers: providers,</span><br><span class="line">  exports: providers,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DatabasesModule</code>能够以下面的方式导入和配置：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DatabaseModule &#125; <span class="keyword">from</span> <span class="string">'./database/database.module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; User &#125; <span class="keyword">from</span> <span class="string">'./users/entities/user.entity'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  imports: [DatabaseModule.forRoot([User])],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要re-export动态模块，可以在exports数组中忽略<code>forRoot()</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; DatabaseModule &#125; <span class="keyword">from</span> <span class="string">'./database/database.module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; User &#125; <span class="keyword">from</span> <span class="string">'./users/entities/user.entity'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  imports: [DatabaseModule.forRoot([User])],</span><br><span class="line">  exports: [DatabaseModule],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Middleware"><a href="#Middleware" class="headerlink" title="Middleware"></a>Middleware</h2><p>中间件是一个在route handler之前执行的函数。中间件能够获得请求和响应对象，以及在应用的请求-响应环中的<code>next()</code>中间件函数。The next function通常被记作名为<code>next</code>的变量名。</p>
<p><img src="/images/nestjs/Middlewares_1.png" alt="Middlewares_1"></p>
<p>Nest middleware默认和express middleware是一样的。下面是来源express docment中描述middleware的能力：</p>
<blockquote>
<p>Middleware functions can perform the following tasks:</p>
<ul>
<li>execute any code.</li>
<li>make changes to the request and the response objects.</li>
<li>end the request-response cycle.</li>
<li>call the next middleware function in the stack.</li>
<li>if the current middleware function does not end the request-response cycle, it must call <code>next()</code> to pass control to the next middleware function. Otherwise, the request will be left hanging.</li>
</ul>
</blockquote>
<p>可以通过<code>@Injectable()</code>的class或函数实现中间件。class应当implement <code>NestMiddleware</code>接口。函数没有任何特殊要求。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Injectable, NestMiddleware &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Request, Response &#125; <span class="keyword">from</span> <span class="string">'express'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> LoggerMiddleware <span class="keyword">implements</span> NestMiddleware &#123;</span><br><span class="line">  use(req: Request, res: Response, next: <span class="built_in">Function</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Request...'</span>);</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Dependency-injection-2"><a href="#Dependency-injection-2" class="headerlink" title="Dependency injection"></a>Dependency injection</h3><p>Nest middleware完全支持依赖注入，和providers和controllers一样，能够在同一个module中注入可获得的依赖。通常，通过构造器注入。</p>
<h3 id="Applying-middleware"><a href="#Applying-middleware" class="headerlink" title="Applying middleware"></a>Applying middleware</h3><p>在<code>@Module()</code>没有地方配置middleware。通过使用module class的<code>configure()</code>方法来设置。包含middleware的module必须实现<code>NestModule</code>接口。</p>
<p>下面将在<code>AppModule</code>中设置<code>LoggerMiddleware</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module, NestModule, MiddlewareConsumer &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; LoggerMiddleware &#125; <span class="keyword">from</span> <span class="string">'./common/middleware/logger.middleware'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsModule &#125; <span class="keyword">from</span> <span class="string">'./cats/cats.module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  imports: [CatsModule],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule <span class="keyword">implements</span> NestModule &#123;</span><br><span class="line">  configure(consumer: MiddlewareConsumer) &#123;</span><br><span class="line">    consumer</span><br><span class="line">      .apply(LoggerMiddleware)</span><br><span class="line">      .forRoutes(<span class="string">'cats'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module, NestModule, RequestMethod, MiddlewareConsumer &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; LoggerMiddleware &#125; <span class="keyword">from</span> <span class="string">'./common/middleware/logger.middleware'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsModule &#125; <span class="keyword">from</span> <span class="string">'./cats/cats.module'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  imports: [CatsModule],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule <span class="keyword">implements</span> NestModule &#123;</span><br><span class="line">  configure(consumer: MiddlewareConsumer) &#123;</span><br><span class="line">    consumer</span><br><span class="line">      .apply(LoggerMiddleware)</span><br><span class="line">      .forRoutes(&#123; path: <span class="string">'cats'</span>, method: RequestMethod.GET &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的<code>configure()</code>方法能够使用<code>async/await</code>异步化。</p>
<h3 id="Route-wildcards"><a href="#Route-wildcards" class="headerlink" title="Route wildcards"></a>Route wildcards</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">forRoutes(&#123; path: <span class="string">'ab*cd'</span>, method: RequestMethod.ALL &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Middleware-consumeer"><a href="#Middleware-consumeer" class="headerlink" title="Middleware consumeer"></a>Middleware consumeer</h3><p>MiddlewareConsumer是一个帮助类，它提供了几个内置的方法来管理middleware。它们能够以流式风格连起来。<code>forRoutes()</code>能够输入一个单个字符串、多个字符串、<code>RouteInfo</code>对象，controller class 甚至多个controller classes。</p>
<p>大多数情况，可以传入一个controllers列表，使用都好分开。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Module, NestModule, MiddlewareConsumer &#125; <span class="keyword">from</span> <span class="string">'@nestjs/common'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; LoggerMiddleware &#125; <span class="keyword">from</span> <span class="string">'./common/middleware/logger.middleware'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsModule &#125; <span class="keyword">from</span> <span class="string">'./cats/cats.module'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; CatsController &#125; <span class="keyword">from</span> <span class="string">'./cats/cats.controller.ts'</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  imports: [CatsModule],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> AppModule <span class="keyword">implements</span> NestModule &#123;</span><br><span class="line">  configure(consumer: MiddlewareConsumer) &#123;</span><br><span class="line">    consumer</span><br><span class="line">      .apply(LoggerMiddleware)</span><br><span class="line">      .forRoutes(CatsController);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：<code>apply()</code>可以输入单个middleware或多个参数来指定多个middlewares。</p>
<p><a href="https://docs.nestjs.com/middleware#multiple-middleware" target="_blank" rel="noopener">https://docs.nestjs.com/middleware#multiple-middleware</a></p>
<h3 id="Excluding-routes"><a href="#Excluding-routes" class="headerlink" title="Excluding routes"></a>Excluding routes</h3><p>有时需要排除确定的routes。我们可以使用<code>exclude()</code>实现，This method can take a single string, multiple strings, or a <code>RouteInfo</code> object identifying routes to be excluded, as shown below:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">consumer</span><br><span class="line">  .apply(LoggerMiddleware)</span><br><span class="line">  .exclude(</span><br><span class="line">    &#123; path: <span class="string">'cats'</span>, method: RequestMethod.GET &#125;,</span><br><span class="line">    &#123; path: <span class="string">'cats'</span>, method: RequestMethod.POST &#125;,</span><br><span class="line">    <span class="string">'cats/(.*)'</span>,</span><br><span class="line">  )</span><br><span class="line">  .forRoutes(CatsController);</span><br></pre></td></tr></table></figure>
<h3 id="Functional-middleware"><a href="#Functional-middleware" class="headerlink" title="Functional middleware"></a>Functional middleware</h3><p>上面使用的<code>LoggerMiddleware</code>是非常简单的，它没有成员、没有额外的方法和依赖。我们可以把它定义为一个简单的函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">logger</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Request...`</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">consumer</span><br><span class="line">  .apply(logger)</span><br><span class="line">  .forRoutes(CatsController);</span><br></pre></td></tr></table></figure>
<h3 id="Multiple-middleware"><a href="#Multiple-middleware" class="headerlink" title="Multiple middleware"></a>Multiple middleware</h3><p>为了绑定多个middleware，它们按照顺序执行。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">consumer.apply(cors(), helmet(), logger).forRoutes(CatsController);</span><br></pre></td></tr></table></figure>
<h3 id="Globle-middleware"><a href="#Globle-middleware" class="headerlink" title="Globle middleware"></a>Globle middleware</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">await</span> NestFactory.create(AppModule);</span><br><span class="line">app.use(logger);</span><br><span class="line"><span class="keyword">await</span> app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Exception-filters"><a href="#Exception-filters" class="headerlink" title="Exception filters"></a>Exception filters</h2><h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><p>官网<a href="https://docs.nestjs.com/first-steps" target="_blank" rel="noopener">https://docs.nestjs.com/first-steps</a></p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
  </entry>
  <entry>
    <title>Nginx一般配置</title>
    <url>/2020/01/19/Nginx%E4%B8%80%E8%88%AC%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Nginx一般配置"><a href="#Nginx一般配置" class="headerlink" title="Nginx一般配置"></a>Nginx一般配置</h1><blockquote>
<p>一般后台项目配置到Nginx中</p>
</blockquote>
<a id="more"></a>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">http</span> <span class="string">&#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">##</span></span><br><span class="line">	<span class="comment"># Basic Settings</span></span><br><span class="line">	<span class="comment">##</span></span><br><span class="line">	<span class="string">sendfile</span> <span class="string">on;</span></span><br><span class="line">	<span class="string">tcp_nopush</span> <span class="string">on;</span></span><br><span class="line">	<span class="string">tcp_nodelay</span> <span class="string">on;</span></span><br><span class="line">	<span class="string">keepalive_timeout</span> <span class="number">65</span><span class="string">;</span></span><br><span class="line">	<span class="string">types_hash_max_size</span> <span class="number">2048</span><span class="string">;</span></span><br><span class="line">	<span class="comment"># server_tokens off;</span></span><br><span class="line">	<span class="comment"># server_names_hash_bucket_size 64;</span></span><br><span class="line">	<span class="comment"># server_name_in_redirect off;</span></span><br><span class="line">	<span class="string">include</span> <span class="string">/etc/nginx/mime.types;</span></span><br><span class="line">	<span class="string">default_type</span> <span class="string">application/octet-stream;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">##</span></span><br><span class="line">	<span class="comment"># SSL Settings</span></span><br><span class="line">	<span class="comment">##</span></span><br><span class="line"></span><br><span class="line">	<span class="string">ssl_protocols</span> <span class="string">TLSv1</span> <span class="string">TLSv1.1</span> <span class="string">TLSv1.2;</span> <span class="comment"># Dropping SSLv3, ref: POODLE</span></span><br><span class="line">	<span class="string">ssl_prefer_server_ciphers</span> <span class="string">on;</span></span><br><span class="line">	<span class="string">server</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="string">listen</span> <span class="number">80</span><span class="string">;</span></span><br><span class="line">        <span class="string">return</span> <span class="number">301</span> <span class="string">https://$http_host$request_uri;</span></span><br><span class="line">		<span class="string">location</span> <span class="string">/</span> <span class="string">&#123;</span></span><br><span class="line">    		<span class="string">proxy_pass</span>      <span class="string">http://127.0.0.1:8000;</span> <span class="comment"># 代理本地地址</span></span><br><span class="line">   		<span class="string">&#125;</span></span><br><span class="line">	<span class="string">&#125;</span></span><br><span class="line">    <span class="string">server</span> <span class="string">&#123;</span></span><br><span class="line">        <span class="comment"># SSL 配置</span></span><br><span class="line"> 		<span class="string">listen</span> <span class="number">443</span><span class="string">;</span></span><br><span class="line">		<span class="string">ssl</span> <span class="string">on;</span></span><br><span class="line">		<span class="string">ssl_certificate</span> <span class="string">/etc/nginx/server.crt;</span> <span class="comment">#(证书公钥)</span></span><br><span class="line">		<span class="string">ssl_certificate_key</span> <span class="string">/etc/nginx/server.key;</span> <span class="comment">#(证书私钥)</span></span><br><span class="line">		<span class="string">ssl_session_timeout</span> <span class="string">5m;</span></span><br><span class="line">		<span class="string">ssl_protocols</span>  <span class="string">SSLv2</span> <span class="string">SSLv3</span> <span class="string">TLSv1;</span></span><br><span class="line">		<span class="string">ssl_ciphers</span>  <span class="string">HIGH:!aNULL:!MD5;</span></span><br><span class="line">		<span class="string">ssl_prefer_server_ciphers</span> <span class="string">on;</span>		</span><br><span class="line"> </span><br><span class="line">		<span class="string">location</span> <span class="string">/</span> <span class="string">&#123;</span></span><br><span class="line">	    	<span class="string">proxy_pass</span>      <span class="string">http://127.0.0.1:8000;</span> <span class="comment"># tomcat服务器地址</span></span><br><span class="line">	  		<span class="comment">#  root /usr/share/nginx/html/;  # 本地静态网页路径</span></span><br><span class="line">		<span class="string">&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">    <span class="comment"># 配置 ws/wss</span></span><br><span class="line">	<span class="string">upstream</span> <span class="string">websocket</span> <span class="string">&#123;</span>  </span><br><span class="line">    	<span class="string">server</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9001;</span>  </span><br><span class="line">	<span class="string">&#125;</span>  </span><br><span class="line">	<span class="string">server</span> <span class="string">&#123;</span>  </span><br><span class="line">    	<span class="string">listen</span> <span class="number">8888</span><span class="string">;</span>  </span><br><span class="line">    	<span class="string">ssl</span> <span class="string">on;</span></span><br><span class="line">		<span class="string">ssl_certificate</span> <span class="string">/etc/nginx/server.crt;</span> <span class="comment">#(证书公钥)</span></span><br><span class="line">		<span class="string">ssl_certificate_key</span> <span class="string">/etc/nginx/server.key;</span> <span class="comment">#(证书私钥)</span></span><br><span class="line">    	<span class="string">ssl_session_timeout</span> <span class="string">20m;</span></span><br><span class="line">   	 	<span class="string">ssl_verify_client</span> <span class="string">off;</span></span><br><span class="line">    	<span class="string">location</span> <span class="string">/</span> <span class="string">&#123;</span></span><br><span class="line">	        <span class="string">proxy_pass</span> <span class="string">http://websocket;</span>  </span><br><span class="line">       		<span class="string">proxy_http_version</span> <span class="number">1.1</span><span class="string">;</span>  </span><br><span class="line">        	<span class="string">proxy_set_header</span> <span class="string">Connection</span> <span class="string">"Upgrade"</span><span class="string">;</span>  </span><br><span class="line">    	<span class="string">&#125;</span>  </span><br><span class="line">	<span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技能</category>
      </categories>
  </entry>
  <entry>
    <title>Neural-Network-Primer</title>
    <url>/2020/03/05/Neural-Network-Primer/</url>
    <content><![CDATA[<h1 id="神经网络基础"><a href="#神经网络基础" class="headerlink" title="神经网络基础"></a>神经网络基础</h1><p><strong>NLP:</strong> the Yoav Goldberg’s, 2016 <a href="https://www.jair.org/media/4992/live-4992-9623-jair.pdf" target="_blank" rel="noopener">A Primer on Neural Network Models for Natural Language Processing </a> 2016 a Primer on Neural Network Models for Natural Language Processing</p>
<p>具有梯度下降的<code>RNN</code>入门</p>
<ul>
<li><a href="https://www.youtube.com/embed/aircAruvnKk" target="_blank" rel="noopener">https://www.youtube.com/embed/aircAruvnKk</a></li>
<li><a href="https://www.youtube.com/embed/IHZwWFHWa-w" target="_blank" rel="noopener">https://www.youtube.com/embed/IHZwWFHWa-w</a></li>
<li><a href="https://www.youtube.com/embed/Ilg3gGewQ5U" target="_blank" rel="noopener">https://www.youtube.com/embed/Ilg3gGewQ5U</a></li>
<li><a href="https://www.youtube.com/embed/tIeHLnjs5U8" target="_blank" rel="noopener">https://www.youtube.com/embed/tIeHLnjs5U8</a></li>
<li><a href="https://www.youtube.com/embed/ILsA4nyG7I0" target="_blank" rel="noopener">https://www.youtube.com/embed/ILsA4nyG7I0</a></li>
</ul>
<p>CNN：Convolutional Neural Networks</p>
<ul>
<li><a href="https://www.youtube.com/embed/FmpDIaiMIeA" target="_blank" rel="noopener">https://www.youtube.com/embed/FmpDIaiMIeA</a></li>
</ul>
<h2 id="激活函数-Activation-Functions"><a href="#激活函数-Activation-Functions" class="headerlink" title="激活函数 Activation Functions"></a>激活函数 Activation Functions</h2><p>激活函数由两种类型：饱和和非饱和。</p>
<p>饱和意味这这个函数会挤压输入</p>
<ul>
<li><p>$f$是不饱和的 </p>
<script type="math/tex; mode=display">\Leftrightarrow\; (|\lim_{z\rightarrow - \infty} f(z)|= +\rightarrow) \lor (|\lim_{z\rightarrow + \infty} f(z)|= +\infty)</script></li>
<li><p>并且如果$f$不是不饱和的那他就是饱和的</p>
</li>
</ul>
<h2 id="RNN-和-Feedforward-Neural-Nets（FNN）"><a href="#RNN-和-Feedforward-Neural-Nets（FNN）" class="headerlink" title="RNN 和　Feedforward Neural Nets（FNN）"></a>RNN 和　Feedforward Neural Nets（FNN）</h2><p><code>RNN</code>通过增加了对过去事件的内部表示在<code>FNN</code>的基础上得到了很大的改善。由于<code>RNN</code>能够很好的处理序列任务，因此以<code>RNN</code>为基础的深度学习在<code>seq2seq</code>上是非常成功的。应该注意到的是<code>RNN</code>是图灵完全的，并且有能够模拟任何程序的能力。</p>
<blockquote>
<p>如果说训练普通的神经网络是在优化误差函数，那么训练循环神经网络就是在优化程序。</p>
</blockquote>
<p><code>RNN</code>因此也可以学习任何可测量的<code>s2s</code>映射到任意精度。所以，能够在手写识别，文本生成和语言模型上得到很好的结果。<code>RNN</code>中，过去事件的信息的可用性非常重要。当缺少输出序列长度的预先知识的情况下，问题就产生了。因为训练目标必须和输入对齐，而标准的<code>RNN</code>只是简单的将输入映射到输出。此外，它还没有将过去输出的信息考虑在内。一种解决方式是使用两个<code>RNN</code>进行结构的预测：第一个建模输入输出依赖（转录）和第二个建模输出-输出依赖（预测）。这种方式每个输出依赖全部的输入序列和前面所有的输出。</p>
<p><code>RNN</code>的另一个限制是内部状态的大小。可以从<code>Neural Machine Translation NMT</code>的<code>encoder-decoder</code>架构中看到这一点。这里的encoder当更新内部状态的时候逐word的获取全部的输入序列。而decoder将它decode成其他语言。</p>
<h2 id="Encoder-Decoder-Scheme"><a href="#Encoder-Decoder-Scheme" class="headerlink" title="　Encoder-Decoder Scheme"></a>　Encoder-Decoder Scheme</h2><p><code>Seq2Seq modeling</code> 等价与 基于<code>encoder-decoder</code>架构的<code>RNN</code>。下面图将这种方式展开成$M$个<code>encoder steps</code> 和 $N$ 个 <code>decoder steps</code>，和隐藏状态 <code>h</code></p>
<p><img src="/images/Neural_Network_Primer/EncoderDecoder_MC.png" alt="EncoderDecoder_MC"></p>
<center>图1：Encoder-Decoder 架构：encoder将输入句子转换成一个 “meaning”向量，这个向量输入到decoder来生成一个翻译</center>

<ul>
<li>encoder - 将输入数据 $x$ 映射到一个不同的表示（低维的，压缩的）。</li>
<li><p><code>decoder</code> - 将<code>encoder</code>输出的新的特征表示映射成作为输出序列$y$的输入数据空间，一次从左到右一个，<code>decoder</code>通过计算新的隐藏状态生成 $y_{i+1}$字符。隐藏状态根据前面的隐藏状态$h_i$和前一个目标语言<code>word</code> $y_i$的嵌入生成。</p>
</li>
<li><p>条件输入成$c_i$来源<code>encoder</code>的输出$z$</p>
<script type="math/tex; mode=display">
input: (x_1,\cdots,x_m) \rightarrow_{maps}^{encoder} z = (z_1,\cdots,z_m) \rightarrow_{generates}^{decoder} output: (y_1,\cdots,y_n)</script></li>
</ul>
<p>我们考虑成两种类型的模型，有或者没有attention，后面假设$\forall ic_i = z_m$(<a href="https://arxiv.org/abs/1406.1078" target="_blank" rel="noopener">Cho et al., 2014 </a>)</p>
<p>此外，<code>encoder</code>的状态$h_m^E$作为一个压缩和固定长度的向量存在一个问题，它必须包含了输入句子的全部信息。但是这里它失去了一些信息。可以尝试使用一些启发式的方法来克服这个问题和改善<code>RNN</code>的性能</p>
<ul>
<li>Organize input : 多次输入 或 提供 逆向的序列作为输入</li>
<li>Provide more memory： 提供更长的记忆能力，结果表示记忆越大，<code>RNN</code>在各种任务上的性能越好。</li>
</ul>
<p>因此，为了避免记忆的问题，产生了对Attention的研究。</p>
<h2 id="Attention-Basis"><a href="#Attention-Basis" class="headerlink" title="Attention Basis"></a>Attention Basis</h2><p>Attention最直观的定义是来自<a href="https://mchromiak.github.io/articles/2017/Sep/12/Transformer-Attention-is-all-you-need/" target="_blank" rel="noopener">paper about Transformer architecture</a></p>
<blockquote>
<p>An attention function can be described as mapping a query and a set of key-value pairs to an output, where the query, keys, values, and output are all vectors. The output is computed as a weighted sum of the values, where the weight assigned to each value is computed by a compatibility function of the query with the corresponding key.</p>
</blockquote>
<p>能够通过下面的定义：</p>
<script type="math/tex; mode=display">
\begin{eqnarray} A(q, \{(k,v)\} ) \xrightarrow[\text{output}]{\text{maps as}} \sum_{i=1}^k{\overbrace{f_c(q,k_i)}^{\theta_i}}v_i, q \in Q, k \in K, v \in V \end{eqnarray}</script><script type="math/tex; mode=display">
Q,K,V-vecto\; space,f_c -compatibility\;function</script><p>具体的说，Attention mechanism 是输入状态的权重的分布。它接收任意数量的输入 $x_1,\cdots,x_k$，和<code>query</code> $q$，然后为每个输出产生权重$\theta_1,\cdots,\theta_k$。这就用来度量每个输入和query的相关程度。Attention mechanism的输出$out$是它的输入的加权平均</p>
<script type="math/tex; mode=display">
out = \sum_{i=1}^k \theta_ix_i</script><p>因此，使用了attention的网络，只关注输入序列的一部分，但是仍然提供输出序列。因此人民能够将它想象成一个辅助输入，以线性组合的形式提供给网络。这里的线性组合的权重由网络来控制的。</p>
<p>在长句子固定嵌入的encoder-decoder架构中带来的长期依赖的问题。（例如：在固定大小的 encoded向量$h_N^E$中，句子中的结束word依赖开始word$h_1^E$）。而且，长期以来，在<code>RNN</code>也存在这样的问题。尽管一些手段，比如反向输入输入句子和重复输入输入句子，或者<code>LSTM</code>有时改善了性能。然而，它们并不是总是有效。这是因为LSTM中的状态和梯度可能会产生梯度消失的情况。虽然被称为长时间基于但是并不是长时间工作，例如对于2000 words。</p>
<p><img src="/images/Neural_Network_Primer/WaveNet.gif" alt="WaveNet"></p>
<p><img src="/images/Neural_Network_Primer/ByteNet.png" alt="ByteNet"></p>
<center>图2：WaveNet(top; sound) and ByteNet(bottom; NLP) 架构(Image acquired from [Neural Machine Translation in Linear Time, Kalchbrenner et. al 2016 ](https://arxiv.org/abs/1610.10099))</center>

<p>这就是为什么固定编码可能成为性能瓶颈的原因。</p>
<p>Attention 被用来替换记忆和输入操作，这里的模型搜索输入句子(不是固定长度的向量)中和预测目标word相关的一部分。</p>
<p><img src="/images/Neural_Network_Primer/attention.png" alt="attention"></p>
<center>图3：Attention架构</center>

<p>在这个例子中，$\theta_{1,2}$越大，decoder相对其他的words，更加关注$y_3$第三个输出word。所有的权重被归一化总和为1。</p>
<p><img src="/images/Neural_Network_Primer/EncDecAttention.gif" alt="EncDecAttention"></p>
<center>图4：Attention；蓝色链接的透明度表示decoder对encoded word的注意力大小，透明度越少，关注越高。</center>

<p>在法译英中可以可视化在一个$\theta \;matrix$中</p>
<p><img src="/images/Neural_Network_Primer/attentionmatrix.png" alt="attentionmatrix"></p>
<center>图5：注意力矩阵，Adopted form [Bahdanu et al., 2016 ](https://arxiv.org/abs/1409.0473))</center>

<p>在法语输入句子中，“ la zone”这两个词在翻译成英语“ Area”时尤其需要注意。</p>
<p>大小为$InputSize \times OutputSize$的矩阵通过计算每个输出字符对每个输入字符的注意力数值来填充。行表示<code>Input</code>，列表示<code>Output</code>。对于长句子，它可能会快速的增长。这种方法需要对输入输出元素进行完整的查找，实际上它并不像生物的注意力那样有效。从直觉上看，不应该注意到不相关的对象。因此注意力应该是一种简单的记忆，对decoder产生每一个输出元素是有用的。它不需要对整个输入设置一个固定长度的编码向量。权重只是决定从encoder的输入记忆中获取哪一个符号。这种注意力是端到端记忆网络的进一步发展的主体。在端到端网络中，循环的注意力被使用每个输出符号执行多个计算步骤。这包括在每一步生成输出和改变记忆内容前，多次读取相同的序列。</p>
<p>通过反向传播来定义 <code>end-to-end</code>学习模型的权重。</p>
<h2 id="Layer-connections"><a href="#Layer-connections" class="headerlink" title="Layer connections"></a>Layer connections</h2><p>在DL架构中，梯度消失是常见的问题，因此，提出了一些方法来减轻对网络效率的影响。</p>
<h3 id="Highway-layers"><a href="#Highway-layers" class="headerlink" title="Highway layers"></a>Highway layers</h3><h3 id="Residual-connection-残差连接"><a href="#Residual-connection-残差连接" class="headerlink" title="Residual connection 残差连接"></a>Residual connection 残差连接</h3><p>具有多层结构的模型通常使用<code>shortcut</code> 或 <code>residual connections</code>。这个技巧成为了 <a href="https://arxiv.org/abs/1512.03385" target="_blank" rel="noopener">He et al. 2016 CVPR </a>赢得了<code>ImageNet 2016</code>的主要因素。残差连接是层之间的连接，通过<code>short-cut connection</code> 将当前层的输入$x$连接到它的输出上。</p>
<script type="math/tex; mode=display">
h=f(Wx+b)+\mathbf{x}</script><p>残差连接有助于解决梯度消失问题，因为即使layer的非线性函数$f$没有输出结果，$\mathbf{x}$形式的单位函数成为了输出</p>
<h3 id="Dense-connection"><a href="#Dense-connection" class="headerlink" title="Dense connection"></a>Dense connection</h3><h2 id="Position-Embeddings"><a href="#Position-Embeddings" class="headerlink" title="Position Embeddings"></a>Position Embeddings</h2><p>通常被用在非循环的网络中 （CNN），这种网络和循环网络不同，需要通过某种方式来保存序列输入符号的顺序。RNN通过循环的隐藏状态计算来学习序列中的位置。</p>
<h2 id="Auto-regressive-自回归-（AR"><a href="#Auto-regressive-自回归-（AR" class="headerlink" title="Auto-regressive 自回归 （AR)"></a>Auto-regressive 自回归 （AR)</h2><p>自回归问题是未来观测分布的条件均值。在自回归模型中，我们使用变量的过去值的线性组合来预测感兴趣的变量。这个术语<code>autoregression</code>表明它是对变量自身的回归。在神经网络中，每个单元同时接收来自前一层和同一层内的前一层的输入时所理解的自回归。</p>
<h2 id="End-to-End-learning-training"><a href="#End-to-End-learning-training" class="headerlink" title="End-to-End learning/training"></a>End-to-End learning/training</h2><p>训练一个模型最简单的方式就是在一端放入input，另一端获得output。神经网络的端到端学习仅仅以为了基于输入输出单一模型的网络权值优化。</p>
<p>在某些情况下，一个模型不足以得到预期的输出。这就需要一个相互独立的训练模型组成管道。在大多数情况下，输入和输出是两个不同的范围。另一种情况是神经网络需要很多层才能拟合记忆。因此，它需要将一个大的神经网络划分成较小的神经网络组成的管道。另外要注意的是，这种分解技术不一定是有效的，因为这种方法将中间的输出在局部进行了优化。</p>
<p>例子</p>
<ul>
<li>当训练机器人根据视觉来移动，一个模型可以用来对视觉输入（原始像素）的表示进行预处理，然后将处理的结果作为另一个模型的输入，这个模型负责决定机器人移动哪条腿。</li>
<li>图像字幕，将原始的图像像素信息转换成文本描述图片</li>
<li>语音识别，将语音转化成文本。</li>
</ul>
<h2 id="Hyper-parameters-meta-parameters-free-parameters"><a href="#Hyper-parameters-meta-parameters-free-parameters" class="headerlink" title="Hyper parameters (meta-parameters, free-parameters)"></a>Hyper parameters (meta-parameters, free-parameters)</h2><p>机器学习的关键是找到一个数学公式(模型)，其中的参数最适合数据。然而，训练不能直接从数据中发现模型高层次的属性，比如模型的<strong>复杂性</strong>和<strong>学习速度</strong>。这些属性也被叫做<strong>超参数</strong>。对于每个训练的模型的超参数都是在训练过程开始前预先定义的。超参数的值是重要的，但是需要额外的工作来决定。这些工作通过尝试不同的超参数值和训练不同的模型来完成。使用测试来比较，决定哪些超参数值应该被选择。比如最快的得到结果，需要较少的步骤。因此，可以通过模型选中间接地从数据中确定超参数。</p>
<p>解决机器学习问题的四个方式</p>
<ul>
<li>模型类型：比如FNN、RNN、SVN等等</li>
<li>体系架构：例如，对于RNN，可以选中隐藏层的数量，每个隐含层的单位大小</li>
<li>训练参数：例如，决定学习率，批处理大小</li>
<li>模型参数：模型训练来找到模型参数，比如神经网络中的权重和偏差。因此，超参数被认为是训练参数和体系架构中的步骤</li>
</ul>
<p>超参数的例子</p>
<p>梯度算法中的学习率，隐藏层的数量，k-means中的簇的数量，树的深度和树的叶子节点个数，小批量梯度下降中的批处理大小，正则化参数</p>
<h2 id="Transfer-learning"><a href="#Transfer-learning" class="headerlink" title="Transfer learning"></a>Transfer learning</h2><p>迁移学习在强化学习或监督学习中使用。深度学习需要大量的数据集来提高性能（避免过拟合）。然而当面对新的任务没有足够的数据，这种问题就可能产生。这里的想法就是使用其他已经存在的大的数据集来细致的调整神经网络，来使得这个新的任务只需要少量的数据就可以使用（比如：使用从CNN(ConvNet)得到的与训练的特征能被用在SVM中）。换句话说，将学习到的表示迁移到另一个问题上。然而，我们必须避免消极的迁移，因为它也可能减缓对目标任务的训练。当有了预训练的函数$h()$来搜索函数$g()$来使用新的输入$x_i$的投影</p>
<script type="math/tex; mode=display">
(h(g(x_i)))</script><p>例子</p>
<ul>
<li>正迁移 Positvie transfer：如果你之前学习过如何从没有腐烂的蔬菜学习对腐烂的蔬菜进行分类，你可以将腐烂的表示使用到水果上，尽管你之前没有见过腐烂的水果。</li>
<li>负迁移 Negative transfer：学习一项技能使得学习第二个技能更加困难。如果一个跆拳道运动知道如何训练拳击，可能很难理解什么是拳击。</li>
<li>主动迁移 Proactive transfer：当过去学习的模型影响到要学习的新模型</li>
<li>回溯迁移 Retroactive transfer：当一个新的模型影响到之前学习的模型</li>
<li>双向迁移 Bilateral Transfer：机器人学会了使用左机械手，但是在不同的对称性现在必须学习使用右机械手</li>
<li>零迁移 Zero transfer：两个模型是肚里的</li>
<li>刺激归纳 Stimulus generalization：知道什么是腐烂的水果并不意味这能够在生锈的金属上发现一样的。但是你可以总结得出在这两个案列上，它是不可用的。</li>
</ul>
<h2 id="Fine-tuning-微调"><a href="#Fine-tuning-微调" class="headerlink" title="Fine tuning 微调"></a>Fine tuning 微调</h2><p>微调主要在监督学习的背景下考虑。当在为一个算法选择超参数的时候，微调使用大量的机制来解决这个问题。当调整这个算法的行为，为了进一步改善性能而不是操控模型本身。当微调预训练的模型也许被认为和迁移学习等同。如果在微调的过程中使用的数据与预训练的模型使用的数据性质不同，这种情况是正确的。</p>
<p>例子</p>
<ul>
<li>找到模型的最佳超参数</li>
<li>在迁移学习中，替换固定的预训练好的模型使得模型更加灵活，更加适应新的任务。</li>
</ul>
<h2 id="Evolutionary-algorithm-（Evolutionary-Computation）"><a href="#Evolutionary-algorithm-（Evolutionary-Computation）" class="headerlink" title="Evolutionary algorithm （Evolutionary Computation）"></a>Evolutionary algorithm （Evolutionary Computation）</h2><p>机器学习问题中，以便由两个部分组成</p>
<ol>
<li>The model (function class, etc)</li>
<li>Methods of fitting the model (optimization algorithms)</li>
</ol>
<p>神经网络是一个模型：给定了结构和权重的设置，神经网络会产生一些输出。存在一些拟合神经网络的方法，比如反向传播，对比发散，等等。然而，神经网络的重点是如果每个人给你一个正确的权重，你就能很好的处理这个问题。</p>
<p>进化算法处理第二个部分—拟合模型，也就是优化。有一些和进化算法相关的经典模型：例如，进化程序通常试图优化特定类型的所有程序。然而，进化算法本质上是为一个特殊的模型找出正确参数的一种方法。通常，你以这样交叉操作方式来编写模型参数，交叉操作是一个合理的方法。能够使得进化算法改变来获取一个合理的参数设置。</p>
<p>进化算法是能够使用在机器学习中的一类策略，就像BP和其他的策略一样。</p>
<p>进化算法通常收敛非常缓慢，因为它们没有利用梯度信息。另一方面，它们提供了一个机会来避免局部最优和找到全局最优。</p>
<h2 id="Learning-rate-schemes（learning-rate-annealing-or-adaptive-learning-rates）"><a href="#Learning-rate-schemes（learning-rate-annealing-or-adaptive-learning-rates）" class="headerlink" title="　Learning rate schemes（learning rate annealing or adaptive learning rates）"></a>　Learning rate schemes（learning rate annealing or adaptive learning rates）</h2><p>随着训练改变学习率，比如SGD可以提高性能和减少训练次数。随着学习率自适应的变化，一个人可以使用不同的策略来决定学习率如何来改变。</p>
<p>See <a href="http://cs231n.github.io/neural-networks-3/#anneal" target="_blank" rel="noopener">cs231n </a> on learning rate annealing and <a href="https://www.tensorflow.org/versions/r0.12/api_docs/python/train/decaying_the_learning_rate" target="_blank" rel="noopener">Tensorflow decaying learning rate </a>.</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>安排邮筒</title>
    <url>/2020/06/14/LeetCode5421/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="　题目描述"></a>　题目描述</h2><p>给你一个房屋数组houses 和一个整数 k ，其中 houses[i] 是第 i 栋房子在一条街上的位置，现需要在这条街上安排 k 个邮筒。</p>
<p>请你返回每栋房子与离它最近的邮筒之间的距离的 最小 总和。</p>
<p>答案保证在 32 位有符号整数范围以内。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1478. 安排邮筒 https://leetcode-cn.com/problems/allocate-mailboxes/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinDistance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="keyword">int</span>[] houses, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = houses.length;</span><br><span class="line">        Arrays.sort(houses);</span><br><span class="line">        <span class="keyword">int</span>[][] rec = <span class="keyword">new</span> <span class="keyword">int</span>[n][n]; <span class="comment">// rec[i][j] 用一个邮箱最小的花费</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : rec) &#123;</span><br><span class="line">            Arrays.fill(ints, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = houses[i] + houses[j] &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = i; x &lt;= j; x++) &#123;</span><br><span class="line">                    rec[i][j] += Math.abs(houses[x] - mid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : dp) &#123;</span><br><span class="line">            Arrays.fill(ints, <span class="number">0x7fffffff</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = rec[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= Math.min(i + <span class="number">1</span>, k); j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = j - <span class="number">1</span>; x &lt;= i; x++) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[x - <span class="number">1</span>][j - <span class="number">1</span>] + rec[x][i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p>来源：力扣（LeetCode）<br>        链接：<a href="https://leetcode-cn.com/problems/allocate-mailboxes" target="_blank" rel="noopener">https://leetcode-cn.com/problems/allocate-mailboxes</a><br>        著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Self-Attention</title>
    <url>/2020/03/05/Self-Attention/</url>
    <content><![CDATA[<h1 id="Self-Attention详解"><a href="#Self-Attention详解" class="headerlink" title="　Self-Attention详解"></a>　Self-Attention详解</h1><p><a href="https://jalammar.github.io/illustrated-transformer/" target="_blank" rel="noopener">https://jalammar.github.io/illustrated-transformer/</a></p>
<p><img src="/images/Self-Attention/v2-32eb6aa9e23b79784ed1ca22d3f9abf9_720w.jpg" alt="v2-32eb6aa9e23b79784ed1ca22d3f9abf9_720w"></p>
<p>对于 Self-Attention，其中<code>Q(query),K(key),V(value)</code>三个矩阵都来源同一个输入，首先需要计算<code>Q</code>和<code>K</code>之间的点乘，然后除以一个标准尺度$\sqrt{d_k}$，它是query和key向量的维度。再试用Softmax将结果归一化为概率分布，然后在乘以矩阵$V$就得到权重和的表示，整个过程可以表示成：</p>
<script type="math/tex; mode=display">
Attention(Q,K,V) = softmax(\frac{QK^T}{\sqrt{d_k}})V</script><p><img src="/images/Self-Attention/v2-f64cbdcf1d883ede36b26067e34f4e3e_720w.jpg" alt="v2-f64cbdcf1d883ede36b26067e34f4e3e_720w"></p>
<p>假如需要翻译词组 <code>Thinking Machines</code> ，其中<code>Thinking</code>的输入嵌入向量用$x_1$表示，<code>Machines</code>的嵌入向量用$x_2$表示。</p>
<p>当处理<code>Thinking</code>这个词，需要计算句中所有词和它的Attention Score，将词作为搜索的query，和句子中所有词的key来匹配，看看相关度多高。使用$q_1$代表<code>Thinking</code>的query vector，$k_1,k_2$分别表示<code>Thinking,Machines</code>对应的key vector，计算<code>Thinking</code>的Attention Score，只需要计算$q_1$和$k_1,k_2$的点乘。同理计算<code>Machines</code>的Attention Score计算$q_2$和$k2_1,k_2$的点乘。然后再进行放缩，和softmax归一化。</p>
<p><img src="/images/Self-Attention/v2-03d0a60b60a0a28f52ed903c76bb9a22_720w.jpg" alt="v2-03d0a60b60a0a28f52ed903c76bb9a22_720w"></p>
<p>显然当前的单词与自身的Attention score 一般最大。其他单词和当前单词的重要程度有相应分数。然后再将Attention Score和value vector相乘，得到加权后的向量。</p>
<p><img src="/images/Self-Attention/v2-087b831f622f83e4529c1bbf646530f0_720w.jpg" alt="v2-087b831f622f83e4529c1bbf646530f0_720w"></p>
<p>如果将输入的所有向量合并成矩阵形式，则其中的query、key、value向量也可并称矩阵形式表示。</p>
<p><img src="/images/Self-Attention/v2-eea2dcbfa49df9fb799ef8e6997260bf_720w.jpg" alt="v2-eea2dcbfa49df9fb799ef8e6997260bf_720w"></p>
<p>其中，$W^Q,W^K,W^V$是我们模型训练过程中学习到的合适参数。</p>
<p><img src="/images/Self-Attention/v2-752c1c91e1b4dbca1b64f59a7e026b9b_720w.jpg" alt="v2-752c1c91e1b4dbca1b64f59a7e026b9b_720w"></p>
<p>Multi-head就是使用多个Q，K，V，然后将得到的多个$Z$拼接起来，在乘以矩阵$W^o$来计算出layer的输出。</p>
<p>对于encoder就是利用这些基本单元叠加，其中key，query，value来自前一层的输出，所以encoder中的每个位置都可以关注到之前一层中encoder的所有位置。</p>
<p>对于decoder，由两个和encoder不同的地方</p>
<ul>
<li>第一级的 Masked Multi-head，其中的key，query，value均来自前一层的decoder的输出，但是加入了Mask操作，即只能关注到前面已经翻译过了的输出的词语，没有的翻译的无法知道。</li>
<li>第二级的 Multi-head Attention 的输入来自前一级和encoder的输出：query来自前一级的decoder，key和value来自encoder的输出，这样decoder的每个每个位置可以关注到输入序列的情况。</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
  </entry>
  <entry>
    <title>PyTorch-Tutorial</title>
    <url>/2019/09/27/PyTorch-Tutorial/</url>
    <content><![CDATA[<h1 id="Pytorch-Tutorial"><a href="#Pytorch-Tutorial" class="headerlink" title="Pytorch Tutorial"></a>Pytorch Tutorial</h1><h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.empty(<span class="number">5</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([-7.0454e+16,  4.5602e-41, -7.0454e+16,  4.5602e-41,  4.4842e-44])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.randn(<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[-0.2868, -0.7095, -0.2244,  0.0359, -0.0446],
        [ 0.9009, -1.4887,  1.1688, -0.8644, -0.2834],
        [ 0.6291, -0.7237,  0.1425,  0.7541, -0.8514]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.zeros(<span class="number">5</span>, <span class="number">3</span>, dtype=torch.long)</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[0, 0, 0],
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0],
        [0, 0, 0]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">5.5</span>, <span class="number">3</span>])</span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([5.5000, 3.0000])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = x.new_ones(<span class="number">5</span>, <span class="number">3</span>, dtype=torch.double)</span><br><span class="line">print(x)</span><br><span class="line">x = torch.randn_like(x, dtype=torch.float)    <span class="comment"># override dtype!</span></span><br><span class="line">x</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[ 0.5359, -0.6125,  0.4776],
        [ 1.6412, -0.6522,  1.3568],
        [ 0.5305, -1.7568,  1.7467],
        [-0.2996, -0.2183, -0.9193],
        [ 1.4179, -0.1998, -0.9144]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(x.size())</span><br></pre></td></tr></table></figure>
<pre><code>torch.Size([5, 3])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = torch.randn(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">print(x + y)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[-0.7118, -0.8840,  2.0376],
        [-0.6116, -1.1469,  1.6384],
        [ 0.6491, -2.3616,  2.1900],
        [-0.7521, -1.1007, -1.9134],
        [-0.2323, -0.4377,  0.5033]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(torch.add(x, y))</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[-0.7118, -0.8840,  2.0376],
        [-0.6116, -1.1469,  1.6384],
        [ 0.6491, -2.3616,  2.1900],
        [-0.7521, -1.1007, -1.9134],
        [-0.2323, -0.4377,  0.5033]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = torch.empty(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">torch.add(x, y, out=result)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[-0.7118, -0.8840,  2.0376],
        [-0.6116, -1.1469,  1.6384],
        [ 0.6491, -2.3616,  2.1900],
        [-0.7521, -1.1007, -1.9134],
        [-0.2323, -0.4377,  0.5033]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># adds x to y</span></span><br><span class="line">y.add_(x)</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[-0.1759, -1.4965,  2.5152],
        [ 1.0296, -1.7991,  2.9952],
        [ 1.1797, -4.1185,  3.9367],
        [-1.0517, -1.3190, -2.8327],
        [ 1.1856, -0.6375, -0.4111]])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(x[:, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<pre><code>tensor([-0.6125, -0.6522, -1.7568, -0.2183, -0.1998])
</code></pre><p><strong>Resizing:</strong> If you want to resize/reshape tensor, you can use <code>torch.view</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.randn(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line">y = x.view(<span class="number">16</span>)</span><br><span class="line">z = x.view(<span class="number">-1</span>, <span class="number">8</span>)  <span class="comment"># the size -1 is inferred from other dimensions</span></span><br><span class="line">print(x.size(), y.size(), z.size())</span><br></pre></td></tr></table></figure>
<pre><code>torch.Size([4, 4]) torch.Size([16]) torch.Size([2, 8])
</code></pre><p>If you have a one element tensor, use <code>.item()</code> to get the value as a Python number</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.randn(<span class="number">1</span>)</span><br><span class="line">print(x)</span><br><span class="line">print(x.item())</span><br></pre></td></tr></table></figure>
<pre><code>tensor([-0.5195])
-0.5194937586784363
</code></pre><h2 id="Converting-a-Torch-Tensor-to-a-NumPy-Array"><a href="#Converting-a-Torch-Tensor-to-a-NumPy-Array" class="headerlink" title="Converting a Torch Tensor to a NumPy Array"></a>Converting a Torch Tensor to a NumPy Array</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.ones(<span class="number">5</span>)</span><br><span class="line">print(a)</span><br><span class="line">b = a.numpy()</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([1., 1., 1., 1., 1.])
[1. 1. 1. 1. 1.]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.add_(<span class="number">1</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([2., 2., 2., 2., 2.])
[2. 2. 2. 2. 2.]
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.ones(<span class="number">5</span>)</span><br><span class="line">b = torch.from_numpy(a)</span><br><span class="line">np.add(a, <span class="number">1</span>, out=a)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<pre><code>[2. 2. 2. 2. 2.]
tensor([2., 2., 2., 2., 2.], dtype=torch.float64)
</code></pre><h2 id="AUTOGRAD-AUTOMATIC-DIFFERENTIATION"><a href="#AUTOGRAD-AUTOMATIC-DIFFERENTIATION" class="headerlink" title="AUTOGRAD: AUTOMATIC DIFFERENTIATION"></a>AUTOGRAD: AUTOMATIC DIFFERENTIATION</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.ones(<span class="number">2</span>, <span class="number">2</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[1., 1.],
        [1., 1.]], requires_grad=True)
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = x + <span class="number">2</span></span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[3., 3.],
        [3., 3.]], grad_fn=&lt;AddBackward0&gt;)
</code></pre><p><code>y</code> was created as a result of an operation, so it has a <code>grad_fn</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(y.grad_fn)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;AddBackward0 object at 0x7f1f65224a58&gt;
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">z = y * y * <span class="number">3</span></span><br><span class="line">out = z.mean()</span><br><span class="line">print(z, out)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[27., 27.],
        [27., 27.]], grad_fn=&lt;MulBackward0&gt;) tensor(27., grad_fn=&lt;MeanBackward0&gt;)
</code></pre><p><code>.requires_grad_( ... )</code> changes an existing Tensor’s <code>requires_grad</code> flag in-place. The input flag defaults to <code>False</code> if not given.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = torch.randn(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">a = ((a * <span class="number">3</span>) / (a - <span class="number">1</span>))</span><br><span class="line">print(a.requires_grad)</span><br><span class="line">a.requires_grad_(<span class="literal">True</span>)</span><br><span class="line">print(a.requires_grad)</span><br><span class="line">b = (a * a).sum()</span><br><span class="line">print(b.grad_fn)</span><br></pre></td></tr></table></figure>
<pre><code>False
True
&lt;SumBackward0 object at 0x7f1f65a18ba8&gt;
</code></pre><p>Let’s backprop now. Because <code>out</code> contains a single scalar, <code>out.backward()</code> is equivalent to <code>out.backward(torch.tensor(1.))</code>.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">out.backward()</span><br></pre></td></tr></table></figure>
<p>Print gradients d(out)/dx</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(x.grad)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[4.5000, 4.5000],
        [4.5000, 4.5000]])
</code></pre><p>You should have got a matrix of <code>4.5</code>. Let’s call the <code>out</code> Tensor “o”. We have that $o = \frac{1}{4}\sum<em>i z_i$, $z_i = 3(x_i+2)^2$ and $z_i\bigr\rvert</em>{x<em>i=1} = 27$. Therefore, $\frac{\partial o}{\partial x_i} = \frac{3}{2}(x_i+2)$, hence $\frac{\partial o}{\partial x_i}\bigr\rvert</em>{x_i=1} = \frac{9}{2} = 4.5$.</p>
<p>Mathematically, if you have a vector valued function $\vec{y}=f(\vec{x})$, then the gradient of $\vec{y}$  with respect to $\vec{x}$  is a Jacobian matrix:</p>
<script type="math/tex; mode=display">\begin{split}J=\left(\begin{array}{ccc}
 \frac{\partial y_{1}}{\partial x_{1}} & \cdots & \frac{\partial y_{1}}{\partial x_{n}}\\
 \vdots & \ddots & \vdots\\
 \frac{\partial y_{m}}{\partial x_{1}} & \cdots & \frac{\partial y_{m}}{\partial x_{n}}
 \end{array}\right)\end{split}</script><p>Generally speaking, <code>torch.autograd</code> is an engine for computing vector-Jacobian product. That is, given any vector $v=\left(\begin{array}{cccc} v<em>{1} &amp; v</em>{2} &amp; \cdots &amp; v<em>{m}\end{array}\right)^{T}$, compute the product $v^{T}\cdot J$. If $v$ happens to be the gradient of a scalar function $l=g\left(\vec{y}\right)$, that is, $v=\left(\begin{array}{ccc}\frac{\partial l}{\partial y</em>{1}} &amp; \cdots &amp; \frac{\partial l}{\partial y_{m}}\end{array}\right)^{T}$, then by the chain rule, the vector-Jacobian product would be the gradient of $l$ with respect to $\vec{x}$ :</p>
<script type="math/tex; mode=display">\begin{split}J^{T}\cdot v=\left(\begin{array}{ccc}
 \frac{\partial y_{1}}{\partial x_{1}} & \cdots & \frac{\partial y_{m}}{\partial x_{1}}\\
 \vdots & \ddots & \vdots\\
 \frac{\partial y_{1}}{\partial x_{n}} & \cdots & \frac{\partial y_{m}}{\partial x_{n}}
 \end{array}\right)\left(\begin{array}{c}
 \frac{\partial l}{\partial y_{1}}\\
 \vdots\\
 \frac{\partial l}{\partial y_{m}}
 \end{array}\right)=\left(\begin{array}{c}
 \frac{\partial l}{\partial x_{1}}\\
 \vdots\\
 \frac{\partial l}{\partial x_{n}}
 \end{array}\right)\end{split}</script><p> (Note that $v^T⋅J$ gives a row vector which can be treated as a column vector by taking $J^T⋅v$.)</p>
<p>This characteristic of vector-Jacobian product makes it very convenient to feed external gradients into a model that has non-scalar output.</p>
<p>Now let’s take a look at an example of vector-Jacobian product:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.randn(<span class="number">3</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">y = x * <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> y.data.norm() &lt; <span class="number">1000</span>: <span class="comment"># y.data 的 2 范数</span></span><br><span class="line">    y = y * <span class="number">2</span></span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([ 243.8343, 1859.5187,  433.1491], grad_fn=&lt;MulBackward0&gt;)
</code></pre><p>Now in this case <code>y</code> is no longer a scalar. <code>torch.autograd</code> could not compute the full Jacobian directly, but if we just want the vector-Jacobian product, simply pass the vector to <code>backward</code> as argument:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v = torch.tensor([<span class="number">0.1</span>, <span class="number">1.0</span>, <span class="number">0.0001</span>], dtype=torch.float)</span><br><span class="line">y.backward(v)</span><br><span class="line">print(x.grad)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([1.0240e+02, 1.0240e+03, 1.0240e-01])
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(x.requires_grad)</span><br><span class="line">print((x ** <span class="number">2</span>).requires_grad)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    print((x ** <span class="number">2</span>).requires_grad)</span><br></pre></td></tr></table></figure>
<pre><code>True
True
False
</code></pre><h2 id="NEURAL-NETWORKS"><a href="#NEURAL-NETWORKS" class="headerlink" title="NEURAL NETWORKS"></a>NEURAL NETWORKS</h2><p>Neural networks can be constructed using the <code>torch.nn</code> package.</p>
<p>Now that you had a glimpse of <code>autograd</code>, <code>nn</code> depends on <code>autograd</code> to define models and differentiate them. An <code>nn.Module</code> contains layers, and a method <code>forward(input)</code>that returns the <code>output</code>.</p>
<p>For example, look at this network that classifies digit images:</p>
<p><img src="https://pytorch.org/tutorials/_images/mnist.png" alt="fsd"></p>
<h3 id="Define-the-network"><a href="#Define-the-network" class="headerlink" title="Define the network"></a>Define the network</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net,self).__init__()</span><br><span class="line">        <span class="comment"># 1 input image channel, 6 output channels, 3x3 square convolution</span></span><br><span class="line">        <span class="comment"># kernel</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, <span class="number">3</span>)</span><br><span class="line">        <span class="comment"># an affine operation: y = Wx + b</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">6</span> * <span class="number">6</span>, <span class="number">120</span>)  <span class="comment"># 6*6 from image dimension</span></span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>) </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># Max pooling over a (2, 2) window</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv1(x)), (<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">        <span class="comment"># If the size is a square you can only specify a single number</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv2(x)), <span class="number">2</span>)</span><br><span class="line">        x = x.view(<span class="number">-1</span>, self.num_flat_features(x))</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">num_flat_features</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        size = x.size()[<span class="number">1</span>:]  <span class="comment"># all dimensions except the batch dimension</span></span><br><span class="line">        num_features = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> size:</span><br><span class="line">            num_features *= s</span><br><span class="line">        <span class="keyword">return</span> num_features</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net = Net()</span><br><span class="line">print(net)</span><br></pre></td></tr></table></figure>
<pre><code>Net(
  (conv1): Conv2d(1, 6, kernel_size=(3, 3), stride=(1, 1))
  (conv2): Conv2d(6, 16, kernel_size=(3, 3), stride=(1, 1))
  (fc1): Linear(in_features=576, out_features=120, bias=True)
  (fc2): Linear(in_features=120, out_features=84, bias=True)
  (fc3): Linear(in_features=84, out_features=10, bias=True)
)
</code></pre><p>You just have to define the <code>forward</code> function, and the <code>backward</code> function (where gradients are computed) is automatically defined for you using <code>autograd</code>. You can use any of the Tensor operations in the <code>forward</code> function.</p>
<p>The learnable parameters of a model are returned by <code>net.parameters()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">params = list(net.parameters())</span><br><span class="line">print(len(params))</span><br><span class="line">print(params[<span class="number">0</span>].size())  <span class="comment"># conv1's .weight</span></span><br></pre></td></tr></table></figure>
<pre><code>10
torch.Size([6, 1, 3, 3])
</code></pre><p>Let try a random 32x32 input. Note: expected input size of this net (LeNet) is 32x32. To use this net on MNIST dataset, please resize the images from the dataset to 32x32.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input = torch.randn(<span class="number">1</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="number">32</span>)</span><br><span class="line">out = net(input)</span><br><span class="line">print(out)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[ 0.0251,  0.0173,  0.0737, -0.0636,  0.0445, -0.0363,  0.0201,  0.0686,
         -0.1066,  0.0272]], grad_fn=&lt;AddmmBackward&gt;)
</code></pre><p>Zero the gradient buffers of all parameters and backprops with random gradients:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net.zero_grad()</span><br><span class="line">out.backward(torch.randn(<span class="number">1</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure>
<p>For example, <code>nn.Conv2d</code> will take in a 4D Tensor of <code>nSamples x nChannels x Height x Width</code>.</p>
<p>If you have a single sample, just use <code>input.unsqueeze(0)</code> to add a fake batch dimension.</p>
<p>Recap:</p>
<ul>
<li><code>torch.Tensor</code> - A multi-dimensional array with support for autograd operations like <code>backward()</code>. Also holds the gradient w.r.t. the tensor.</li>
<li><code>nn.Module</code> - Neural network module. Convenient way of encapsulating parameters, with helpers for moving them to GPU, exporting, loading, etc.</li>
<li><code>nn.Parameter</code> - A kind of Tensor, that is automatically registered as a parameter when assigned as an attribute to a <code>Module</code>.</li>
<li><code>autograd.Function</code> - Implements forward and backward definitions of an <code>autograd</code> operation. Every <code>Tensor</code> operation creates at least a single <code>Function</code> node that connects to functions that created a <code>Tensor</code> and encodes its history.</li>
</ul>
<h3 id="Loss-Function"><a href="#Loss-Function" class="headerlink" title="Loss Function"></a>Loss Function</h3><p>A loss function takes the (output, target) pair of inputs, and computes a value that estimates how far away the output is from the target.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">output = net(input)</span><br><span class="line">target = torch.randn(<span class="number">10</span>)  <span class="comment"># a dummy target, for example</span></span><br><span class="line">target = target.view(<span class="number">1</span>, <span class="number">-1</span>)  <span class="comment"># make it the same shape as output</span></span><br><span class="line">criterion = nn.MSELoss()</span><br><span class="line">loss = criterion(output, target)</span><br><span class="line">print(loss)</span><br></pre></td></tr></table></figure>
<pre><code>tensor([[ 0.0251,  0.0173,  0.0737, -0.0636,  0.0445, -0.0363,  0.0201,  0.0686,
         -0.1066,  0.0272]], grad_fn=&lt;AddmmBackward&gt;)
tensor([[ 0.9742,  0.1312, -0.3844, -0.8399, -0.9474, -0.1069,  0.2654, -0.1648,
          0.0786, -1.5961]])
tensor(0.5499, grad_fn=&lt;MseLossBackward&gt;)
</code></pre><p>Now, if you follow <code>loss</code> in the backward direction, using its <code>.grad_fn</code> attribute, you will see a graph of computations that looks like this:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input -&gt; conv2d -&gt; relu -&gt; maxpool2d -&gt; conv2d -&gt; relu -&gt; maxpool2d</span><br><span class="line">      -&gt; view -&gt; linear -&gt; relu -&gt; linear -&gt; relu -&gt; linear</span><br><span class="line">      -&gt; MSELoss</span><br><span class="line">      -&gt; loss</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(loss.grad_fn)  <span class="comment"># MSELoss</span></span><br><span class="line">print(loss.grad_fn.next_functions[<span class="number">0</span>][<span class="number">0</span>])  <span class="comment"># Linear</span></span><br><span class="line">print(loss.grad_fn.next_functions[<span class="number">0</span>][<span class="number">0</span>].next_functions[<span class="number">0</span>][<span class="number">0</span>])  <span class="comment"># ReLU</span></span><br></pre></td></tr></table></figure>
<pre><code>&lt;MseLossBackward object at 0x7f8589ab59b0&gt;
&lt;AddmmBackward object at 0x7f85894d5400&gt;
&lt;AccumulateGrad object at 0x7f8589ab59b0&gt;
</code></pre><h3 id="Backprop"><a href="#Backprop" class="headerlink" title="Backprop"></a>Backprop</h3><p>To backpropagate the error all we have to do is to <code>loss.backward()</code>. You need to clear the existing gradients though, else gradients will be accumulated to existing gradients.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net.zero_grad()     <span class="comment"># zeroes the gradient buffers of all parameters</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'conv1.bias.grad before backward'</span>)</span><br><span class="line">print(net.conv1.bias.grad)</span><br><span class="line"></span><br><span class="line">loss.backward()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'conv1.bias.grad after backward'</span>)</span><br><span class="line">print(net.conv1.bias.grad)</span><br></pre></td></tr></table></figure>
<pre><code>conv1.bias.grad before backward
tensor([0., 0., 0., 0., 0., 0.])
conv1.bias.grad after backward
tensor([-0.0092,  0.0072, -0.0021, -0.0014,  0.0019, -0.0038])
</code></pre><h3 id="Update-the-weights"><a href="#Update-the-weights" class="headerlink" title="Update the weights"></a>Update the weights</h3><p>The simplest update rule used in practice is the Stochastic Gradient Descent (SGD):</p>
<p><code>weight = weight - learning_rate * gradient</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> net.parameters():</span><br><span class="line">    f.data.sub_(f.grad.data * learning_rate)</span><br></pre></td></tr></table></figure>
<p>However, as you use neural networks, you want to use various different update rules such as SGD, Nesterov-SGD, Adam, RMSProp, etc. To enable this, we built a small package: <code>torch.optim</code> that implements all these methods. Using it is very simple:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># create your optimizer</span></span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># in your training loop:</span></span><br><span class="line">optimizer.zero_grad()   <span class="comment"># zero the gradient buffers</span></span><br><span class="line">output = net(input)</span><br><span class="line">loss = criterion(output, target)</span><br><span class="line">loss.backward()</span><br><span class="line">optimizer.step()    <span class="comment"># Does the update</span></span><br></pre></td></tr></table></figure>
<h2 id="TRAINING-A-CLASSIFIER"><a href="#TRAINING-A-CLASSIFIER" class="headerlink" title="TRAINING A CLASSIFIER"></a>TRAINING A CLASSIFIER</h2><h3 id="What-about-data"><a href="#What-about-data" class="headerlink" title="What about data?"></a>What about data?</h3><p>Generally, when you have to deal with image, text, audio or video data, you can use standard python packages that load data into a numpy array. Then you can convert this array into a <code>torch.*Tensor</code>.</p>
<ul>
<li>For images, packages such as <code>Pillow</code>, <code>OpenCV</code> are useful</li>
<li>For audio, packages such as <code>scipy</code> and <code>librosa</code></li>
<li>For text, either raw Python or Cython based loading, or NLTK and SpaCy are useful</li>
</ul>
<p>Specifically for vision, we have created a package called <code>torchvision</code>, that has data loaders for common datasets such as Imagenet, CIFAR10, MNIST, etc. and data transformers for images, viz., <code>torchvision.datasets</code> and <code>torch.utils.data.DataLoader</code>.</p>
<p>For this tutorial, we will use the CIFAR10 dataset. It has the classes: ‘airplane’, ‘automobile’, ‘bird’, ‘cat’, ‘deer’, ‘dog’, ‘frog’, ‘horse’, ‘ship’, ‘truck’. The images in CIFAR-10 are of size 3x32x32, i.e. 3-channel color images of 32x32 pixels in size.</p>
<p><img src="https://pytorch.org/tutorials/_images/cifar10.png" alt=""></p>
<h3 id="Training-an-image-classifier"><a href="#Training-an-image-classifier" class="headerlink" title="Training an image classifier"></a>Training an image classifier</h3><p>We will do the following steps in order:</p>
<ol>
<li>Load and normalizing the CIFAR10 training and test datasets <code>using torchvision</code></li>
<li>Define a Convolutional Neural Network</li>
<li>Define a loss function</li>
<li>Train the network on the training data</li>
<li>Test the network on the test data</li>
</ol>
<h4 id="1-Loading-and-normalizing-CIFAR10"><a href="#1-Loading-and-normalizing-CIFAR10" class="headerlink" title="1. Loading and normalizing CIFAR10"></a>1. Loading and normalizing CIFAR10</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br></pre></td></tr></table></figure>
<p>The output of torchvision datasets are PILImage images of range [0, 1]. We transform them to Tensors of normalized range [-1, 1]. .. note:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">If running on Windows and you get a BrokenPipeError, try setting</span><br><span class="line">the num_worker of torch.utils.data.DataLoader() to 0.</span><br></pre></td></tr></table></figure></p>
<p>Note: transforms.Normalize(mean,std)</p>
<p>z-score 规范化(零均值规范化)</p>
<script type="math/tex; mode=display">
input = \frac{input - mean}{std}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">transform = transforms.Compose(</span><br><span class="line">    [transforms.ToTensor(),</span><br><span class="line">     transforms.Normalize((<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>), (<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>))])</span><br><span class="line"></span><br><span class="line">trainset = torchvision.datasets.CIFAR10(root=<span class="string">'./data'</span>, train=<span class="literal">True</span>,</span><br><span class="line">                                        download=<span class="literal">True</span>, transform=transform)</span><br><span class="line">trainloader = torch.utils.data.DataLoader(trainset, batch_size=<span class="number">4</span>,</span><br><span class="line">                                          shuffle=<span class="literal">True</span>, num_workers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">testset = torchvision.datasets.CIFAR10(root=<span class="string">'./data'</span>, train=<span class="literal">False</span>,</span><br><span class="line">                                       download=<span class="literal">True</span>, transform=transform)</span><br><span class="line">testloader = torch.utils.data.DataLoader(testset, batch_size=<span class="number">4</span>,</span><br><span class="line">                                         shuffle=<span class="literal">False</span>, num_workers=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">classes = (<span class="string">'plane'</span>, <span class="string">'car'</span>, <span class="string">'bird'</span>, <span class="string">'cat'</span>,</span><br><span class="line">           <span class="string">'deer'</span>, <span class="string">'dog'</span>, <span class="string">'frog'</span>, <span class="string">'horse'</span>, <span class="string">'ship'</span>, <span class="string">'truck'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Downloading https://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz to ./data/cifar-10-python.tar.gz


100.0%

Files already downloaded and verified
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># functions to show an image</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imshow</span><span class="params">(img)</span>:</span></span><br><span class="line">    img = img / <span class="number">2</span> + <span class="number">0.5</span>     <span class="comment"># unnormalize</span></span><br><span class="line">    npimg = img.numpy()</span><br><span class="line">    plt.imshow(np.transpose(npimg, (<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>)))</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># get some random training images</span></span><br><span class="line">dataiter = iter(trainloader)</span><br><span class="line">images, labels = dataiter.next() <span class="comment"># image size(4, 1, 32, 32) nSamples nChannels Height Width</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># show images</span></span><br><span class="line">imshow(torchvision.utils.make_grid(images))</span><br><span class="line"><span class="comment"># print labels</span></span><br><span class="line">print(<span class="string">' '</span>.join(<span class="string">'%5s'</span> % classes[labels[j]] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>)))</span><br></pre></td></tr></table></figure>
<p><img src="images/output_74_0.png" alt="png"></p>
<pre><code>  cat horse  deer truck
</code></pre><h4 id="2-Define-a-Convolutional-Neural-Network"><a href="#2-Define-a-Convolutional-Neural-Network" class="headerlink" title="2. Define a` Convolutional Neural Network"></a>2. Define a` Convolutional Neural Network</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>)</span><br><span class="line">        self.pool = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, <span class="number">5</span>)</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        x = self.pool(F.relu(self.conv1(x)))</span><br><span class="line">        x = self.pool(F.relu(self.conv2(x)))</span><br><span class="line">        x = x.view(<span class="number">-1</span>, <span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>)</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">net = Net()</span><br></pre></td></tr></table></figure>
<h4 id="3-Define-a-Loss-function-and-optimizer"><a href="#3-Define-a-Loss-function-and-optimizer" class="headerlink" title="3. Define a Loss function and optimizer"></a>3. Define a Loss function and optimizer</h4><p>Let’s use a Classification Cross-Entropy loss and SGD with momentum.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure>
<h4 id="4-Train-the-network"><a href="#4-Train-the-network" class="headerlink" title="4. Train the network"></a>4. Train the network</h4><p>This is when things start to get interesting. We simply have to loop over our data iterator, and feed the inputs to the network and optimize.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">2</span>):  <span class="comment"># loop over the dataset multiple times</span></span><br><span class="line"></span><br><span class="line">    running_loss = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> i, data <span class="keyword">in</span> enumerate(trainloader, <span class="number">0</span>):</span><br><span class="line">        <span class="comment"># get the inputs; data is a list of [inputs, labels]</span></span><br><span class="line">        inputs, labels = data</span><br><span class="line"></span><br><span class="line">        <span class="comment"># zero the parameter gradients</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># forward + backward + optimize</span></span><br><span class="line">        outputs = net(inputs)</span><br><span class="line">        loss = criterion(outputs, labels)</span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print statistics</span></span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">2000</span> == <span class="number">1999</span>:    <span class="comment"># print every 2000 mini-batches</span></span><br><span class="line">            print(<span class="string">'[%d, %5d] loss: %.3f'</span> %</span><br><span class="line">                  (epoch + <span class="number">1</span>, i + <span class="number">1</span>, running_loss / <span class="number">2000</span>))</span><br><span class="line">            running_loss = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'Finished Training'</span>)</span><br></pre></td></tr></table></figure>
<pre><code>[1,  2000] loss: 2.242
[1,  4000] loss: 1.987
[1,  6000] loss: 1.758
[1,  8000] loss: 1.639
[1, 10000] loss: 1.543
[1, 12000] loss: 1.508
[2,  2000] loss: 1.426
[2,  4000] loss: 1.390
[2,  6000] loss: 1.363
[2,  8000] loss: 1.351
[2, 10000] loss: 1.335
[2, 12000] loss: 1.299
Finished Training
</code></pre><h4 id="5-Test-the-network-on-the-test-data"><a href="#5-Test-the-network-on-the-test-data" class="headerlink" title="5. Test the network on the test data"></a>5. Test the network on the test data</h4><p>We have trained the network for 2 passes over the training dataset. But we need to check if the network has learnt anything at all.</p>
<p>We will check this by predicting the class label that the neural network outputs, and checking it against the ground-truth. If the prediction is correct, we add the sample to the list of correct predictions.</p>
<p>Okay, first step. Let us display an image from the test set to get familiar.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dataiter = iter(testloader)</span><br><span class="line">images, labels = dataiter.next()</span><br><span class="line"></span><br><span class="line"><span class="comment"># print images</span></span><br><span class="line">imshow(torchvision.utils.make_grid(images))</span><br><span class="line">print(<span class="string">'GroundTruth: '</span>, <span class="string">' '</span>.join(<span class="string">'%5s'</span> % classes[labels[j]] <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>)))</span><br></pre></td></tr></table></figure>
<p><img src="images/output_82_0.png" alt="png"></p>
<pre><code>GroundTruth:    cat  ship  ship plane
</code></pre><p>Okay, now let us see what the neural network thinks these examples above are:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">outputs = net(images)</span><br></pre></td></tr></table></figure>
<p>The outputs are energies for the 10 classes. The higher the energy for a class, the more the network thinks that the image is of the particular class. So, let’s get the index of the highest energy:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_, predicted = torch.max(outputs, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Predicted: '</span>, <span class="string">' '</span>.join(<span class="string">'%5s'</span> % classes[predicted[j]]</span><br><span class="line">                              <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">4</span>)))</span><br></pre></td></tr></table></figure>
<pre><code>Predicted:    cat  ship  ship  ship
</code></pre><p>Let us look at how the network performs on the whole dataset.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">correct = <span class="number">0</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> testloader:</span><br><span class="line">        images, labels = data</span><br><span class="line">        outputs = net(images)</span><br><span class="line">        _, predicted = torch.max(outputs.data, <span class="number">1</span>)</span><br><span class="line">        total += labels.size(<span class="number">0</span>)</span><br><span class="line">        correct += (predicted == labels).sum().item()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Accuracy of the network on the 10000 test images: %d %%'</span> % (</span><br><span class="line">    <span class="number">100</span> * correct / total))</span><br></pre></td></tr></table></figure>
<pre><code>Accuracy of the network on the 10000 test images: 53 %
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">class_correct = list(<span class="number">0.</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line">class_total = list(<span class="number">0.</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> testloader:</span><br><span class="line">        images, labels = data</span><br><span class="line">        outputs = net(images)</span><br><span class="line">        _, predicted = torch.max(outputs, <span class="number">1</span>)</span><br><span class="line">        c = (predicted == labels).squeeze()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">            label = labels[i]</span><br><span class="line">            class_correct[label] += c[i].item()</span><br><span class="line">            class_total[label] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    print(<span class="string">'Accuracy of %5s : %2d %%'</span> % (</span><br><span class="line">        classes[i], <span class="number">100</span> * class_correct[i] / class_total[i]))</span><br></pre></td></tr></table></figure>
<pre><code>Accuracy of plane : 57 %
Accuracy of   car : 67 %
Accuracy of  bird : 22 %
Accuracy of   cat : 46 %
Accuracy of  deer : 61 %
Accuracy of   dog : 28 %
Accuracy of  frog : 53 %
Accuracy of horse : 65 %
Accuracy of  ship : 79 %
Accuracy of truck : 53 %
</code></pre><h3 id="Training-on-GPU"><a href="#Training-on-GPU" class="headerlink" title="Training on GPU"></a>Training on GPU</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">device = torch.device(<span class="string">"cuda:0"</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">"cpu"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Assuming that we are on a CUDA machine, this should print a CUDA device:</span></span><br><span class="line"></span><br><span class="line">print(device)</span><br><span class="line"></span><br><span class="line">net.to(device)</span><br><span class="line"></span><br><span class="line">inputs, labels = data[<span class="number">0</span>].to(device), data[<span class="number">1</span>].to(device)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>Transformer-All-is-all-you-need</title>
    <url>/2020/03/04/Transformer-All-is-all-you-need/</url>
    <content><![CDATA[<h1 id="The-Transformer-Attention-is-all-you-need"><a href="#The-Transformer-Attention-is-all-you-need" class="headerlink" title="The Transformer - Attention is all you need"></a>The Transformer - Attention is all you need</h1><p>参考来源：<a href="https://mchromiak.github.io/articles/2017/Sep/12/Transformer-Attention-is-all-you-need/#.Xl8qrXWTLmj" target="_blank" rel="noopener">https://mchromiak.github.io/articles/2017/Sep/12/Transformer-Attention-is-all-you-need/#.Xl8qrXWTLmj</a></p>
<p>前置知识：</p>
<ul>
<li>RNN – Andrej Karpathy’s blog <a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/" target="_blank" rel="noopener">The Unreasonable Effectiveness of Recurrent Neural Networks </a></li>
<li>Seq2Seq - Nathan Lintz Seq2seq-Nathan Lintz<a href="https://indico.io/blog/sequence-modeling-neuralnets-part1/" target="_blank" rel="noopener">Sequence Modeling With Neural Networks (Part 1): Language &amp; Seq2Seq</a>, Part2 <a href="https://indico.io/blog/sequence-modeling-neural-networks-part2-attention-models/" target="_blank" rel="noopener">Sequence modeling with attention</a></li>
<li>LSTM – Christopher Olah’s blog <a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noopener">Understanding LSTM Networks </a> and R2Rt.com <a href="https://r2rt.com/written-memories-understanding-deriving-and-extending-the-lstm.html" target="_blank" rel="noopener">Written Memories: Understanding, Deriving and Extending the LSTM</a>.</li>
<li>Attention – Christopher Olah<a href="https://distill.pub/2016/augmented-rnns/#attentional-interfaces" target="_blank" rel="noopener">Attention and Augmented Recurrent Neural Networks</a></li>
</ul>
<a id="more"></a>
<h2 id="算法的目标"><a href="#算法的目标" class="headerlink" title="算法的目标"></a>算法的目标</h2><ul>
<li><code>Seq2Seq的并行化：RNN/CNN</code>处理有序的逐字的序列是并行的障碍。<code>Transformer</code>通过使用注意力机制和对序列中字符的位置编码来替换递归结构来获得并行化运行，反过来，这也导致训练时间的明显减少。</li>
<li>减少顺序计算：独立序列中字符的位置距离，以$O(1)$的时间复杂度来学习两个符号之间的依赖关系，</li>
</ul>
<h2 id="RNN和CNN"><a href="#RNN和CNN" class="headerlink" title="RNN和CNN"></a>RNN和CNN</h2><ol>
<li>RNN<ul>
<li>优点：<code>RNN</code>对于语言，图片等序列的变长表示的处理是流行和成功的。<code>RNN</code>是<code>seq2seq</code>(with attention)的核心。门控模型比如<code>LSTM</code>、<code>GRU</code>适合处理远距离的误差传播</li>
<li>问题：它的顺序特点阻止了实例的并行化。远距离的依赖仍然难以处理，尽管有门这类的模型。<code>RNN</code>中对于序列状态的对齐是浪费的。难以对层级相似的领域建模，比如语言。</li>
</ul>
</li>
<li>CNN<ul>
<li>优点：对于每层的并行化和适应大多数依赖是局部的（感觉翻译有问题）</li>
<li>问题：当使用扩大卷积，对文本使用左填充，位置之间的路径可以是对数的。</li>
<li>解决方案：<code>multi-head self-attention</code> 机制。论文中表明这种方式可以减少2-3个数量级的计算。</li>
</ul>
</li>
</ol>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Paper: <a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">ArXiv</a>.</p>
<p>当使用<code>RNN</code>或者<code>CNN</code>接收一个序列作为输入时，它能按照逐字的处理句子。但这种顺序性对于处理的并行是一个障碍。更重的是，在这样的情况下，当序列太长的话，模型更倾向于以往序列中远距离的内容或者将它和后序位置的内容混合起来。</p>
<p>一种措施是采用卷积<code>seq2seq</code>。卷积能够使得<code>GPU</code>处理能够并行化。因此 <a href="https://arxiv.org/abs/1705.03122" target="_blank" rel="noopener">Gehring et al, 2017 </a> (Facebook AI)提出了一个全卷积架构来表示输入序列的层次表示。关键是距离近的在低层次相互作用，而距离远则在高层此相互作用。这种卷积网络的堆积被用来评估字之间的长距离依赖。尽管固定了卷积核的大小，但这都是可能的。</p>
<p>文中作者也提出了两个技巧：</p>
<ul>
<li>位置嵌入：将位置嵌入添加到输入嵌入当中，用于捕捉序列中的顺序。</li>
<li><code>Multi-step attention</code>：注意力机制使用当前的decoder状态和前面的目标字符的嵌入来计算。</li>
</ul>
<p><img src="/images/Transformer/MultiStepAttention.gif" alt=""></p>
<center>图1： Multi-step attention from ConvS2S</center>

<p>为了替换卷积网络，<code>Transformer</code>中提出了一种新的方法。他提出了对每个位置进行编码和使用注意力机制，来关联两个距离较远的单词，因此实现了并行化，加速了训练速度。</p>
<p><code>NLP</code>中通过<code>seq2seq</code>模型实现将输入句子编码成固定大小的向量表示。向量大小固定，与输入句子的长度无关。很明显这导致了失去了一些信息。为了解决这个问题，<code>Transformer</code>提出了一种基于注意力的替代方法</p>
<p>可以参考：</p>
<ul>
<li><a href="https://arxiv.org/abs/1703.03906" target="_blank" rel="noopener">Denny Britz on Attention, 2017</a></li>
<li><a href="https://arxiv.org/abs/1705.04304" target="_blank" rel="noopener">Self-attention (a.k.a Intra-attention)</a></li>
</ul>
<h2 id="Transformer的Motivation"><a href="#Transformer的Motivation" class="headerlink" title="Transformer的Motivation"></a>Transformer的Motivation</h2><p><code>Transformer</code>架构的目标是序列变换的问题，即输入序列转换为输出序列的任务。比如语音识别、文本语音转换、机器翻译、蛋白质第二结构预测、图灵机等。目标是设置一个单一的架构来处理尽可能多的序列。</p>
<p>基于<code>encoder-decode</code>r方案的复杂<code>RNN</code>和<code>CNN</code>是主要的序列变换模型（语言模型和机器模型）。循环模型由于序列性质而不能并行的训练。因此存在从记忆中学习长期依赖的问题。记忆越大，效果越好，但是内存会限制学习长序列的批处理。这也是为什么并行化没有帮助的理由。</p>
<p>减少序列计算的约束一直是众多研究的方向。但是在基于CNN的方法中，从输入到输出位置的隐藏表示的并行计算随着位置的增加而增加。<code>ConvS2S</code> 的 $O(n)$和<code>ByteNet</code>的$O(n\log n)$的复杂度使得学习长距离的依赖关系更加困难。</p>
<p><code>Transformer</code>减少了从输入/输出序列中两个字符的序列计算数量到常量$O(1)$数量级。<code>Transformer</code>使用多头的注意力机制实现了这个目标。多头注意力机制允许建模输入 或 输出序列的依赖而不用考虑他们的距离。</p>
<p>注意力的大多数研究都是和RNN网络结合起来。而<code>Transformer</code>的新方法是完全消除循环，使用注意力来处理输入和输出之间的依赖。<code>Transformer</code>将关注点转移到注意力机制上。它不仅消除了循环，而且有利于使用 <code>self-attention</code>的卷积。此外，还留出了更大的空间来并行化。</p>
<p>这篇文章的最高性能是通过将注意力机制运用到连接<code>encoder</code>和<code>decoder</code>来实现的。</p>
<p>这种架构被作者称为第一个完全使用<code>self-attention</code>来计算输入和输出的表示的架构。</p>
<h2 id="算法的对信息的处理策略"><a href="#算法的对信息的处理策略" class="headerlink" title="算法的对信息的处理策略"></a>算法的对信息的处理策略</h2><p>Transformer是基于<code>seq2seq</code>模型的统计机器翻译模型。<code>seq2seq</code>由两个<code>RNN</code>组成，一个是<code>encoder</code>用于处理输入，另一是<code>decoder</code>用于生成输出。</p>
<p>通常，<code>Transformer</code>的<code>encoder</code>将输入序列映射到连续表示$z$，反过来，$z$被<code>decoder</code>用来生成输出，例如一次一个字符。</p>
<p><code>encoder</code>的最终状态是一个固定长度的向量$z$。$z$必须<code>encode</code>包含原始句子的全部信息。因此$z$也被成为句子嵌入(sentence embedding)。</p>
<p><code>encoder-decoder</code>模型在它的每一步设计为<code>auto-regressive</code>（自回归）。使用前面生成的字符作为额外的输入来生成下一个字符时。</p>
<script type="math/tex; mode=display">
x_i+y_{i-1} \to y_i</script><h2 id="基于Encoder-Decoder的Transformer"><a href="#基于Encoder-Decoder的Transformer" class="headerlink" title="基于Encoder-Decoder的Transformer"></a>基于Encoder-Decoder的Transformer</h2><p>在<code>Transformer</code>（如<code>ByteNet</code>或<code>ConvS2S</code>)中，<code>decoder</code>是直接堆在<code>encoder</code>上面。<code>Encoder</code>和<code>Decoder</code>都是由相同的层堆积而成的。每个堆积层都是由两种一般类型的子层组成的：</p>
<ul>
<li><code>multi-head self-attention mechanism</code> </li>
<li><code>position-wise fully connected FNN</code></li>
</ul>
<p>与<code>ConvS2S</code>相反，这里的输入表示是有输入元素和它在序列中的绝对位置组合而成的。<code>ByteNet</code>有扩大的卷积层和没有<code>position-wise FNN</code>。Transformer针对这两种类型采用了两种不同的神经网络。</p>
<p>这种注意力机制的应用和变化使得Transformer变得新颖。</p>
<p>One can find the reference Transformer model implementation from authors is present in <a href="https://github.com/tensorflow/tensor2tensor/blob/master/tensor2tensor/models/transformer.py" target="_blank" rel="noopener">Tensor2Tensor (T2T) library </a></p>
<p><img src="/images/Transformer/encoder.png" alt=""></p>
<center>图2：单层Encoder（左） 和  N=6个相同的层组成的Decoder(右)</center>

<h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><ul>
<li><code>Stage 1- Encoder</code> 输入序列顺序的信息是很重要的。因为没有递归，也没有卷积，所以在序列中每个字符关于绝对或相对位置的信息使用位置编码来表示。因此，对于<code>encoder</code>的输入表示成这样：</li>
</ul>
<ul>
<li><code>positional encodings</code>: added $\oplus$ to</li>
<li><code>embedded input</code></li>
</ul>
<ul>
<li><p>$N=6$ layers。实际上是超过6层的。因为这些<code>layers</code>由两个layers组成：<code>position-wise FNN</code> 和 <code>encoder</code> 或 <code>decoder</code> 和基于注意力的<code>sublayers</code>。每个额外还包括四个线性投影和注意力逻辑。因此，可以提供比6 <code>layer</code>架构更深的层次。</p>
<ul>
<li><p><code>Stage 2- Multi-head attention</code></p>
</li>
<li><p><code>Stage 3- position-wise FNN</code></p>
<p><code>Stage2</code> 和 <code>Stage 3</code> 使用残差连接（因此，所有阶段都是用512维 $d_{model}=512$），然后接着在输出端使用<code>normalization layer</code></p>
</li>
</ul>
</li>
</ul>
<p>所以，<code>Encoder</code>的原理如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Stage1_out = Embedding512 + TokenPositionEncoding512</span><br><span class="line">Stage2_out = layer_normalization( multihead_attention(Stage1_out) + Stage1_out )</span><br><span class="line">Stage3_out = layer_normalization(FFN(Stage2_out) + Stage2_out)</span><br><span class="line"></span><br><span class="line">out_enc = Stage3_out</span><br></pre></td></tr></table></figure>
<h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p><code>Decoder</code>的架构是非常相似的，它在<code>Stage 3</code>采用额外的<code>layer</code>，使用在<code>decoder output</code> 上使用 <code>mask multi-head attention</code>。</p>
<ul>
<li>Stage1 - Decoder Input。输入是output embedding，偏移一个位置来确保对位置$i$的预测只依赖位置$i$之前的位置。</li>
<li>Stage2 Masked Multi-head attention 修改来防止位置影响后续的位置(感觉翻译有问题。)</li>
</ul>
<p>Stage 2,3,4也使用残差连接，在它的输出后面接着normalization layer。</p>
<p>Decoder的原理如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Stage1_out = OutputEmbedding512 + TokenPositionEncoding512</span><br><span class="line"></span><br><span class="line">Stage2_Mask = masked_multihead_attention(Stage1_out)</span><br><span class="line">Stage2_Norm1 = layer_normalization(Stage2_Mask) + Stage1_out</span><br><span class="line">Stage2_Multi = multihead_attention(Stage2_Norm1 + out_enc) + Stage2_Norm1</span><br><span class="line">Stage2_Norm2 = layer_normalization(Stage2_Multi) + Stage2_Multi</span><br><span class="line"></span><br><span class="line">Stage3_FNN = FNN(Stage2_Norm2)</span><br><span class="line">Stage3_Norm = layer_normalization(Stage3_FNN) + Stage2_Norm2</span><br><span class="line"></span><br><span class="line">out_dec = Stage3_Norm</span><br></pre></td></tr></table></figure>
<h2 id="组成Transformer架构的机制"><a href="#组成Transformer架构的机制" class="headerlink" title="组成Transformer架构的机制"></a>组成Transformer架构的机制</h2><p>Transformer主要由以下几种类型的layers组成，细节如下：</p>
<h3 id="Positional-Encoding——PE"><a href="#Positional-Encoding——PE" class="headerlink" title="Positional Encoding——PE"></a>Positional Encoding——PE</h3><p>在RNN(LSTM)中，time step的概念倍定义为一次一个的输入或输出。在FNN中，使用某种方式将位置编码表示成时间。在Transformer中，作者提出使用正弦波函数来表示时间，作为额外的输入。这种信号增加到输入和输出来表示时间的变化。</p>
<p>向输入嵌入增加位置编码的一种方式是嵌入输入元素的绝对位置(ConvS2S)。但是，Transformer的作者使用不同频率正弦和余弦函数。这种正弦的方法非常复杂，和嵌入绝对位置的方法有着相似的性能。但是，它能够允许模型能够在测试时间内对更长的句子产生更好的翻译。这种正弦方式能够让模型外推到更长的序列上。</p>
<p>这种编码方式能够感知当前处理的输入或输出的位置。位置编码能够被学习或者固定。作者通过测试表明：两种的性能相似。</p>
<script type="math/tex; mode=display">
\begin{align}
& PE(pos, 2i) = \sin(\frac{pos}{1000^{\frac{2i}{d_{model}}}}) \\
& PE(pos, 2i+1) = \cos(\frac{pos}{1000^{\frac{2i}{d_{model}}}}) \\
\end{align}</script><h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><p>作者阐述了attention的定义，详细的可以查看<a href="https://mchromiak.github.io/articles/2017/Sep/01/Primer-NN/#attention-basis" target="_blank" rel="noopener">Attention primer</a>。Attention是一种函数，能够将两个元素的输入<code>(query,key-value pair)</code>映射到一个输出。由映射函数的到的输出是<code>values</code>的加权和。每个<code>value</code>的权重是度量每个input <code>key</code> 和<code>query</code>的相关程度。Transformer中attention的创新点是 <code>multi-head self-attention</code></p>
<h3 id="Scaled-Dot-Product-Attention"><a href="#Scaled-Dot-Product-Attention" class="headerlink" title="Scaled Dot-Product Attention"></a>Scaled Dot-Product Attention</h3><p>在<code>encoder-decoder</code>中，<code>query</code>通常是decoder的隐藏状态。<code>key</code>是encoder的隐藏状态。相应<code>value</code>是规范化的权重，表示一个<code>key</code>得到多少attention。输出使用加权和来计算。这里的<code>query</code>和<code>key</code>的点积用来计算value。</p>
<p>假设<code>queries</code> 和 <code>keys</code>的维度是 $d_k$，<code>values</code>的维度是$d_v$。这些维度是由线性投影得到的。输入通过三个矩阵表示：<code>queries</code> 矩阵 <code>Q</code>，<code>keys</code> 矩阵 <code>K</code>， <code>values</code>矩阵 <code>V</code>。</p>
<p>上面的方式有两个好处：</p>
<ul>
<li>加法和乘法点积变种有着相似的理论复杂性</li>
<li>有着常量$\frac{1}{\sqrt{d_k}}$点积能够更快和空间效率更高。被用来优化乘法代码</li>
</ul>
<script type="math/tex; mode=display">
Attention(Q,k,V)=softmax(\frac{QK^T}{\sqrt{d_k}})V</script><p>在Numpy中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attention</span><span class="params">(Q, k, V)</span>:</span></span><br><span class="line">    num = np.dot(Q, K.T)</span><br><span class="line">    denum = np.sqrt(K.shape[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> np.dot(softmax(num/denum), V)</span><br></pre></td></tr></table></figure>
<h3 id="Multi-head-attention"><a href="#Multi-head-attention" class="headerlink" title="Multi-head attention"></a>Multi-head attention</h3><p>Transformer减少了输入和输出序列中相关位置的计算操作的量级到$O(1)$。然而这是由减少了有效的分解为代价的，因为平均注意力加权位置。</p>
<p><img src="/images/Transformer/MultiHead.png" alt=""></p>
<center>图3：由h个并行运行的attention layers组成的 Multi-Head Attention</center>

<p>为了减少代价，作者使用了Multi-head attention</p>
<ul>
<li>$h=8$ attention layers：表示K，Q，V的线性投影（为了减少维度）<script type="math/tex; mode=display">
head_i = Attention(QW_i^Q,KW_i^K,VW_i^V)</script></li>
</ul>
<p>  这里的投影就是参数矩阵</p>
<script type="math/tex; mode=display">
  W_i^Q,W_i^K \in \mathbb{R}^{d_{model} \times d_k},W_i^V \in \mathbb{R}^{d_{model} \times d_v}</script><ul>
<li><p>在每个layer（不同的<code>k,q,v</code>的线性投影）并行使用scaled-dot attention，可以得到$d_v$维的输出</p>
</li>
<li><p>连接每个layer（不同的线性投影）的输出：$Concat(head_1， head_2, \cdots , head_h)$</p>
</li>
<li><p>对上一步的连接结果进行线性投影</p>
<script type="math/tex; mode=display">
MultiHeadAttention(Q, K, V) = Concat(head_1, \cdots, head_h)W^o \quad where \quad W_0 \in  \mathbb{R^{d_{hd_v} \times d_{model}}}</script></li>
</ul>
<p><code>Transformer</code>使用 <code>multi-head</code> （ $d<em>{model}/h $ 维的并行的<code>attention</code>函数） <code>attention</code>  替代 单个（ $d</em>{model}$维）的 <code>attention</code>函数（其中<code>q,k,v</code>都是$d_{model}$维的）。由于减少了每个head的维度，所以在计算代价上和<code>single-head attention</code>是相似的。</p>
<p><code>Transformer</code>模仿了经典的注意力机制，在<code>encoder-decoder attention layers</code> 的<code>queries</code>是来自前面的<code>decoder layer</code>。 <code>keys</code> 和 <code>values</code>来源<code>encoder</code>的输出。因此，在<code>decoder</code>上的每个位置能够观察到输出序列的所有位置。</p>
<h3 id="Self-Attention-（SA"><a href="#Self-Attention-（SA" class="headerlink" title="Self-Attention （SA)"></a>Self-Attention （SA)</h3><p>See <a href="https://mchromiak.github.io/articles/2017/Sep/01/Primer-NN/#attention-basis" target="_blank" rel="noopener">Attention Primer</a> for basics on attention.</p>
<p>在<code>encoder</code>中，<code>self-attention layer</code> 处理来自同一个位置的输入<code>queries，keys，values</code>。encoder中的每个位置都可以观察到来自前面 layer of the encoder 的所有位置。</p>
<p>在decoder中，self-attention layer 能够让每个位置注意到decoder中前面的所有的位置，包括当前的位置。为了保持auto-regressive的属性，通过mask(set to $-\infty$)所有的 和与softmax非法连接的输入<code>values</code>，使用dot-attention attention来表示左边的信息流。</p>
<p>作者产生使用 self-attention layers 代替 循环 layers和卷积layers由三个原因。</p>
<ul>
<li><p>最小化每层的总的计算复杂度</p>
<p>self-attention layers 使用序列执行操作$O(1)$数量级连接所有的位置，在RNN中是$O(n)$。</p>
</li>
<li><p>最大化并行计算的数量，通过最小化序列操作的需求的数量来度量</p>
<p>对于序列长度 n 小于表示的维度d，对于非常长的序列 n &gt; d维self-attention 能够只考虑以输入序列中以各自输出位置为中心大小为r的邻域，从而使得最大路径增加到$O(\frac{n}{r})$</p>
</li>
<li><p>最小化由不同类型的layer组成的网络中任一两个输入和输出位置之间的最大路径长度。输入和输出序列中任何位置组合之间的路径越短，越容易学习到长期依赖关系。</p>
</li>
</ul>
<h3 id="Position-wise-FFN"><a href="#Position-wise-FFN" class="headerlink" title="Position-wise FFN"></a>Position-wise FFN</h3><p>在encoder和decoder最后那个，attention子层由一个全连接的FNN来处理。它应用在每个单独的位置上，同时意味着两个线性变换和一个ReLU</p>
<script type="math/tex; mode=display">
FNN(x) = max(0,xW_1+b_1)W_2+b_2</script><p>对于每个位置的线性变换是一样的，但是每个层使用不同的参数。它的工作方式类似于两个卷积核大小维1的卷积网络。输入或输出的维度是$d<em>{model}=512$，inner0layer 是$d</em>{ff}=2048$</p>
<h2 id="算法的伪代码or流程图"><a href="#算法的伪代码or流程图" class="headerlink" title="算法的伪代码or流程图"></a>算法的伪代码or流程图</h2><p><img src="/images/Transformer/transform20fps.gif" alt=""></p>
<center>图4：在英译法的Transformer的逐步变换</center>

<p>在encoder阶段（如图1所示），Transformer第一步对输入句子(空心圈)中的每个word生成初始的表示(representation/embedding)。下一步，对每个word，self-attention收集了句子上下文其他word的信息，并且产生了新的表示(representation，被填充后的圈；实心圆)。对句子里的每个word重复这个过程。对每一个word，基于前面的表示继续构建新的表示，前面的表示并行的重复多次（下一层的填空圈）</p>
<p>Decoder按照从左到右的模式每次相似的生成一个word。它观察decoder中先前生成的words和encoder的最终表示。</p>
<p>值得注意的self-attention策略允许遇见共指消解<code>coreference resolution</code>的问题，例如，句子中的单词<code>it</code>能够根据上下文指代句子中的不同名词。</p>
<p><img src="/images/Transformer/CoreferenceResolution.png" alt=""></p>
<center>图5：共参考消解. 两个例子中 it和不同的符号相关 </center>

<h2 id="启发和经验准则"><a href="#启发和经验准则" class="headerlink" title="启发和经验准则"></a>启发和经验准则</h2><p>作者进行了一系列的实验，讨论了以有着使用了100K Step 64维的 key,values的$h=8$heads为基础的模型，模型大小为512的$N=6$的layers的推荐方案</p>
<p>同时也说明了模型质量随着$d_k$的减少而下降，因此可以进一步优化 dot-product compatibility function。</p>
<p>固定的正弦位置编码和学习的位置编码相比，得分几乎相等。</p>
<h2 id="算法的使用场景"><a href="#算法的使用场景" class="headerlink" title="算法的使用场景"></a>算法的使用场景</h2><ul>
<li>语言翻译</li>
<li>句法类别分析的经典语言分析任务</li>
<li>输入输出不同的模式，如图像和视频</li>
<li>共指消解</li>
</ul>
<h2 id="可用于演示的数据集"><a href="#可用于演示的数据集" class="headerlink" title="可用于演示的数据集"></a>可用于演示的数据集</h2><ul>
<li>Perplexity (PPL) BLEU (PPL) BLEU</li>
<li>English-to-German translation development set WMT 2014 English-to-German and WMT 2014 English-to-French translation tasks</li>
<li>newstest2013 </li>
<li>English constituency parsing </li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title>Word2Vec原理</title>
    <url>/2020/03/21/Word2Vec%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h1><blockquote>
<p>word2vec 是 google 在 2013 年推出的一个 NLP 工具，它的特点是将所有的词向量化，这样词与词之间就可以定量的去度量他们之间的关系，挖掘词之间的联系。</p>
<p>因此本文的讲解 word2vec 原理以 Github 上的 <a href="https://github.com/tmikolov/word2vec" target="_blank" rel="noopener">word2vec</a> 代码为准。本文关注于 word2vec 的基础知识。</p>
</blockquote>
<a id="more"></a>
<h2 id="词向量基础"><a href="#词向量基础" class="headerlink" title="词向量基础"></a>词向量基础</h2><p>词向量来表示词并不是Word2Vec的首创，很久之前就提出了。最早的词向量相当的冗长，词向量维度大小为整个词汇表的大小，对于每个具体词汇表中词，将对应的位置置为1。这就是One-hot编码表示。</p>
<p>One-hot representation 表示词向量是非常简单的，但存在很多问题。最大的问题就是一般词汇表非常的大，比如百万级别，那么每个词都得用百万维度的向量来表示，这对内存来说简直是个灾难。而且只有一个位置为1,其余为0，表达的效率不高。因此如何将词向量的维度变小？</p>
<p>Distributed representation 就是为了解决 one hot representation的问题而提出的。它的思想就是通过训练，将每个词映射到一个较短的词向量来。所有的词向量就构成了向量空间，进而可以使用统计学的方法来研究词与词之间的关系。但是这个较短的词向量维度多大呢？这个一般需要我们在训练时自己来指定。</p>
<p>通过Distributed Representation表示较短的词向量，就可以很容易来分析词之间的关系。</p>
<p>如果将词的维度降到2维，用下图的词向量表示我们的词的时候，可以发现：</p>
<script type="math/tex; mode=display">
\overrightarrow{King}-\overrightarrow{Man}+\overrightarrow{Woman} = \overrightarrow{Queen}</script><p><img src="/images/word2vec/distribute-representation-demo1.png" alt="distribute-representation-demo1"></p>
<p>可见，只要得到词汇表中所有词对应的词向量，就可以做很多的事情。</p>
<p>但是如何训练得到合适的词向量？常见的方法就是使用神经网络语言模型。</p>
<h2 id="CBOW-amp-Skip-Gram-用于-NNLM-Neural-Network-Language-Model"><a href="#CBOW-amp-Skip-Gram-用于-NNLM-Neural-Network-Language-Model" class="headerlink" title="CBOW &amp; Skip-Gram 用于 NNLM(Neural Network Language Model)"></a>CBOW &amp; Skip-Gram 用于 NNLM(Neural Network Language Model)</h2><p>在word2vec提出之前，以及使用神经网络DNN来训练词向量进而处理词与词之间的关系。一般的方法是一个三层的神经网络结构（当然也可以是多层），分为：输入层、隐藏层和输出层（softmax层）。</p>
<p>这种模型的输入和输出一般采用CBOW(Continuous Bag-of-Words)与Skip-Gram来定义。</p>
<p>CBOW模型</p>
<ul>
<li>输入：特征词的上下文相关的词对应的词向量</li>
<li>输出：特征词的对应词向量</li>
</ul>
<p>比如这样一段话：<code>..an efficent method for learning high qualitu distributed vector...</code>。假设上下文大小取值为4，特定的词是”learning”，也就是我们需要输出词向量，上下文对应的词有8个，前后各4个，这8个词就是模型的输入。</p>
<p><img src="/images/word2vec/CBOW-example1.png" alt="CBOW-example1"></p>
<p>因为CBOW采用的是词袋模型，因此这8个词的地位是相同的，不考虑它们和我们关注的词之间的距离，只要在上下文之内即可。</p>
<p>在上面的例子中，输入是8个词向量，输出是所有词的softmax概率，训练目标是期望训练样本特定词对应的softmax概率最大。</p>
<p>Skip-Gram模型：和CBOW的思路刚好相反：</p>
<ul>
<li>输入：特定的一个词的词向量</li>
<li>输出：特定词对应的上下文词向量。</li>
</ul>
<p>同样以上面的例子，输入是特定词，输出是softmax概率排前8的8个词。</p>
<p>问题：word2vec没有使用DNN模型，为了解决DNN模型处理耗时长。因为词汇表非常大，意味值输出层需要进行softmx计算各个词的输出概率的计算了很大。</p>
<h2 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h2><p>霍夫曼树的建立其实并不难，过程如下：</p>
<p>　　　　输入：权值为(w1,w2,…wn)(w1,w2,…wn)的nn个节点</p>
<p>　　　　输出：对应的霍夫曼树</p>
<p>　　　　1）将(w1,w2,…wn)(w1,w2,…wn)看做是有nn棵树的森林，每个树仅有一个节点。</p>
<p>　　　　2）在森林中选择根节点权值最小的两棵树进行合并，得到一个新的树，这两颗树分布作为新树的左右子树。新树的根节点权重为左右子树的根节点权重之和。</p>
<p>　　　　3） 将之前的根节点权值最小的两棵树从森林删除，并把新树加入森林。</p>
<p>　　　　4）重复步骤 2）和 3）直到森林里只有一棵树为止。</p>
<p>Huffman树的优点？</p>
<p>当得到霍夫曼树后，我们对叶子节点进行霍夫曼编码，权重高的叶子节点越靠近根节点，而权重低的叶子节点则会原理根节点，这就导致这样一个结果：高权重节点编码值较短，低权重节点编码值较长。</p>
<p>确保了树的带权路径最短，也符合信息论。</p>
<p>在word2vec中，约定编码方式和常规不同，约定左子树编码为1,右子树编码为0,同时约定左子树的权重大于右子树的权重。</p>
<h2 id="基于Hierarchical-Softmax-的模型概述"><a href="#基于Hierarchical-Softmax-的模型概述" class="headerlink" title="基于Hierarchical Softmax 的模型概述"></a>基于Hierarchical Softmax 的模型概述</h2><p>word2vec在传统的神经网络词向量语言模型上做了改进：</p>
<ul>
<li>输入层到隐藏层的映射，没有采取神经网络的线性变换加激活函数的方法，而是采用了简单的对所有输入词向量求和并求取平均的方法。比如输入的是三个4维词向量：(1,2,3,4),(9,6,11,8),(5,10,7,12)(1,2,3,4),(9,6,11,8),(5,10,7,12),那么我们word2vec映射后的词向量就是(5,6,7,8)(5,6,7,8)。由于这里是从多个词向量变成了一个词向量。</li>
<li>隐藏层到输出的softmax层的计算量进行了改进，巍峨哦了避免计算所有词的softmax概率，word2vec采用了霍夫曼树来替代隐藏层到输出层的softmax层映射。</li>
</ul>
<p>由于之前要将输出softmax层的概率变成了一颗二叉霍夫曼树，那么我们的概率计算只要沿着树形结构计算就行了。</p>
<p>如图：我们可以沿着根节点一致走到我们的叶子节点的词$w_2$</p>
<p><img src="/images/word2vec/huffman-demo.png" alt="huffman-demo"></p>
<p>类比之前的NNLM，霍夫曼树的内部节点就类似之前的神经网络隐藏层的神经元，其中，根节点的词向量就对应我们投影后的词向量，而所有叶子节点就类似softmax输出层的神经元。叶子节点的个数就是词汇表的大小。</p>
<p>在霍夫曼树中，隐藏层到输出层的softmax映射不是一步完成的，而是沿着霍夫曼树一步步的完成的，因此，这种softmax被称为<code>Hierarchical Softmax</code>。</p>
<p>沿着霍夫曼树具体是如何操作？</p>
<p>在word2vec中，采用了二元logistic regression的方法，规定沿着左子树走，就是负类（霍夫曼编码为1），沿着右子树走，就是正类（霍夫曼树编码0）。判别正类和负类的方法就是使用sigmoid函数，即：</p>
<script type="math/tex; mode=display">
P(+) = \sigma(x_w^T\theta)=\frac{1}{1+e^{-x_w^T\theta}}</script><p>其中$x_w$就是当前内部节点的词向量，而$\theta$就是就是我们需要从训练样本得到的logistic regression的模型参数。</p>
<p>霍夫曼树的好处？</p>
<ul>
<li>由于是二叉树，之前的计算量是$V$，现在变成了$\log_2 V$。</li>
<li>高频词靠近词根，则高频词能够被更快的找到。符合贪心优化的思想。</li>
</ul>
<p>容易得到，被划分为左子树而成为负类的概率为$P(-)=1-P(+)$。在某个内部节点，判断沿左子树还是右子树走的依据就是看$P(-)$,$P(+)$谁的概率大。而控制两者概率大小的因素就是当前节点的<strong>词向量</strong>，另一个是当前节点的模型参数$\theta$。</p>
<p>对于上图的$w_2$，如果它是训练样本的输出，那么我们就期望对于隐藏节点$n(w_2,1)$的$P(-)$概率大，$n(w_2,2)$的$P(-)$概率大，$n(w_2,3)$的$P(+)$概率大。</p>
<h2 id="基于Hierarchical-Softmax-的模型梯度计算"><a href="#基于Hierarchical-Softmax-的模型梯度计算" class="headerlink" title="基于Hierarchical Softmax 的模型梯度计算"></a>基于Hierarchical Softmax 的模型梯度计算</h2><p>通过使用最大似然法来寻找所有节点的词向量和所有内部节点$\theta$。以上述的$w_2$为例，我们希望期望最大化下面的似然函数：</p>
<script type="math/tex; mode=display">
\prod_{i=1}^3P(n(w_2,i))=(1-\frac{1}{1+e^{-x_{w_2}^T\theta_1}})(1-\frac{1}{1+e^{-x_{w_2}^T\theta_2}})\frac{1}{1+e^{-x_{w_2}^T\theta_3}}</script><p>对于所有的训练样本，期望最大化所有样本的似然函数乘积。</p>
<p>为了简化描述，定义输入的词为$w$，其输入层词向量求和平均后的霍夫曼树的根节点词向量为$x_w$，从根节点到$w$所在的叶子节点，包含的节点总数为$l_w$，$w$在霍夫曼树中从根节点开始，经过的第$i$个节点表示为$p_i^w$，对应的霍夫曼编码为$d_i^w \in {0,1}$，其中$i=2,3,\cdots,l_w$。而该节点对应的模型参数表示为$\theta_i^w$，其中$i=1,2,\cdots,l_w-1$，没有$i=l_w$因为模型参数针对霍夫曼树的内部节点。</p>
<p>定义：$w$经过霍夫曼树某个节点$j$的逻辑回归概率为$P(d<em>j^w|x_w,\theta</em>{j-1}^w)$，其表达式为：</p>
<script type="math/tex; mode=display">
P(d_j^w|x_w,\theta_{j-1}^w) =
\begin{cases}
\sigma(x_w^T \theta_{j-1}^w) &d_j^w=0 \\
1- \sigma(x_w^T \theta_{j-1}^w) &d_j^w = 1
\end{cases}</script><p>对于某个目标输出词$w$，其最大似然为：</p>
<script type="math/tex; mode=display">
\prod_{j=2}^{l_w}P(d_j^w|x_w, \theta_{j-1}^w) = \prod_{j=2}^{l_w} [\sigma(x_w^T\theta_{j-1}^w)] ^{1-d_j^w}[1-\sigma(x_w^T\theta_{j-1}^w)]^{d_j^w}</script><p>由于word2vec中，使用SGD，并没有将所有样本的似然乘起来得到真正训练集最大似然，每次仅用一个样本更新，这样可以减少梯度计算量。</p>
<p>对应的对数似然函数$L$为：</p>
<script type="math/tex; mode=display">
L= log \prod_{j=2}^{l_w}P(d_j^w|x_w, \theta_{j-1}^w) = \sum\limits_{j=2}^{l_w} ((1-d_j^w) log [\sigma(x_w^T\theta_{j-1}^w)]  + d_j^w log[1-\sigma(x_w^T\theta_{j-1}^w)])</script><p>要得到模型中$w$的词向量和内部节点的模型参数$\theta$，可以使用梯度上升法。首先我们可以求模型参数$\theta_{j-1}^w$的梯度：</p>
<script type="math/tex; mode=display">
\begin{align} \frac{\partial L}{\partial \theta_{j-1}^w} & = (1-d_j^w)\frac{(\sigma(x_w^T\theta_{j-1}^w)(1-\sigma(x_w^T\theta_{j-1}^w)}{\sigma(x_w^T\theta_{j-1}^w)}x_w - d_j^w \frac{(\sigma(x_w^T\theta_{j-1}^w)(1-\sigma(x_w^T\theta_{j-1}^w)}{1- \sigma(x_w^T\theta_{j-1}^w)}x_w  \\ & =  (1-d_j^w)(1-\sigma(x_w^T\theta_{j-1}^w))x_w -  d_j^w\sigma(x_w^T\theta_{j-1}^w)x_w \\& = (1-d_j^w-\sigma(x_w^T\theta_{j-1}^w))x_w \end{align}</script><p>同样的方法，可以求得$x_w$的梯度表达式：</p>
<script type="math/tex; mode=display">
\frac{\partial L}{\partial x_w} = \sum\limits_{j=2}^{l_w}(1-d_j^w-\sigma(x_w^T\theta_{j-1}^w))\theta_{j-1}^w</script><h2 id="基于Hierarchical-Softmax的CBOW模型"><a href="#基于Hierarchical-Softmax的CBOW模型" class="headerlink" title="基于Hierarchical Softmax的CBOW模型"></a>基于Hierarchical Softmax的CBOW模型</h2><p>首先定义词向量的维度大小$M$，以及CBOW的上下文大小2c。这样对于训练样本中的每一个词，前面和后面的c个词作为CBOW模型的输入，该词本身作为样本的输出，期望softmax概率最大。</p>
<p>在使用CBOW模型之前，将词汇表建立成一棵霍夫曼树</p>
<p>第一步：从输入层到隐藏层（投影层）:</p>
<script type="math/tex; mode=display">
x_w=\frac{1}{2c}\sum\limits_{i=1}^{2c} x_i</script><p>第二部，通过梯度上升法来更新我们的$\theta_{j-1}^w$和$x_w$。虽然这边的$x_w$是由2c个词向量相加而成，梯度更新完毕后直接用梯度项更新原始的各个$x_i(i=1,2,\cdots,2c)$，即：</p>
<script type="math/tex; mode=display">
\theta_{j-1}^w = \theta_{j-1}^w + \eta  (1-d_j^w-\sigma(x_w^T\theta_{j-1}^w))x_w</script><script type="math/tex; mode=display">
x_i= x_i +\eta  \sum\limits_{j=2}^{l_w}(1-d_j^w-\sigma(x_w^T\theta_{j-1}^w))\theta_{j-1}^w \;(i =1,2..,2c)</script><p>其中$\eta$是梯度上升的步长。</p>
<p>整个算法流程如下：</p>
<p>输入：基于CBOW的语料训练样本，词向量的维度大小$M$，CBOW的上下文大小$2c$,步长$\eta$</p>
<p>输出：霍夫曼树的内部节点模型参数$\theta$，所有的词向量$w$</p>
<ol>
<li><p>基于语料训练样本建立霍夫曼树</p>
</li>
<li><p>随机初始化所有模型参数$\theta$，所有的词向量$w$</p>
</li>
<li><p>进行梯度上升迭代过程，对于训练中的每个样本$(context(w),w)$进行如下步骤：</p>
<ol>
<li><p>$e=0$，计算$x<em>w=\frac{1}{2c}\sum</em>{i=1}^{2c}x_i$</p>
</li>
<li><p>$for\;j=2\;to\;l_w$计算：</p>
<script type="math/tex; mode=display">
\begin{align}
f=\sigma(x_w^T\theta_{j-1}^w) \\
g=(1-d_j^w-f)\eta \\
e = e + g\theta_{j-1}^w \\
\theta_{j-1}^w = \theta_{j-1}^w + gx_w
\end{align}</script></li>
</ol>
</li>
</ol>
<ol>
<li>对于$context(w)$中的每个词向量$x_i$进行更新：<script type="math/tex; mode=display">
x_i=x_i+e</script></li>
</ol>
<ol>
<li>如果梯度收敛，则结束梯度迭代，否则回到步骤3继续迭代。</li>
</ol>
<h2 id="基于Hierarchical-Softmax-的-Skip-Gram模型"><a href="#基于Hierarchical-Softmax-的-Skip-Gram模型" class="headerlink" title="基于Hierarchical Softmax 的 Skip-Gram模型"></a>基于Hierarchical Softmax 的 Skip-Gram模型</h2><p>此时输入为一个词$w$，输出的为$2c$个词向量$context(w)$。</p>
<p>对于训练样本中的每一个词，该词本身作为样本的输入，其前面和后面的$c$个词作为Skip-Gram模型的输出，期望这些词的softmax概率比其他的词大。</p>
<p>首先，将词汇表建立乘一棵霍夫曼树</p>
<p>对于输入层到隐藏层（投影层），由于只有一个词，所以$x_w$就是词$w$对应的词向量。</p>
<p>然后，通过梯度上升法来更新我们的$\theta_{j-1}$和$x_w$。</p>
<p>注意：这里的$x_w$周围有$2c$个词向量，如果我们期望$P(x_i|x_w),i=1,2,\cdots,2c$最大。我们可以注意到由于上下文是相互的，在期望$P(x_i|x_w),i=1,2,\cdots,2c$最大化的同时，反过来我们也期望$P(x_w|x_i),i=1,2,\cdots,2c$最大。那么这两种究竟是那个更好呢？</p>
<p>word2vec使用了后者，这样的做的优点，在一个迭代窗口内，我们不只是更新$x_w$一个词，而是$x_i,i=1,2,\cdots,2c$个词。这样整个迭代会更加均衡。因此，Skip-Gram没有和CBOW一样对输入进行迭代更新，而是对$2c$个输出进行迭代更新。</p>
<p>Hierarchical Softmax的缺点：当训练样本中的一个中心词$w$是一个很生僻的词，那么就需要在霍夫曼树往下走很久了。</p>
<h2 id="基于Negative-Sampling的模型概述"><a href="#基于Negative-Sampling的模型概述" class="headerlink" title="基于Negative Sampling的模型概述"></a>基于Negative Sampling的模型概述</h2><p>Negative Sampling （负采样）</p>
<p>假设有一个训练样本，中心词是$w$，它的周围上下文共有$2c$个词，记为$context(w)$。由于这个中心词$w$，和$context(w)$相关存在，因此它是一个真实的正例。</p>
<p>通过Negative Sampling采样，可以得到neg个和$w$不同的中心词$w_i,i=1,2,\cdots,neg$，这样$context(w)$和$w_i$就组成neg并不真实存在的负例。利用这个正例和neg个负例进行二元logistic regression。得到负采样对应每个词$w_i$对应的模型参数$\theta_i$和每个词的词向量。</p>
<p>两个问题：</p>
<ul>
<li>如何通过一个正例和neg个负例进行二元logistic regression</li>
<li>如何进行负采样</li>
</ul>
<h2 id="基于Negative-Sampling-的模型梯度计算"><a href="#基于Negative-Sampling-的模型梯度计算" class="headerlink" title="基于Negative Sampling 的模型梯度计算"></a>基于Negative Sampling 的模型梯度计算</h2><p>Negative Sampling 也是采用了二元逻辑回归来求解参数。</p>
<p>通过负采样得到neg个负例$(context(w),w_i)i=1,2,\cdots,neg$。</p>
<p>将正例定义为$w_0$。</p>
<p>在期望回归中，正例应该期望满足：</p>
<script type="math/tex; mode=display">
P(context(w_0), w_i) = \sigma(x_{w_0}^T\theta^{w_i}) ,y_i=1, i=0</script><p>负例期望满足：</p>
<script type="math/tex; mode=display">
P(context(w_0), w_i) =1-  \sigma(x_{w_0}^T\theta^{w_i}), y_i = 0, i=1,2,..neg</script><p>因此可以期望最大化下式：</p>
<script type="math/tex; mode=display">
\prod_{i=0}^{neg}P(context(w_0), w_i) = \sigma(x_{w_0}^T\theta^{w_0})\prod_{i=1}^{neg}(1-  \sigma(x_{w_0}^T\theta^{w_i}))</script><p>相应的对数似然函数为：</p>
<script type="math/tex; mode=display">
L = \sum\limits_{i=0}^{neg}y_i log(\sigma(x_{w_0}^T\theta^{w_i})) + (1-y_i) log(1-  \sigma(x_{w_0}^T\theta^{w_i}))</script><p>和Hierarchical Sofrmax类似，采用SGD，这里我们需要求出$x_{w_0},\theta^{w_i},i=0,1,2,\cdots,neg$的梯度。</p>
<p>计算$\theta^{w_i}$的梯度：</p>
<script type="math/tex; mode=display">
\begin{align} \frac{\partial L}{\partial \theta^{w_i} } &= y_i(1-  \sigma(x_{w_0}^T\theta^{w_i}))x_{w_0}-(1-y_i)\sigma(x_{w_0}^T\theta^{w_i})x_{w_0} \\ & = (y_i -\sigma(x_{w_0}^T\theta^{w_i})) x_{w_0} \end{align}</script><p>对应的$x_{w_0}$的梯度：</p>
<script type="math/tex; mode=display">
\frac{\partial L}{\partial x^{w_0} } = \sum\limits_{i=0}^{neg}(y_i -\sigma(x_{w_0}^T\theta^{w_i}))\theta^{w_i}</script><h2 id="Negative-Sampling负采样方法"><a href="#Negative-Sampling负采样方法" class="headerlink" title="Negative Sampling负采样方法"></a>Negative Sampling负采样方法</h2><p>如果词汇表的大小为$V$，那么将一段长度为1的线段分成$V$份，每份对应词汇表中的一个词。当然每个词对应的线段长度是不一样的，高频词对应的线段长，低频词对应的线段短。每个词$w$的线段长度由下决定：</p>
<script type="math/tex; mode=display">
len(w) = \frac{count(w)}{\sum\limits_{u \in vocab} count(u)}</script><p>在word2vec中，分子分母取了$3/4$次幂:</p>
<script type="math/tex; mode=display">
len(w) = \frac{count(w)^{3/4}}{\sum\limits_{u \in vocab} count(u)^{3/4}}</script><p>采样前，将长度为1的线段划分乘$M$等份，$M&gt;&gt;V$，这样就可以确保每个词对应的线段都会划分成对应的小块。而$M$份中的每一份都会落到某一个词对应的线段上。采样的时候，只需要从$M$个位置中采样出neg个位置，此时采样到的每个位置对应的线段所属的词就是我们的负例词。</p>
<p>word2vec中，$M=10^8$</p>
<h2 id="基于Negative-Sampling-的CBOW模型"><a href="#基于Negative-Sampling-的CBOW模型" class="headerlink" title="基于Negative Sampling 的CBOW模型"></a>基于Negative Sampling 的CBOW模型</h2><p>输入：基于CBOW的语料训练样本，词向量维度大小为$M$，CBOW的上下文大小$2c$，步长为$\eta$，负采样的个数$neg$</p>
<p>输出：词汇表中每个词对应的模型参数$\theta$，所有的词向量$x_w$</p>
<ol>
<li><p>随机初始化所有模型参数$\theta$，所有的词向量$w$</p>
</li>
<li><p>对于每个训练样本$(context(w_0),w_0)$，负采样出neg个负例中心词$w_i,i=1,2,\cdots,neg$</p>
</li>
<li><p>进行梯度上升迭代过程，对于训练集中的每个样本$(context(w<em>0),w_0,w_1,\cdots,w</em>{neg})$做如下处理</p>
<ol>
<li><p>$e=0$，计算$x<em>{w_0}=\frac{1}{2c}\sum\limits</em>{i=1}^{2c}x_i$</p>
</li>
<li><p>$for\;i=0\;to\;neg$，计算：</p>
<script type="math/tex; mode=display">
\begin{align}
f=\sigma(x_{w_0}^T\theta^{w_i})\\
g=(y_i-f)\eta \\
e=e+g\theta^{w_i} \\
\theta^{w_i} = \theta^{w_i} + gx_{w_0}
\end{align}</script></li>
</ol>
</li>
</ol>
<ol>
<li>对于$context(w)$中的每个词向量$x_k$（2c个）进行更新：<script type="math/tex; mode=display">
x_k = x_k +e</script></li>
</ol>
<ol>
<li>如果梯度收敛，则结束迭代，否则回到步骤3继续迭代。</li>
</ol>
<h2 id="基于Negative-Sampling-Skip-Gram模型"><a href="#基于Negative-Sampling-Skip-Gram模型" class="headerlink" title="基于Negative Sampling Skip-Gram模型"></a>基于Negative Sampling Skip-Gram模型</h2><p>输入：基于Skip-Gram的语料训练样本，词向量的维度大小$Mcount$，Skip-Gram的上下文大小$2c$,步长$\eta$， , 负采样的个数neg。</p>
<p>输出：词汇表每个词对应的模型参数$\theta$，所有的词向量$x_w$</p>
<ol>
<li><p>随机初始化所有的模型参数θθ，所有的词向量$w$</p>
</li>
<li><p>对于每个训练样本$(context(w_0),w_0)$，负采样出neg个负例中心词$w_i,i=1,2,…neg$</p>
</li>
<li><p>进行梯度上升迭代过程，对于训练集中的每一个样本$(context(w<em>0),w_0,w_1,…w</em>{neg})$做如下处理：</p>
<ol>
<li><p>$for\;i=1\;to\;2c:$</p>
<ol>
<li><p>$e=0$</p>
</li>
<li><p>$for\;j=0\;to\;neg$，计算：</p>
<script type="math/tex; mode=display">
\begin{align}
f=\sigma(x_{w_{0i}}^T\theta^{w_j})\\
g=(y_j-f)\eta \\
e =e + g\theta^{w_j} \\
\theta^{w_j} = \theta^{w_j} + gx_{w_{0i}}
\end{align}</script></li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code>     3. 词向量更新：
        $$
        x_{w_{0i}} = x_{w_{0i}} + e
        $$

　2. 如果梯度收敛，则结束迭代，否则继续步骤3.
</code></pre>]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title>git提交格式</title>
    <url>/2020/02/09/git%E6%8F%90%E4%BA%A4%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Git-提交格式"><a href="#Git-提交格式" class="headerlink" title="Git 提交格式"></a>Git 提交格式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>前段时间从网络上看到一张图片，图片描述的是对Git提交Action中message的格式建议。因此，整理下便于未来时常回顾。</p>
</blockquote>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>格式如下，其中type用于描述代码变化的类型，Scope描述代码修改的范围，Subject简短的描述变化的内容</p>
<p><code>type(scope): subject</code></p>
<p><code>BODY(Optional)</code></p>
<p><code>FOOTER(Optional)</code></p>
<h2 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h2><ul>
<li>feat - 一个新的特性</li>
<li>fix - Bug的解决</li>
<li>docs - 文档的改变</li>
<li>style - 样式的改变，格式改变，删除空格或冒号等</li>
<li>refactor - 修改代码，不是为了解决bug或增加新特性。重构</li>
<li>perf - 改善software行为</li>
<li>chore - 改变构建的流程</li>
</ul>
<h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><p>一个短语用于描述被改变的代码的部分。例如“（userservice）”</p>
<h2 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h2><p>对改变的部分作一个间断的描述</p>
<h2 id="Body-optional"><a href="#Body-optional" class="headerlink" title="Body(optional)"></a>Body(optional)</h2><p>在Subject 下面增加空行，然后开始描述额外的上下文信息。</p>
<h2 id="Footer-optional"><a href="#Footer-optional" class="headerlink" title="Footer(optional)"></a>Footer(optional)</h2><p>用于参考受代码更改影响的问题，例如 “Fixes # 13”</p>
<h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><p><img src="/images/Git_Commit_Format.jpg" alt=""></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Linux系统常用命令</title>
    <url>/2019/06/28/command_of_Linux/</url>
    <content><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><blockquote>
<p>Linux 系统下的命令</p>
</blockquote>
<a id="more"></a>
<h2 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h2><ul>
<li>fdisk -l  查看当前分区挂载信息</li>
<li>mkfs  mke2fs 格式化一个未格式化的分区</li>
<li>mount /dev/**  data/   挂载这个设备到 data目录上</li>
<li>umount /dev/** 卸载设备</li>
<li>ls -s -S -a -l -t -F filename  查看文件和文件夹信息</li>
<li>cd</li>
<li>pwd 显示当前所在目录</li>
<li>mkdir 创建一个文件夹</li>
<li>rmdir 删除一个文件</li>
<li>touch 创建一个文件</li>
<li>cat -a -n -b -s 显示文件内容</li>
<li>cat file.txt | ls 分页显示</li>
<li>cat &gt; 文件名 在命令行里输入文件内容 Cirl+D 退出</li>
<li>cat file1 file2 &gt; file3 把file1和file2 输入到file3</li>
<li>cat file2 &gt;&gt; file1 给文件file1 追加内容</li>
<li>cp  f1 f2 文件复制 -i 安全访问的复制</li>
<li>rm 文件/目录  删除文件 -i -r 递归处理 -f 强制删除 -v 显示执行过程 -d 直接吧目录的硬链接数据删成0</li>
<li>mv 文件移动</li>
<li><p>chmod +/-/= 权限类型 文件1  文件2 。。。</p>
<pre><code>  1. + 增加权限 -去除权限 =给予指定权限 删除其他权限
  2. r读w写x可执行
  3. u/g/o/a 所有者/所在组/其他用户/所有用户  a+rw 所有用户读写权限  ug+r 所有者和组增加读权限
</code></pre></li>
<li><p>grep 查找指定文件字符串 -i 不区分大小写</p>
</li>
<li>head -2 file 显示文件前两行内容</li>
<li>tail -1 file 显示文件最后一行内容</li>
<li>wc -l 显示行数 -w显示单词书 -m显示字符数 统计文件的行数单词数和字符数</li>
<li>sort 对文件内容进行排序</li>
<li>sort -t”:” -k2 file 指定每列的分隔符为：，根据文件的第二列排序输出</li>
<li>find file/dir  查看当前目录下的文件和目录</li>
<li>which 命令 查看命令所在的目录</li>
<li>whereis 文件名 查找可执行的命令和包含该文件名的字符串</li>
<li>locate 文件名 查找文件</li>
<li>bzip2 file1 file2 ..压缩命令</li>
<li>bunzip2 文件名 解压命令</li>
<li>gzip 文件压缩解压命令 -d 解压</li>
<li>unzip 解压.zip文件 -d 解压到指定目录 -n 不覆盖原来存在的文件 -v查看文件目录不解压 -o以默认方式覆盖已经存在的文件</li>
<li>zcat 和 bzcat 查看压缩文件内容 不解压</li>
<li>zcat 文件名  查看.gz 文件</li>
<li>bzcat 文件名 查看.bz2 文件</li>
<li>tar 命令 对文件和目录进行打包</li>
<li>tar [-选项] [备份的文件名] [要打包的目录或文件]</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>创建新的打包文件</td>
</tr>
<tr>
<td>-x</td>
<td>抽取.tar 文件的内容</td>
</tr>
<tr>
<td>-z</td>
<td>打包后用gzip压缩或者解压</td>
</tr>
<tr>
<td>-j</td>
<td>就打包后用bzip2进行压缩或者解压操作</td>
</tr>
<tr>
<td>-t</td>
<td>查看一个打包文件的目录</td>
</tr>
<tr>
<td>-f</td>
<td>使用文件或设备</td>
</tr>
<tr>
<td>-v</td>
<td>在压缩或解压后显示详细的文件清单</td>
</tr>
</tbody>
</table>
</div>
<h2 id="磁盘内容"><a href="#磁盘内容" class="headerlink" title="　磁盘内容"></a>　磁盘内容</h2><ul>
<li><p>mount</p>
<p>  mount -t 文件类型 -o 挂接方式 device path</p>
</li>
</ul>
<blockquote>
<p>-t iso9660/ntfs/msdos/smbfs/vfat/nfs -o loop(将文件当作硬盘分区挂接到系统)/iocharset(指定访问的文件<br>系统的字符集)/ro 采用只读的方式挂接/device 要挂接的设备 /rw 采用读写挂接 /dir 设备在系统的挂接点</p>
</blockquote>
<p>光盘文件的挂接</p>
<pre><code>mount -o loop -t iso9660 /ss.iso /mnt/ss
</code></pre><ul>
<li>fdisk -l 查看系统的硬盘和硬盘分区情况</li>
<li>umount 挂载点或设备 卸载一个设备</li>
<li>df 查看当前硬盘的分区信息</li>
<li>df -a 显示所有文件分区和硬盘</li>
<li>df -i 列出i-nodes的使用量</li>
<li>df -k 大小以KB为单位</li>
<li>df -h MB</li>
<li>df -t 列出某个文件系统的分区磁盘使用情况</li>
<li>df -x 列出不是某个文件系统分区磁盘的使用情况</li>
<li><p>df -t 列出每个分区所属文件系统的名称</p>
</li>
<li><p>du 命令 查看当前目录下所有文件和目录的信息</p>
</li>
</ul>
<blockquote>
<p>-a -h -b -c最后加上总计 -s列出各文件大小的总和 -x值计算属于同一个文件系统的文件</p>
</blockquote>
<ul>
<li><p>fsck 分区名 硬盘检测 只能由root使用</p>
</li>
<li><p>shutdown [选项] [时间] [警告信息]</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-h</td>
<td>关闭系统服务安全关机</td>
</tr>
<tr>
<td>-k</td>
<td>不关机只发出警告信息</td>
</tr>
<tr>
<td>-r</td>
<td>通知服务后重启</td>
</tr>
<tr>
<td>-t</td>
<td>在规定的时间关机</td>
</tr>
</tbody>
</table>
</div>
<pre><code>shutdown -h +2 两分钟后关机
</code></pre><ul>
<li>half 关机 ==shutdown -h</li>
<li><p>half -f 强制关机</p>
</li>
<li><p>poweroff 关机</p>
</li>
<li><p>reboot 重启</p>
</li>
<li><p>init 命令 切换ubuntu的运行级别</p>
</li>
<li>init [0-7] 0代表关机 6代表重新启动</li>
</ul>
<h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2><ul>
<li>echo [选项] [字符串] 显示命令行中的字符串 用于输出提示信息</li>
</ul>
<blockquote>
<p>-n 输出字符串 光标不换行</p>
</blockquote>
<h3 id="more命令和less命令"><a href="#more命令和less命令" class="headerlink" title="more命令和less命令"></a>more命令和less命令</h3><blockquote>
<p>对文件内容或查询结果进行分屏显示</p>
</blockquote>
<ul>
<li>more [选项] file</li>
<li>less [选项] file</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-p</td>
<td>不滚动，清屏</td>
</tr>
<tr>
<td>+n</td>
<td>从第n行开始</td>
</tr>
<tr>
<td>-s</td>
<td>将连续的空行压缩成一个空格</td>
</tr>
</tbody>
</table>
</div>
<h3 id="help命令和man命令"><a href="#help命令和man命令" class="headerlink" title="help命令和man命令"></a>help命令和man命令</h3><blockquote>
<p>显示某个命令的格式用法</p>
</blockquote>
<ul>
<li><p>help/man 命令</p>
</li>
<li><p>cal 显示日历</p>
</li>
<li>cal [选项]  -m 以星期一为每周的第一天显示 -y 显示今年年历 -就以凯撒历显示</li>
<li>cal 当前月</li>
<li>cal 2000 2000年年历</li>
<li><p>cal 5 2000 2000年5月</p>
</li>
<li><p>date命令 显示和设定系统的时间日期</p>
</li>
<li><p>ps [选项]查看进程信息</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-e</td>
<td>显示所有进程</td>
</tr>
<tr>
<td>a</td>
<td>显示所有终端下的进程</td>
</tr>
<tr>
<td>-f</td>
<td>以全格式显示</td>
</tr>
<tr>
<td>u</td>
<td>面向用户的格式显示</td>
</tr>
<tr>
<td>-r</td>
<td>显示正在运行的进程</td>
</tr>
<tr>
<td>x</td>
<td>显示所有不控制终端的进程</td>
</tr>
<tr>
<td>-o</td>
<td>以用户定义的格式显示</td>
</tr>
<tr>
<td>-l</td>
<td>查看当前用户进程的优先级</td>
</tr>
</tbody>
</table>
</div>
<p>nice 命令</p>
<blockquote>
<p>改变进程优先级</p>
</blockquote>
<ul>
<li><p>nice [选项] -n为-20-19的值 值越小优先级越高</p>
<p>  nice -10</p>
</li>
<li><p>renice [+/-n] [-g 命令名] [-p 进程标识码] [-u 进程所有者]</p>
</li>
<li><p>fg 命令 使挂起的进程返回前台执行 fg n 代表进程序号</p>
</li>
<li><p>bg 命令 激活被挂起的进程，使之在后台运行</p>
</li>
<li><p>kill [-信号] PID 终止进程</p>
</li>
<li><p>top 命令 监视系统进程</p>
</li>
<li>top [选项]</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>c</td>
<td>显示整个命令行</td>
</tr>
<tr>
<td>d</td>
<td>指定屏幕刷新秒数，默认3s刷新一次</td>
</tr>
<tr>
<td>i</td>
<td>不显示任何闲置或僵死的进程</td>
</tr>
<tr>
<td>n</td>
<td>指定每秒内监控信息的更新次数</td>
</tr>
<tr>
<td>p</td>
<td>进程标识码列表</td>
</tr>
<tr>
<td>s</td>
<td>是top在安全模式下运行</td>
</tr>
<tr>
<td>S</td>
<td>使用累计模式</td>
</tr>
</tbody>
</table>
</div>
<p>last 命令 列出目前与过去登陆系统用户的信息</p>
<ul>
<li>last [-adRx] [-f] [-n] [账号名称] [终端机标号]</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>把从何处登入系统的主机名称或IP地址显示在最后一行</td>
</tr>
<tr>
<td>-d</td>
<td>把地址转换成主机名称</td>
</tr>
<tr>
<td>-f</td>
<td>指定记录文件</td>
</tr>
<tr>
<td>-n</td>
<td>设置列出名单的显示列数</td>
</tr>
<tr>
<td>-R</td>
<td>不显示登入系统的主机名称或IP</td>
</tr>
<tr>
<td>-x</td>
<td>显示系统关机，重新开机以及执行等级改变等信息</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>free 查看系统内存情况 -m 以MB显示</li>
</ul>
<p>增加用户</p>
<pre><code>useradd [-u uid] [-g group] [-d home_dir] [-s shell] [-c comment] [-m
[-k skeldir]] [-N] [-f incavtive] [-e expire] login`
</code></pre><blockquote>
<p>例子：增加一个jack用户，指定宿主目录为/home/jack shell为/bin/bash</p>
</blockquote>
<pre><code>sudo useradd -u 1001 -d /home/jack -m -s /bin/bash jack
</code></pre><p>增加成功，但是还不能登入系统，因为没有密码</p>
<pre><code>sudo passwd jack 设置jack密码
</code></pre><ul>
<li>userdel 删除用户信息</li>
<li>userdel [-r] login</li>
</ul>
<p><code>userdel -r jack 删除jack用户</code></p>
<p>groupadd 组增加 groupdel 组删除</p>
<ul>
<li>sudo passwd root 给root重设密码 激活root</li>
<li>su root 切换到root</li>
<li><p>sudo passwd -l root 锁定root</p>
</li>
<li><p>sudo 命令既super do 指以超级管理员的身份执行</p>
</li>
<li>passwd  用户  修改用户密码</li>
<li>su 用户 切换用户 su root 当前root激活可以切换</li>
</ul>
<h3 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h3><ul>
<li>apt-get 命令</li>
<li>aptitude 命令</li>
</ul>
<p><code>sudo apt-get dist-upgrade 更新所有软件</code></p>
<h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><ul>
<li>ifconfig 不带参数的显示当前网卡信息</li>
</ul>
<blockquote>
<p>修改网卡地址: ifconfig 设备名称 IP地址  netmask 子网掩码</p>
</blockquote>
<pre><code>sudo ifconfig eth12 192.168.157.141 netmask 255.255.255.0
</code></pre><ul>
<li>DNS 配置 cat /etc/resolv.conf</li>
<li><p>HOST cat /etc/hosts</p>
</li>
<li><p>hostname 命令修改和显示主机名 -i 显示IP</p>
</li>
</ul>
<h3 id="网路命令"><a href="#网路命令" class="headerlink" title="网路命令"></a>网路命令</h3><ul>
<li>ifconfig -interface [options] address</li>
</ul>
<blockquote>
<p>-interface 指定网络接口名如 eth0、eth1</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>up</td>
<td>激活指定的网络接口</td>
</tr>
<tr>
<td>down</td>
<td>关闭指定网络接口</td>
</tr>
<tr>
<td>broadcast address</td>
<td>设置接口广播地址</td>
</tr>
<tr>
<td>pointopoint</td>
<td>启用点对点方式</td>
</tr>
<tr>
<td>address</td>
<td>设置指定接口设备IP地址</td>
</tr>
<tr>
<td>netmask address</td>
<td>设置接口子网掩码</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>ping命令 测试主机网络是否畅通</li>
</ul>
<p><code>ping [选项] 主机名或IP</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>设置响应次数</td>
</tr>
<tr>
<td>-d</td>
<td>使用Socket的SO_DEBUG功能</td>
</tr>
<tr>
<td>-f</td>
<td>极限检查</td>
</tr>
<tr>
<td>-i</td>
<td>指定收发时间间隔单位为s</td>
</tr>
<tr>
<td>-s</td>
<td>byte 设置数据包大小</td>
</tr>
<tr>
<td>-R</td>
<td>记录路由过程</td>
</tr>
<tr>
<td>-r</td>
<td>忽略普通的路由表直接发送到远程主机</td>
</tr>
<tr>
<td>-p</td>
<td>设置填满数据包的范本样式</td>
</tr>
<tr>
<td>-q</td>
<td>不显示命令的执行过程只显示结果</td>
</tr>
<tr>
<td>-t</td>
<td>设置存活数值TTL</td>
</tr>
<tr>
<td>-v</td>
<td>详细显示命令的执行过程</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>netstat 命令 检查网络端口的连接情况</li>
</ul>
<p>netstat [选项]</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>显示所有有效的连接信息</td>
</tr>
<tr>
<td>-r</td>
<td>显示路由的信息</td>
</tr>
<tr>
<td>-i</td>
<td>显示interface网络界面信息的内容</td>
</tr>
<tr>
<td>-n</td>
<td>使用IP代替名称，显示网络情况</td>
</tr>
<tr>
<td>-o</td>
<td>显示计时器</td>
</tr>
<tr>
<td>-h</td>
<td>在线帮助</td>
</tr>
<tr>
<td>-c</td>
<td>持续列出网络状态</td>
</tr>
<tr>
<td>-t</td>
<td>显示TCP连接情况</td>
</tr>
<tr>
<td>-u</td>
<td>显示UDP连接情况</td>
</tr>
<tr>
<td>-v</td>
<td>显示命令执行过程</td>
</tr>
<tr>
<td>-w</td>
<td>显示RAW传输协议连接情况</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>ftp命令和bye命令</li>
</ul>
<blockquote>
<p>ftp 登录FTP服务器，该命令允许用户使用FTP协议进行文件的传输，文件的上传和下载</p>
</blockquote>
<pre><code>ftp 主机名/IP
</code></pre><blockquote>
<p>bye 退出ftp服务器</p>
</blockquote>
<p>ftp 内部命令<br>|||<br>|—-|—-|<br>|ls|列出远程机的当前目录|<br>|cd|改变远程机的工作目录|<br>|lcd|改变本地的工作目录|<br>|close|终止当前的ftp命令|<br>|hash|每次传输完数据缓冲区的数据就显示一个#号|<br>|get|从远程机传送指定文件到本机|<br>|put|从本地传送指定文件到远程机|<br>|quit|断开与远程机的连接，退出ftp|</p>
<ul>
<li>telnet 命令logout命令</li>
</ul>
<p><code>telnet [选项] 主机名/IP地址</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>尝试自动登录远端系统</td>
</tr>
<tr>
<td>-c</td>
<td>不读取用户专属目录里的.telentrc文件</td>
</tr>
<tr>
<td>-8</td>
<td>允许使用8位字符资料，包括输入输出</td>
</tr>
<tr>
<td>-l</td>
<td>指定要登录远端计算机的用户名称</td>
</tr>
<tr>
<td>-b</td>
<td>使用别名指定远端主机的名称</td>
</tr>
<tr>
<td>-n</td>
<td>指定文件记录相关信息</td>
</tr>
</tbody>
</table>
</div>
<p>logout 下线命令</p>
<ul>
<li>rlogin 命令 远程登录</li>
</ul>
<p><code>rlogin 主机名/IP地址</code></p>
<ul>
<li>route命令 表示手工修改产生和查看路由表</li>
</ul>
<p><code>route [选项] targetaddress [选项]</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-add</td>
<td>增加路由</td>
</tr>
<tr>
<td>-delete</td>
<td>删除路由</td>
</tr>
<tr>
<td>-net</td>
<td>路由到达的是一个网络，而不是一台主机</td>
</tr>
<tr>
<td>-host</td>
<td>路由到达的是一台主机</td>
</tr>
<tr>
<td>-netmask Nm</td>
<td>指定路由的子网掩码</td>
</tr>
<tr>
<td>gw</td>
<td>指定路由的网关</td>
</tr>
<tr>
<td>[dev]If</td>
<td>强迫路由连接指定接口</td>
</tr>
</tbody>
</table>
</div>
<p>例子：为了访问网络，必须把计算机的IP地址设置成Linux的默认路由，增加一个路由<br>route add 0.0.0.0 1 Array 192.168.1.1</p>
<ul>
<li>finger 命令 用来查询一台主机上的登录帐号的信息，通常会显示用户名名，主目录，停滞时间，登录时间，登录Shell等</li>
</ul>
<p><code>finger [选项] [使用者] [用户名@主机名]</code><br>-s -l -p</p>
<ul>
<li>mail 命令 发送邮件</li>
</ul>
<p>Mail [-s subject] [-c address] [-b address] mail -f [mailbox]mail [-u user]</p>
<h3 id="Curl"><a href="#Curl" class="headerlink" title="Curl"></a>Curl</h3><pre><code>curl -I 网址   //返回响应头
curl -A testagent 网址 //代理访问
curl -e 网址1 网址2 //伪装网址的来源
curl -i 网址 //在返回的数据中显示响应头
curl --cacert CA证书 网址
curl -v 网址 //显示一次请求的过程
curl -X POST 网址 //指定访问网址的方式
</code></pre><h3 id="Tool-Command"><a href="#Tool-Command" class="headerlink" title="Tool Command"></a>Tool Command</h3><p>清除卸载后的配置文件</p>
<pre><code>dpkg -l |grep ^rc|awk &#39;{print $2}&#39; |sudo xargs dpkg -P
</code></pre><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>使用权限 : 所有使用者</p>
<p>使用方式 :<code>chmod [-cfvR] [--help] [--version] mode file...</code></p>
<p>说明 :</p>
<blockquote>
<p>Linux/Unix 的档案调用权限分为三级 : 档案拥有者、群组、其他。利用 chmod 可以藉以控制档案如何被他人所调用。</p>
</blockquote>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>mode : 权限设定字串</p>
<p>格式如下 : <code>[ugoa...][[+-=][rwxX]...][,...]</code>，其中</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>u</td>
<td>表示该档案的拥有者</td>
</tr>
<tr>
<td>g</td>
<td>表示与该档案的拥有者属于同一个群体(group)者</td>
</tr>
<tr>
<td>o</td>
<td>表示其他以外的人</td>
</tr>
<tr>
<td>a</td>
<td>表示这三者皆是。</td>
</tr>
<tr>
<td>+</td>
<td>表示增加权限</td>
</tr>
<tr>
<td>-</td>
<td>表示取消权限</td>
</tr>
<tr>
<td>-</td>
<td>= 表示唯一设定权限。</td>
</tr>
<tr>
<td>r</td>
<td>表示可读取</td>
</tr>
<tr>
<td>w</td>
<td>表示可写入</td>
</tr>
<tr>
<td>x</td>
<td>表示可执行</td>
</tr>
<tr>
<td>X</td>
<td>表示只有当该档案是个子目录或者该档案已经被设定过为可执行。</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-c</td>
<td>若该档案权限确实已经更改，才显示其更改动作</td>
</tr>
<tr>
<td>-f</td>
<td>若该档案权限无法被更改也不要显示错误讯息</td>
</tr>
<tr>
<td>-v</td>
<td>显示权限变更的详细资料</td>
</tr>
<tr>
<td>-R</td>
<td>对目前目录下的所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更)</td>
</tr>
<tr>
<td>—help</td>
<td>显示辅助说明</td>
</tr>
<tr>
<td>—version</td>
<td>显示版本</td>
</tr>
</tbody>
</table>
</div>
<p>范例 :将档案 file1.txt 设为所有人皆可读取 :<br><code>chmod ugo+r file1.txt</code></p>
<p>将档案 file1.txt 设为所有人皆可读取:<br><code>chmod a+r file1.txt</code></p>
<p>将档案 file1.txt 与 file2.txt 设为该档案拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入:<br><code>chmod ug+w,o-w file1.txt file2.txt</code></p>
<p>将 ex1.py 设定为只有该档案拥有者可以执行:<br><code>chmod u+x ex1.py</code></p>
<p>将目前目录下的所有档案与子目录皆设为任何人可读取<br><code>chmod -R a+r *</code></p>
<p>此外chmod也可以用数字来表示权限如 chmod 777 file<br>语法为：<code>chmod abc file</code></p>
<p>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。</p>
<p>r=4，w=2，x=1<br>若要rwx属性则4+2+1=7；<br>若要rw-属性则4+2=6；<br>若要r-x属性则4+1=5。</p>
<p>范例：<br><code>chmod a=rwx file</code>和<code>chmod 777 file</code>效果相同</p>
<p><code>chmod ug=rwx,o=x file</code>和<code>chmod 771 file</code>效果相同</p>
<p>若用chmod 4755 filename可使此程序具有root的权限.</p>
<h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>使用权限 : root</p>
<p>使用方式 : <code>chmod [-cfhvR] [--help] [--version] user[] file...</code></p>
<blockquote>
<p>Linux/Unix 是多人多工作业系统，所有的档案皆有拥有者。利用 chown 可以将档案的拥有者加以改变。一般来说，这个指令只有是由 系统管理者(root)所使用，<br>一般使用者没有权限可以改变别人的档案拥有者，也没有权限可以自己的档案拥有者改设为别人。只有系统管理者(root)才 有这样的权限。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>user</td>
<td>新的档案拥有者的使用者</td>
</tr>
<tr>
<td>IDgroup</td>
<td>新的档案拥有者的使用者群体(group)</td>
</tr>
<tr>
<td>-c</td>
<td>若该档案拥有者确实已经更改，才显示其更改动作</td>
</tr>
<tr>
<td>-f</td>
<td>若该档案拥有者无法被更改也不要显示错误讯息</td>
</tr>
<tr>
<td>-h</td>
<td>只对于连结 (link)进行变更，而非该 link 真正指向的档案</td>
</tr>
<tr>
<td>-v</td>
<td>显示拥有者变更的详细资料</td>
</tr>
<tr>
<td>-R</td>
<td>对目前目录下的所有档案与子目录进行相同的拥有者 变更(即以递回的方式逐个变更)</td>
</tr>
<tr>
<td>—help</td>
<td>显示辅助说明</td>
</tr>
<tr>
<td>—version</td>
<td>显示版本</td>
</tr>
</tbody>
</table>
</div>
<p>范例 :<br>将档案 file1.txt 的拥有者设为 users 群体的使用者 jessie :</p>
<p><code>chown jessie:users file1.txt</code></p>
<p>将目前目录下的所有档案与子目录的拥有者皆设为 users 群体的使用者 lamport :</p>
<p><code>chmod -R lamport:users *</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>-rw———- (600)</td>
<td>只有属主有读写权限。</td>
</tr>
<tr>
<td>-rw-r—r— (644)</td>
<td>只有属主有读写权限；而属组用户和其他用户只有读权限。</td>
</tr>
<tr>
<td>-rwx——— (700)</td>
<td>只有属主有读、写、执行权限。</td>
</tr>
<tr>
<td>-rwxr-xr-x (755)</td>
<td>属主有读、写、执行权限；而属组用户和其他用户只有读、执行权限。</td>
</tr>
</tbody>
</table>
</div>
<p>-rwx—x—x (711)|属主有读、写、执行权限；而属组用户和其他用户只有执行权限。<br>|-rw-rw-rw- (666)|所有用户都有文件读、写权限。这种做法不可取。|<br>|-rwxrwxrwx (777)|所有用户都有读、写、执行权限。更不可取的做法。|</p>
<p>以下是对目录的两个普通设定:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>drwx——— (700)</td>
<td>只有属主可在目录中读、写。</td>
</tr>
<tr>
<td>drwxr-xr-x (755)</td>
<td>所有用户可读该目录，但只有属主才能改变目录中的内容。</td>
</tr>
</tbody>
</table>
</div>
<p>运行 .sh 文件类型的文件：</p>
<p>用file命令测试一下看是什么类型的</p>
<pre><code>file xxxx.sh
</code></pre><p>如果是Bourne-Again shell script 可以<code>sh xxxx.sh</code> 或者<code>chmod +x xxxx.sh</code>再<code>./xxx.sh</code></p>
<p>一般 .sh 的直接添加x(可执行属性)<code>chmod +x xxx.sh</code> 然后<code>./xxx.sh</code>就可以了</p>
<h2 id="特殊命令"><a href="#特殊命令" class="headerlink" title="特殊命令"></a>特殊命令</h2><p>查看当前静态文件系统信息</p>
<pre><code>cat /etc/fstab
</code></pre><p>查看当前系统磁盘的UUID</p>
<pre><code>ls /dev/disk/by-uuid
</code></pre><p>重新获取IP</p>
<pre><code>dhclient -r 释放IP
dhclient 获取IP
</code></pre>]]></content>
      <categories>
        <category>技能</category>
      </categories>
  </entry>
  <entry>
    <title>maven中scope详解</title>
    <url>/2020/01/10/maven%E4%B8%ADscope%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="maven中scope详解"><a href="#maven中scope详解" class="headerlink" title="maven中scope详解"></a>maven中scope详解</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h5 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h5><ul>
<li>Maven 的哲学思想是，约定优于配置（Convention Over Configuration），Maven 依赖中 scope 的默认值是<strong>compile</strong></li>
<li>Scope 指定了依赖（第三方jar包）的 <strong>作用范围</strong></li>
<li>作用范围包括，所在项目的<strong>测试、编译、运行、打包等</strong>生命周期</li>
<li>其中，编译和运行还分为<ul>
<li><strong>测试代码</strong>的编译和运行</li>
<li><strong>非测试代码</strong>的编译和运行</li>
</ul>
</li>
</ul>
<h2 id="scope分类"><a href="#scope分类" class="headerlink" title="scope分类"></a>scope分类</h2><ol>
<li><p>test 测试范围</p>
<p>测试范围的依赖（第三方jar包），<strong>针对测试相关代码的编译和运行</strong>，在<strong>通常代码</strong>的编译和运行时都不需要，只有在<strong>有关测试的代码编译和运行测试代码阶段</strong>可用</p>
</li>
<li><p>compile 编译范围</p>
<p><strong>依赖默认范围</strong>，该依赖需要参与当前项目的<strong>编译、测试、运行、打包</strong></p>
</li>
<li><p>runtime 运行时范围</p>
<p>表示依赖<strong>无需参与当前项目的编译</strong>，但是后期的<strong>运行和测试</strong>需要参与，不参与编译能运行成功吗？？</p>
<p>与 compile 相比，<strong>跳过编译</strong>而已</p>
<p>比如，你可能在编译的时候需要 JDBC API JAR，只有在 <strong>运行时</strong>才需要 JDBC</p>
<p>貌似是编译时<strong>该包不参与</strong>，运行时参与<strong>？</strong></p>
</li>
<li><p>provided 表明该依赖已经提供，故只在未提供时才被使用</p>
<p>应用场景是你定义了一个Servlet，此刻得需要Servlet-api.jar 才能编译成功，但是当你达成<strong>war 包</strong>时，你并不想将 Servlet-api.jar 包进去，因为<strong>Tomcat等容器会提供</strong></p>
<p>跟compile 类似，说明JDK、容器或使用者会<strong>提供这个依赖</strong>，如Servlet.jar</p>
<p>这个依赖只作用在<strong> 编译和测试</strong>，该依赖会由系统组件提供，不需<strong>手动添加</strong>，只存在<strong>编译、运行、测试阶段</strong>，打包是不用包进去，打包阶段做了<strong>exclude</strong>动作</p>
<p>没有传递性</p>
</li>
<li><p>system</p>
<p>被依赖项<strong>不会从maven仓库下载</strong>，而是<strong>从本地系统指定路径下寻找</strong>，需要 systemPath 属性</p>
</li>
</ol>
<h2 id="scope-的传递依赖"><a href="#scope-的传递依赖" class="headerlink" title="scope 的传递依赖"></a>scope 的传递依赖</h2><p> A -&gt; B -&gt; C, 当前项目 A，A依赖于B，B依赖于C，知道B在 A中的scope，怎么知道 C在 A 中的 scope</p>
<ul>
<li>即，<strong>A需不需要 C的问题</strong>，本质由 <strong>C在B中的scope决定</strong></li>
<li>当 C 在 B 中的scope 是test 或 provided 时，C <strong>直接被丢弃</strong>，<strong>A不依赖C</strong></li>
<li>否则 A 依赖 C，C的scope <strong>继承与B 的scope</strong></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>链接：<a href="https://www.jianshu.com/p/a9bd44a83dc5" target="_blank" rel="noopener">https://www.jianshu.com/p/a9bd44a83dc5</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>nmap基础教程</title>
    <url>/2020/02/05/nmap%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="nmap基础教程"><a href="#nmap基础教程" class="headerlink" title="nmap基础教程"></a>nmap基础教程</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Nmap主机扫描工具</p>
<p>主要功能：</p>
<ul>
<li>主机探测</li>
<li>端口扫描</li>
<li>版本检测</li>
<li>系统检测</li>
<li>支持探测脚本的编写</li>
</ul>
<p>应用场合</p>
<ul>
<li>通过对设备或者防火墙的探测来审计它的安全性</li>
<li>探测目标主机所开放的端口</li>
<li>通过识别新的服务器审计网络的安全性</li>
<li>探测网络上的主机</li>
</ul>
<h2 id="端口扫描工具"><a href="#端口扫描工具" class="headerlink" title="端口扫描工具"></a>端口扫描工具</h2><blockquote>
<p>借助工具，收集扫描IP提供哦你的计算机网络服务类型，从而发现弱点。</p>
</blockquote>
<p>常见服务对应端口</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>服务</th>
<th>端口号</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTTP</td>
<td>80</td>
</tr>
<tr>
<td>HTTPS</td>
<td>443</td>
</tr>
<tr>
<td>Telnet</td>
<td>23</td>
</tr>
<tr>
<td>FTP</td>
<td>21</td>
</tr>
<tr>
<td>SSH（安全登录）、SCP（文件传输）、端口重定向</td>
<td>22</td>
</tr>
<tr>
<td>SMTP</td>
<td>25</td>
</tr>
<tr>
<td>POP3</td>
<td>110</td>
</tr>
<tr>
<td>WebLogic</td>
<td>7001</td>
</tr>
<tr>
<td>TOMCAT</td>
<td>8080</td>
</tr>
<tr>
<td>WIN2003远程登录</td>
<td>3389</td>
</tr>
<tr>
<td>Oracle数据库</td>
<td>1521</td>
</tr>
<tr>
<td>MS SQL* SEVER数据库sever</td>
<td>1433</td>
</tr>
<tr>
<td>MySQL 数据库sever</td>
<td>3306</td>
</tr>
</tbody>
</table>
</div>
<p>完整全面扫描</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -T4 -A -v</span><br></pre></td></tr></table></figure>
<p>其中-A选项用于使用进攻性（Aggressive）方式扫描；-T4指定扫描过程使用的时序（Timing），总有6个级别（0-5），级别越高，扫描速度越快，但也容易被防火墙或IDS检测并屏蔽掉，在网络通讯状况良好的情况推荐使用T4；-v表示显示冗余（verbosity）信息，在扫描过程中显示扫描的细节，从而让用户了解当前的扫描状态。</p>
<h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-sL: List Scan 列表扫描，仅将指定的目标的IP列举出来，不进行主机发现。  </span><br><span class="line">  </span><br><span class="line">-sn: Ping Scan 只进行主机发现，不进行端口扫描。  </span><br><span class="line">  </span><br><span class="line">-Pn: 将所有指定的主机视作开启的，跳过主机发现的过程。  </span><br><span class="line">  </span><br><span class="line">-PS/PA/PU/PY[portlist]: 使用TCPSYN/ACK或SCTP INIT/ECHO方式进行发现。  </span><br><span class="line">  </span><br><span class="line">-PE/PP/PM: 使用ICMP <span class="built_in">echo</span>, timestamp, and netmask 请求包发现主机。-PO[protocollist]: 使用IP协议包探测对方主机是否开启。  </span><br><span class="line">  </span><br><span class="line">-n/-R: -n表示不进行DNS解析；-R表示总是进行DNS解析。  </span><br><span class="line">  </span><br><span class="line">--dns-servers &lt;serv1[,serv2],...&gt;: 指定DNS服务器。  </span><br><span class="line">  </span><br><span class="line">--system-dns: 指定使用系统的DNS服务器  </span><br><span class="line">  </span><br><span class="line">--traceroute: 追踪每个路由节点</span><br></pre></td></tr></table></figure>
<h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><ol>
<li><p>扫描方式</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-sS/sT/sA/sW/sM:指定使用 TCP SYN/Connect()/ACK/Window/Maimon scans的方式来对目标主机进行扫描。  </span><br><span class="line">  </span><br><span class="line">  -sU: 指定使用UDP扫描方式确定目标主机的UDP端口状况。  </span><br><span class="line">  </span><br><span class="line">  -sN/sF/sX: 指定使用TCP Null, FIN, and Xmas scans秘密扫描方式来协助探测对方的TCP端口状态。  </span><br><span class="line">  </span><br><span class="line">  --scanflags &lt;flags&gt;: 定制TCP包的flags。  </span><br><span class="line">  </span><br><span class="line">  -sI &lt;zombiehost[:probeport]&gt;: 指定使用idle scan方式来扫描目标主机（前提需要找到合适的zombie host）  </span><br><span class="line">  </span><br><span class="line">  -sY/sZ: 使用SCTP INIT/COOKIE-ECHO来扫描SCTP协议端口的开放的情况。  </span><br><span class="line">  </span><br><span class="line">  -sO: 使用IP protocol 扫描确定目标机支持的协议类型。  </span><br><span class="line">  </span><br><span class="line">  -b &lt;FTP relay host&gt;: 使用FTP bounce scan扫描方式</span><br></pre></td></tr></table></figure>
</li>
<li><p>端口参数和扫描顺序</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-p &lt;port ranges&gt;: 扫描指定的端口  </span><br><span class="line">  </span><br><span class="line">实例: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9（其中T代表TCP协议、U代表UDP协议、S代表SCTP协议）  </span><br><span class="line">  </span><br><span class="line">-F: Fast mode – 快速模式，仅扫描TOP 100的端口  </span><br><span class="line">  </span><br><span class="line">-r: 不进行端口随机打乱的操作（如无该参数，nmap会将要扫描的端口以随机顺序方式扫描，以让nmap的扫描不易被对方防火墙检测到）。  </span><br><span class="line">  </span><br><span class="line">--top-ports &lt;number&gt;:扫描开放概率最高的number个端口（nmap的作者曾经做过大规模地互联网扫描，以此统计出网络上各种端口可能开放的概率。以此排列出最有可能开放端口的列表，具体可以参见文件：nmap-services。默认情况下，nmap会扫描最有可能的1000个TCP端口）  </span><br><span class="line">  </span><br><span class="line">--port-ratio &lt;ratio&gt;: 扫描指定频率以上的端口。与上述--top-ports类似，这里以概率作为参数，让概率大于--port-ratio的端口才被扫描。显然参数必须在在0到1之间，具体范围概率情况可以查看nmap-services文件。</span><br></pre></td></tr></table></figure>
</li>
<li><p>版本侦测</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">-sV: 指定让Nmap进行版本侦测  </span><br><span class="line">  </span><br><span class="line">--version-intensity &lt;level&gt;: 指定版本侦测强度（0-9），默认为7。数值越高，探测出的服务越准确，但是运行时间会比较长。  </span><br><span class="line">  </span><br><span class="line">--version-light: 指定使用轻量侦测方式 (intensity 2)  </span><br><span class="line">  </span><br><span class="line">--version-all: 尝试使用所有的probes进行侦测 (intensity 9)  </span><br><span class="line">  </span><br><span class="line">--version-trace: 显示出详细的版本侦测过程信息。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><ol>
<li><p>Nmap扫描特定IP地址</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>用<code>-vv</code>对结果进行详细输出</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -vv &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>自行设置端口范围进行扫描</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -p1-998 &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>指定端口号进行扫描</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -p80,512,22,90,126,443 &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>对目标进行Ping扫描</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -sP &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>路由跟踪</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -traceroute &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>扫描一个段的主机在线状况</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -sP &lt;network address &gt; &lt;/CIDR&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>操作系统探测</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -O &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>万能开关扫描</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -A &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><strong>SYN扫描</strong>：利用基本的SYN扫描方式测试其端口开放状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">namp -sS -T4 &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><strong>FIN扫描</strong>：利用FIN扫描方式探测防火墙状态。FIN扫描方式用于识别端口是否关闭，收到RST回复说明该端口关闭，否则说明是open或filtered状态</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">namp -sF -T4 &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><strong>ACK扫描</strong>：利用ACK扫描判断端口是否被过滤。针对ACK探测包，为被过滤的端口（无论打开或关闭）会回复RST包</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">namp -sA -T4 &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>扫描前不进行Ping扫描测试</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -Pn &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>如果有一个ip地址列表，将这个保存为一个txt文件，和nmap在同意目录下，扫描这个txt的所有主机，命令为</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -iL target.txt</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>版本检测扫描</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">nmap -sV &lt;target ip&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://www.cnblogs.com/weihua2616/p/6599629.html" target="_blank" rel="noopener">https://www.cnblogs.com/weihua2616/p/6599629.html</a></li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>TypeScript_Tutorial</title>
    <url>/2020/04/09/TypeScript-Tutorial/</url>
    <content><![CDATA[<h1 id="TypeScript-教程"><a href="#TypeScript-教程" class="headerlink" title="TypeScript 教程"></a>TypeScript 教程</h1><blockquote>
<p>ypeScript 是 JavaScript 的一个超集，支持 ECMAScript 6 标准。</p>
<p>TypeScript 由微软开发的自由和开源的编程语言。</p>
<p>TypeScript 设计目标是开发大型应用，它可以编译成纯 JavaScript，编译出来的 JavaScript 可以运行在任何浏览器上。</p>
<p>ypeScript 是一种给 JavaScript 添加特性的语言扩展。增加的功能包括：</p>
<ul>
<li>类型批注和编译时类型检查</li>
<li>类型推断</li>
<li>类型擦除</li>
<li>接口</li>
<li>枚举</li>
<li>Mixin</li>
<li>泛型编程</li>
<li>名字空间</li>
<li>元组</li>
<li>Await</li>
</ul>
<p>以下功能是从 ECMA 2015 反向移植而来：</p>
<ul>
<li>类</li>
<li>模块</li>
<li>lambda 函数的箭头语法</li>
<li>可选参数以及默认参数</li>
</ul>
</blockquote>
<a id="more"></a>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>TypeScript程序主要由以下几个部分组成：模块、函数、变量、语句和表达式、注释</p>
<ol>
<li><p>Hello World</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hello : <span class="built_in">string</span> = <span class="string">"Hello World!"</span></span><br><span class="line"><span class="built_in">console</span>.log(hello)</span><br></pre></td></tr></table></figure>
<p>上面的代码通过<strong>tsc</strong>命令编译</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tsc Test.ts</span><br></pre></td></tr></table></figure>
<p>得到如下js代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="string">"Hello World!"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(hello);</span><br></pre></td></tr></table></figure>
<p>使用node命令执行js代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$node Test.js</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>
<p>可以同时编译多个ts文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tsc file1.ts file2.ts file3.ts</span><br></pre></td></tr></table></figure>
<p>tsc常用编译参数：</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">编译参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1.</td>
<td style="text-align:center"><strong>—help</strong>显示帮助信息</td>
</tr>
<tr>
<td style="text-align:center">2.</td>
<td style="text-align:center"><strong>—module</strong>载入扩展模块</td>
</tr>
<tr>
<td style="text-align:center">3.</td>
<td style="text-align:center"><strong>—target</strong>设置 ECMA 版本</td>
</tr>
<tr>
<td style="text-align:center">4.</td>
<td style="text-align:center"><strong>—declaration</strong>额外生成一个 .d.ts 扩展名的文件。<code>tsc ts-hw.ts --declaration</code>以上命令会生成 ts-hw.d.ts、ts-hw.js 两个文件。</td>
</tr>
<tr>
<td style="text-align:center">5.</td>
<td style="text-align:center"><strong>—removeComments</strong>删除文件的注释</td>
</tr>
<tr>
<td style="text-align:center">6.</td>
<td style="text-align:center"><strong>—out</strong>编译多个文件并合并到一个输出的文件</td>
</tr>
<tr>
<td style="text-align:center">7.</td>
<td style="text-align:center"><strong>—sourcemap</strong>生成一个 sourcemap (.map) 文件。sourcemap 是一个存储源代码与编译代码对应位置映射的信息文件。</td>
</tr>
<tr>
<td style="text-align:center">8.</td>
<td style="text-align:center"><strong>—module noImplicitAny</strong>在表达式和声明上有隐含的 any 类型时报错</td>
</tr>
<tr>
<td style="text-align:center">9.</td>
<td style="text-align:center"><strong>—watch</strong>在监视模式下运行编译器。会监视输出文件，在它们改变时重新编译。</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>保留关键字</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>break</th>
<th>as</th>
<th>catch</th>
<th>switch</th>
</tr>
</thead>
<tbody>
<tr>
<td>case</td>
<td>if</td>
<td>throw</td>
<td>else</td>
</tr>
<tr>
<td>var</td>
<td>number</td>
<td>string</td>
<td>get</td>
</tr>
<tr>
<td>module</td>
<td>type</td>
<td>instanceof</td>
<td>typeof</td>
</tr>
<tr>
<td>public</td>
<td>private</td>
<td>enum</td>
<td>export</td>
</tr>
<tr>
<td>finally</td>
<td>for</td>
<td>while</td>
<td>void</td>
</tr>
<tr>
<td>null</td>
<td>super</td>
<td>this</td>
<td>new</td>
</tr>
<tr>
<td>in</td>
<td>return</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>any</td>
<td>extends</td>
<td>static</td>
<td>let</td>
</tr>
<tr>
<td>package</td>
<td>implements</td>
<td>interface</td>
<td>function</td>
</tr>
<tr>
<td>new</td>
<td>try</td>
<td>yield</td>
<td>const</td>
</tr>
<tr>
<td>continue</td>
<td>do</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>   TypeScript</p>
<ul>
<li>忽略程序中出现的空格、制表符和换行符</li>
<li>区分大小写字符</li>
<li><p>每段指令都是一段语句，可以使用分号或者不使用。写在同一行的语句一定要使用分号来分割。</p>
<p>注释</p>
</li>
<li><p>单行注释 //</p>
</li>
<li>多行注释 /**/</li>
</ul>
<ol>
<li><p>面向对象</p>
<p>TypeScript是一种面向对象的编程语言。</p>
<ul>
<li><strong>对象</strong>：对象是类的一个实例（<strong>对象不是找个女朋友</strong>），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li>
<li><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态。</li>
<li><strong>方法</strong>：方法是类的操作的实现步骤。</li>
</ul>
<p>面向对象编程实例</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Site &#123; </span><br><span class="line">   name():<span class="built_in">void</span> &#123; </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Runoob"</span>) </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Site(); </span><br><span class="line">obj.name();</span><br></pre></td></tr></table></figure>
<p>编译后生成的JavaScript代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Site = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Site</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Site.prototype.name = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Runoob"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> Site;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Site();</span><br><span class="line">obj.name();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">数据类型</th>
<th style="text-align:left">关键字</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">任意类型</td>
<td style="text-align:left">any</td>
<td style="text-align:left">声明为 any 的变量可以赋予任意类型的值。</td>
</tr>
<tr>
<td style="text-align:left">数字类型</td>
<td style="text-align:left">number</td>
<td style="text-align:left">双精度 64 位浮点值。它可以用来表示整数和分数。<br>let binaryLiteral: number = 0b1010; // 二进制<br/> let octalLiteral: number = 0o744;    // 八进制<br/> let decLiteral: number = 6;    // 十进制<br/> let hexLiteral: number = 0xf00d;    // 十六进制</td>
</tr>
<tr>
<td style="text-align:left">字符串类型</td>
<td style="text-align:left">string</td>
<td style="text-align:left">一个字符系列，使用单引号（<strong>‘</strong>）或双引号（<strong>“</strong>）来表示字符串类型。反引号（<strong>`</strong>）来定义多行文本和内嵌表达式。<br/>let name: string = “Runoob”; <br/>let years: number = 5;<br/> let words: string = “您好，今年是 ${ name } 发布 ${ years + 1} 周年”;</td>
</tr>
<tr>
<td style="text-align:left">布尔类型</td>
<td style="text-align:left">boolean</td>
<td style="text-align:left">表示逻辑值：true 和 false。<br/><code>let flag: boolean = true;</code></td>
</tr>
<tr>
<td style="text-align:left">数组类型</td>
<td style="text-align:left">无</td>
<td style="text-align:left">声明变量为数组。<br/><code>// 在元素类型后面加上[] let arr: number[] = [1, 2]; // 或者使用数组泛型 let arr: Array = [1, 2];</code></td>
</tr>
<tr>
<td style="text-align:left">元组</td>
<td style="text-align:left">无</td>
<td style="text-align:left">元组类型用来表示已知元素数量和类型的数组，各元素的类型不必相同，对应位置的类型需要相同。<code>let x: [string, number]; x = [&#39;Runoob&#39;, 1];    // 运行正常 x = [1, &#39;Runoob&#39;];    // 报错 console.log(x[0]);    // 输出 Runoob</code></td>
</tr>
<tr>
<td style="text-align:left">枚举</td>
<td style="text-align:left">enum</td>
<td style="text-align:left">枚举类型用于定义数值集合。<code>enum Color {Red, Green, Blue}; let c: Color = Color.Blue; console.log(c);    // 输出 2</code></td>
</tr>
<tr>
<td style="text-align:left">void</td>
<td style="text-align:left">void</td>
<td style="text-align:left">用于标识方法返回值的类型，表示该方法没有返回值。<code>function hello(): void {    alert(&quot;Hello Runoob&quot;); }</code></td>
</tr>
<tr>
<td style="text-align:left">null</td>
<td style="text-align:left">null</td>
<td style="text-align:left">表示对象值缺失。</td>
</tr>
<tr>
<td style="text-align:left">undefined</td>
<td style="text-align:left">undefined</td>
<td style="text-align:left">用于初始化变量为一个未定义的值</td>
</tr>
<tr>
<td style="text-align:left">never</td>
<td style="text-align:left">never</td>
<td style="text-align:left">never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。</td>
</tr>
</tbody>
</table>
</div>
<p>注意：**TypeScript 和 JavaScript 没有整数类型。</p>
<ol>
<li><p>Any类型</p>
<blockquote>
<p>任意值是 TypeScript 针对编程时类型不明确的变量使用的一种数据类型，它常用于以下三种情况。</p>
</blockquote>
<ul>
<li><p>变量的值会动态改变时，比如来自用户的输入，任意值类型可以让这些变量跳过编译阶段的类型检查</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">any</span> = <span class="number">1</span>;    <span class="comment">// 数字类型</span></span><br><span class="line">x = <span class="string">'I am who I am'</span>;    <span class="comment">// 字符串类型</span></span><br><span class="line">x = <span class="literal">false</span>;    <span class="comment">// 布尔类型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>改写现有代码时，任意值允许在编译时可选择地包含或移除类型检查</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">x.ifItExists();    <span class="comment">// 正确，ifItExists方法在运行时可能存在，但这里并不会检查</span></span><br><span class="line">x.toFixed();    <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义存储各种类型数据的数组时</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayList: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">false</span>, <span class="string">'fine'</span>];</span><br><span class="line">arrayList[<span class="number">1</span>] = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Null 和 Undefined</p>
<p>null是一个只有一个值的特殊类型。表示一个空对象引用。</p>
<p>用 typeof 检测 null 返回是 object。</p>
<p>在 JavaScript 中, undefined 是一个没有设置值的变量。</p>
<p>typeof 一个没有值的变量会返回 undefined。</p>
<p>Null 和 Undefined 是其他任何类型（包括 void）的子类型，可以赋值给其它类型，如数字类型，此时，赋值后的类型会变成 null 或 undefined。而在TypeScript中启用严格的空校验（—strictNullChecks）特性，就可以使得null 和 undefined 只能被赋值给 void 或本身对应的类型，示例代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启用 --strictNullChecks</span></span><br><span class="line"><span class="keyword">let</span> x: <span class="built_in">number</span>;</span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// 运行正确</span></span><br><span class="line">x = <span class="literal">undefined</span>;    <span class="comment">// 运行错误</span></span><br><span class="line">x = <span class="literal">null</span>;    <span class="comment">// 运行错误</span></span><br></pre></td></tr></table></figure>
<p>上面的例子中变量 x 只能是数字类型。如果一个类型可能出现 null 或 undefined， 可以用 | 来支持多种类型，示例代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 启用 --strictNullChecks</span></span><br><span class="line"><span class="keyword">let</span> x: <span class="built_in">number</span> | <span class="literal">null</span> | <span class="literal">undefined</span>;</span><br><span class="line">x = <span class="number">1</span>; <span class="comment">// 运行正确</span></span><br><span class="line">x = <span class="literal">undefined</span>;    <span class="comment">// 运行正确</span></span><br><span class="line">x = <span class="literal">null</span>;    <span class="comment">// 运行正确</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>never类型</p>
<p>never 是其它类型（包括 null 和 undefined）的子类型，代表从不会出现的值。</p>
<p>这意味着声明为 never 类型的变量只能被 never 类型所赋值，在函数中它通常表现为抛出异常或无法执行到终止点（例如无限循环），示例代码如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x: never;</span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行错误，数字类型不能转为 never 类型</span></span><br><span class="line">x = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行正确，never 类型可以赋值给 never类型</span></span><br><span class="line">x = <span class="function">(<span class="params">(<span class="params"></span>)=&gt;&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="params">'exception'</span>)&#125;</span>)<span class="params">()</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 运行正确，<span class="params">never</span> 类型可以赋值给 数字类型</span></span><br><span class="line"><span class="function"><span class="params">y</span> = (<span class="params">(<span class="params"></span>)=&gt;&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="params">'exception'</span>)&#125;</span>)<span class="params">()</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 返回值为 <span class="params">never</span> 的函数可以是抛出异常的情况</span></span><br><span class="line"><span class="function"><span class="params">function</span> <span class="params">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="params">never</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="params">throw</span> <span class="params">new</span> <span class="params">Error</span>(<span class="params">message</span>);</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 返回值为 <span class="params">never</span> 的函数可以是无法被执行到的终止点的情况</span></span><br><span class="line"><span class="function"><span class="params">function</span> <span class="params">loop</span><span class="params">()</span>: <span class="params">never</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="params">while</span> (<span class="params"><span class="literal">true</span></span>) &#123;&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><blockquote>
<p>变量是一种使用方便的占位符，用于引用计算机内存地址。</p>
</blockquote>
<p>TypeScript 变量的命名规则：</p>
<ul>
<li>变量名称可以包含数字和字母。</li>
<li>除了下划线 <strong>_</strong> 和美元 <strong>$</strong> 符号外，不能包含其他特殊字符，包括空格。</li>
<li>变量名不能以数字开头。</li>
</ul>
<p>变量使用前必须先声明，我们可以使用 var 来声明变量。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> [变量名] : [类型] = 值;</span><br><span class="line"><span class="comment">// 声明变量的类型，但没有初始值，变量值会设置为 undefined：</span></span><br><span class="line"><span class="keyword">var</span> [变量名] : [类型];</span><br><span class="line"><span class="comment">// 声明变量没有设置类型和初始值，类型可以是任意类型，默认初始值为 undefined：</span></span><br><span class="line"><span class="keyword">var</span> [变量名];</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>变量不要使用 name 否则会与 DOM 中的全局 window 对象下的 name 属性出现了重名。</p>
<p>TypeScript 遵循强类型，如果将不同的类型赋值给变量会编译错误，如下实例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num:<span class="built_in">number</span> = <span class="string">"hello"</span>     <span class="comment">// 这个代码会编译错误</span></span><br></pre></td></tr></table></figure>
<p>类型断言可以用来手动指定一个值的类型，即允许变量从一种类型更改为另一种类型。</p>
<p>语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;类型&gt;值</span><br></pre></td></tr></table></figure>
<p>或:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">值 as 类型</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'1'</span> </span><br><span class="line"><span class="keyword">var</span> str2:<span class="built_in">number</span> = &lt;<span class="built_in">number</span>&gt; &lt;<span class="built_in">any</span>&gt; str   <span class="comment">//str、str2 是 string 类型</span></span><br><span class="line"><span class="built_in">console</span>.log(str2)</span><br></pre></td></tr></table></figure>
<p>当类型没有给出时，TypeScript 编译器利用类型推断来推断类型。</p>
<p>如果由于缺乏声明而不能推断出类型，那么它的类型被视作默认的动态 any 类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">2</span>;    <span class="comment">// 类型推断为 number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"num 变量的值为 "</span>+num); </span><br><span class="line">num = <span class="string">"12"</span>;    <span class="comment">// 编译错误</span></span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure>
<p>变量作用域指定了变量定义的位置。</p>
<p>程序中变量的可用性由变量作用域决定。</p>
<p>TypeScript 有以下几种作用域：</p>
<ul>
<li><strong>全局作用域</strong> − 全局变量定义在程序结构的外部，它可以在你代码的任何位置使用。</li>
<li><strong>类作用域</strong> − 这个变量也可以称为 <strong>字段</strong>。类变量声明在一个类里头，但在类的方法外面。 该变量可以通过类的对象来访问。类变量也可以是静态的，静态的变量可以通过类名直接访问。</li>
<li><strong>局部作用域</strong> − 局部变量，局部变量只能在声明它的一个代码块（如：方法）中使用。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> global_num = <span class="number">12</span>          <span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">class</span> Numbers &#123; </span><br><span class="line">   num_val = <span class="number">13</span>;             <span class="comment">// 实例变量</span></span><br><span class="line">   <span class="keyword">static</span> sval = <span class="number">10</span>;         <span class="comment">// 静态变量</span></span><br><span class="line">   </span><br><span class="line">   storeNum():<span class="built_in">void</span> &#123; </span><br><span class="line">      <span class="keyword">var</span> local_num = <span class="number">14</span>;    <span class="comment">// 局部变量</span></span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"全局变量为: "</span>+global_num)  </span><br><span class="line"><span class="built_in">console</span>.log(Numbers.sval)   <span class="comment">// 静态变量</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Numbers(); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"实例变量: "</span>+obj.num_val)</span><br></pre></td></tr></table></figure>
<p>上面的代码使用tsc命令编译为JavaScript代码为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> global_num = <span class="number">12</span>; <span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">var</span> Numbers = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Numbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num_val = <span class="number">13</span>; <span class="comment">// 实例变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    Numbers.prototype.storeNum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> local_num = <span class="number">14</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    &#125;;</span><br><span class="line">    Numbers.sval = <span class="number">10</span>; <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">return</span> Numbers;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"全局变量为: "</span> + global_num);</span><br><span class="line"><span class="built_in">console</span>.log(Numbers.sval); <span class="comment">// 静态变量</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Numbers();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"实例变量: "</span> + obj.num_val);</span><br></pre></td></tr></table></figure>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ol>
<li>算术运算符</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">例子</th>
<th style="text-align:left">x 运算结果</th>
<th style="text-align:left">y 运算结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">加法</td>
<td style="text-align:left">x=y+2</td>
<td style="text-align:left">7</td>
<td style="text-align:left">5</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">减法</td>
<td style="text-align:left">x=y-2</td>
<td style="text-align:left">3</td>
<td style="text-align:left">5</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">乘法</td>
<td style="text-align:left">x=y*2</td>
<td style="text-align:left">10</td>
<td style="text-align:left">5</td>
</tr>
<tr>
<td style="text-align:left">/</td>
<td style="text-align:left">除法</td>
<td style="text-align:left">x=y/2</td>
<td style="text-align:left">2.5</td>
<td style="text-align:left">5</td>
</tr>
<tr>
<td style="text-align:left">%</td>
<td style="text-align:left">取模（余数）</td>
<td style="text-align:left">x=y%2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">5</td>
</tr>
<tr>
<td style="text-align:left">++</td>
<td style="text-align:left">自增</td>
<td style="text-align:left">x=++y</td>
<td style="text-align:left">6</td>
<td style="text-align:left">6</td>
</tr>
<tr>
<td style="text-align:left">x=y++</td>
<td style="text-align:left">5</td>
<td style="text-align:left">6</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">—</td>
<td style="text-align:left">自减</td>
<td style="text-align:left">x=—y</td>
<td style="text-align:left">4</td>
<td style="text-align:left">4</td>
</tr>
<tr>
<td style="text-align:left">x=y—</td>
<td style="text-align:left">5</td>
<td style="text-align:left">4</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>关系运算符</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">比较</th>
<th style="text-align:left">返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">==</td>
<td style="text-align:left">等于</td>
<td style="text-align:left">x==8</td>
<td style="text-align:left"><em>false</em></td>
</tr>
<tr>
<td style="text-align:left">x==5</td>
<td style="text-align:left"><em>true</em></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left">不等于</td>
<td style="text-align:left">x!=8</td>
<td style="text-align:left"><em>true</em></td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">大于</td>
<td style="text-align:left">x&gt;8</td>
<td style="text-align:left"><em>false</em></td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">小于</td>
<td style="text-align:left">x&lt;8</td>
<td style="text-align:left"><em>true</em></td>
</tr>
<tr>
<td style="text-align:left">&gt;=</td>
<td style="text-align:left">大于或等于</td>
<td style="text-align:left">x&gt;=8</td>
<td style="text-align:left"><em>false</em></td>
</tr>
<tr>
<td style="text-align:left">&lt;=</td>
<td style="text-align:left">小于或等于</td>
<td style="text-align:left">x&lt;=8</td>
<td style="text-align:left"><em>true</em></td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>逻辑运算符</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&amp;&amp;</td>
<td style="text-align:left">and</td>
<td style="text-align:left">(x &lt; 10 &amp;&amp; y &gt; 1) 为 true</td>
</tr>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left">\</td>
<td style="text-align:left"></td>
<td>or</td>
<td>(x==5 \</td>
<td>\</td>
<td>y==5) 为 false</td>
</tr>
<tr>
<td style="text-align:left">!</td>
<td style="text-align:left">not</td>
<td style="text-align:left">!(x==y) 为 true</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>短路运算符（&amp;&amp; 和 ||）</p>
<p>&amp;&amp; 与 || 运算符可用于组合表达式。 &amp;&amp; 运算符只有在左右两个表达式都为 true 时才返回 true。</p>
</li>
<li><p>位运算符</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">例子</th>
<th style="text-align:left">类似于</th>
<th style="text-align:left">结果</th>
<th style="text-align:left">十进制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">&amp;</td>
<td style="text-align:left">AND，按位与处理两个长度相同的二进制数，两个相应的二进位都为 1，该位的结果值才为 1，否则为 0。</td>
<td style="text-align:left">x = 5 &amp; 1</td>
<td style="text-align:left">0101 &amp; 0001</td>
<td style="text-align:left">0001</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left"></td>
<td style="text-align:left">OR，按位或处理两个长度相同的二进制数，两个相应的二进位中只要有一个为 1，该位的结果值为 1。</td>
<td style="text-align:left">x = 5 \</td>
<td style="text-align:left">1</td>
<td style="text-align:left">0101 \</td>
<td>0001</td>
<td>0101</td>
<td>5</td>
</tr>
<tr>
<td style="text-align:left">~</td>
<td style="text-align:left">取反，取反是一元运算符，对一个二进制数的每一位执行逻辑反操作。使数字 1 成为 0，0 成为 1。</td>
<td style="text-align:left">x = ~ 5</td>
<td style="text-align:left">~0101</td>
<td style="text-align:left">1010</td>
<td style="text-align:left">-6</td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">异或，按位异或运算，对等长二进制模式按位或二进制数的每一位执行逻辑异按位或操作。操作的结果是如果某位不同则该位为 1，否则该位为 0。</td>
<td style="text-align:left">x = 5 ^ 1</td>
<td style="text-align:left">0101 ^ 0001</td>
<td style="text-align:left">0100</td>
<td style="text-align:left">4</td>
</tr>
<tr>
<td style="text-align:left">&lt;&lt;</td>
<td style="text-align:left">左移，把 &lt;&lt; 左边的运算数的各二进位全部左移若干位，由 &lt;&lt; 右边的数指定移动的位数，高位丢弃，低位补 0。</td>
<td style="text-align:left">x = 5 &lt;&lt; 1</td>
<td style="text-align:left">0101 &lt;&lt; 1</td>
<td style="text-align:left">1010</td>
<td style="text-align:left">10</td>
</tr>
<tr>
<td style="text-align:left">&gt;&gt;</td>
<td style="text-align:left">右移，把 &gt;&gt; 左边的运算数的各二进位全部右移若干位，&gt;&gt; 右边的数指定移动的位数。</td>
<td style="text-align:left">x = 5 &gt;&gt; 1</td>
<td style="text-align:left">0101 &gt;&gt; 1</td>
<td style="text-align:left">0010</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left">&gt;&gt;&gt;</td>
<td style="text-align:left">无符号右移，与有符号右移位类似，除了左边一律使用0 补位。</td>
<td style="text-align:left">x = 2 &gt;&gt;&gt; 1</td>
<td style="text-align:left">0010 &gt;&gt;&gt; 1</td>
<td style="text-align:left">0001</td>
<td style="text-align:left">1</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>赋值运算符</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">例子</th>
<th style="text-align:left">实例</th>
<th style="text-align:left">x 值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">= (赋值)</td>
<td style="text-align:left">x = y</td>
<td style="text-align:left">x = y</td>
<td style="text-align:left">x = 5</td>
</tr>
<tr>
<td style="text-align:left">+= (先进行加运算后赋值)</td>
<td style="text-align:left">x += y</td>
<td style="text-align:left">x = x + y</td>
<td style="text-align:left">x = 15</td>
</tr>
<tr>
<td style="text-align:left">-= (先进行减运算后赋值)</td>
<td style="text-align:left">x -= y</td>
<td style="text-align:left">x = x - y</td>
<td style="text-align:left">x = 5</td>
</tr>
<tr>
<td style="text-align:left">*= (先进行乘运算后赋值)</td>
<td style="text-align:left">x *= y</td>
<td style="text-align:left">x = x * y</td>
<td style="text-align:left">x = 50</td>
</tr>
<tr>
<td style="text-align:left">/= (先进行除运算后赋值)</td>
<td style="text-align:left">x /= y</td>
<td style="text-align:left">x = x / y</td>
<td style="text-align:left">x = 2</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>三元运算符 (?)</p>
<p>三元运算有 3 个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test ? expr1 : expr2</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>类型运算符</p>
<p>typeof 是一元运算符，返回操作数的数据类型。</p>
<p>instanceof 运算符用于判断对象是否为指定的类型</p>
</li>
<li><p>其他运算符</p>
<p>负号运算符(-)：更改操作数的符号</p>
<p>字符串运算符: 连接运算符 (+)运算符可以拼接两个字符串</p>
</li>
</ol>
<h2 id="条件和循环语句"><a href="#条件和循环语句" class="headerlink" title="条件和循环语句"></a>条件和循环语句</h2><p>在 TypeScript 中，我们可使用以下条件语句：</p>
<ul>
<li><strong>if 语句</strong> - 只有当指定条件为 true 时，使用该语句来执行代码</li>
<li><strong>if…else 语句</strong> - 当条件为 true 时执行代码，当条件为 false 时执行其他代码</li>
<li><strong>if…else if….else 语句</strong>- 使用该语句来选择多个代码块之一来执行</li>
<li><strong>switch 语句</strong> - 使用该语句来选择多个代码块之一来执行</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(boolean_expression)&#123;</span><br><span class="line">    <span class="comment">// 在布尔表达式 boolean_expression 为 true 执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(boolean_expression)&#123;</span><br><span class="line">   <span class="comment">// 在布尔表达式 boolean_expression 为 true 执行</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="comment">// 在布尔表达式 boolean_expression 为 false 执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(boolean_expression <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 在布尔表达式 boolean_expression 1 为 true 执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( boolean_expression <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">// 在布尔表达式 boolean_expression 2 为 true 执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(( boolean_expression <span class="number">3</span>)&#123;</span><br><span class="line">    <span class="comment">// 在布尔表达式 boolean_expression 3 为 true 执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 布尔表达式的条件都为 false 时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> constant-expression  :</span><br><span class="line">       statement(s);</span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">/* 可选的 */</span></span><br><span class="line">    <span class="keyword">case</span> constant-expression  :</span><br><span class="line">       statement(s);</span><br><span class="line">       <span class="keyword">break</span>; <span class="comment">/* 可选的 */</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 您可以有任意数量的 case 语句 */</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">/* 可选的 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>switch</strong> 语句必须遵循下面的规则：</p>
<ul>
<li><strong>switch</strong> 语句中的 <strong>expression</strong> 是一个常量表达式，必须是一个整型或枚举类型。</li>
<li>在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。</li>
<li>case 的 <strong>constant-expression</strong> 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。</li>
<li>当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 <strong>break</strong> 语句为止。</li>
<li>当遇到 <strong>break</strong> 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。</li>
<li>不是每一个 case 都需要包含 <strong>break</strong>。如果 case 语句不包含 <strong>break</strong>，控制流将会 <em>继续</em> 后续的 case，直到遇到 break 为止。</li>
<li>一个 <strong>switch</strong> 语句可以有一个可选的 <strong>default</strong> case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 <strong>break</strong> 语句不是必需的。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( init; condition; increment )&#123;</span><br><span class="line">    statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>init</strong> 会首先被执行，且只会执行一次。这一步允许您声明并初始化任何循环控制变量。您也可以不在这里写任何语句，只要有一个分号出现即可。</li>
<li>接下来，会判断 <strong>condition</strong>。如果为 true，则执行循环主体。如果为 false，则不执行循环主体，且控制流会跳转到紧接着 for 循环的下一条语句。</li>
<li>在执行完 for 循环主体后，控制流会跳回上面的 <strong>increment</strong> 语句。该语句允许您更新循环控制变量。该语句可以留空，只要在条件后有一个分号出现即可。</li>
<li>条件再次被判断。如果为 true，则执行循环，这个过程会不断重复（循环主体，然后增加步值，再然后重新判断条件）。在条件变为 false 时，for 循环终止。</li>
</ol>
<p>for…in 语句用于一组值的集合或列表进行迭代输出。val 需要为 string 或 any 类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">in</span> list) &#123; </span><br><span class="line">    <span class="comment">//语句 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for…of 语句创建一个循环来迭代可迭代的对象。在 ES6 中引入的 for…of 循环，以替代 for…in 和 forEach() ，并支持新的迭代协议。for…of 允许你遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代的数据结构等。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someArray = [<span class="number">1</span>, <span class="string">"string"</span>, <span class="literal">false</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry of someArray) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry); <span class="comment">// 1, "string", false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>forEach、every 和 some 是 JavaScript 的循环语法，TypeScript 作为 JavaScript 的语法超集，当然默认也是支持的。</p>
<p>因为 forEach 在 iteration 中是无法返回的，所以可以使用 every 和 some 来取代 forEach。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let list &#x3D; [4, 5, 6];</span><br><span class="line">list.forEach((val, idx, array) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; val: 当前值</span><br><span class="line">    &#x2F;&#x2F; idx：当前index</span><br><span class="line">    &#x2F;&#x2F; array: Array</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">list.every(<span class="function">(<span class="params">val, idx, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// val: 当前值</span></span><br><span class="line">    <span class="comment">// idx：当前index</span></span><br><span class="line">    <span class="comment">// array: Array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// Continues</span></span><br><span class="line">    <span class="comment">// Return false will quit the iteration</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)</span><br><span class="line">&#123;</span><br><span class="line">   statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">   statement(s);</span><br><span class="line">&#125;<span class="keyword">while</span>( condition );</span><br></pre></td></tr></table></figure>
<p><strong>break</strong> 语句有以下两种用法：</p>
<ol>
<li>当 <strong>break</strong> 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句。</li>
<li>它可用于终止 <strong>switch</strong> 语句中的一个 case。</li>
</ol>
<p><strong>ontinue</strong> 语句有点像 <strong>break</strong> 语句。但它不是强制终止，continue 会跳过当前循环中的代码，强迫开始下一次循环。</p>
<p>对于 <strong>for</strong> 循环，<strong>continue</strong> 语句执行后自增语句仍然会执行。对于 <strong>while</strong> 和 <strong>do…while</strong> 循环，<strong>continue</strong> 语句重新执行条件判断语句。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数：一组一起执行一个任务的语句。</p>
<p>函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。</p>
<ol>
<li><p>函数定义</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">function_name</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>调用函数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">function_name()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>函数返回值</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">function_name</span>(<span class="params"></span>):<span class="title">return_type</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 语句</span></span><br><span class="line">    <span class="keyword">return</span> value; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>return_type 是返回值的类型。</li>
<li>return 关键词后跟着要返回的结果。</li>
<li>一个函数只能有一个 return 语句。</li>
<li>返回值的类型需要与函数定义的返回类型(return_type)一致。</li>
</ul>
<p>实例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>):<span class="title">string</span> </span>&#123; <span class="comment">// 返回一个字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World"</span> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">caller</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> msg = greet() <span class="comment">// 调用 greet() 函数 </span></span><br><span class="line">    <span class="built_in">console</span>.log(msg) </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">caller()</span><br></pre></td></tr></table></figure>
<p>编译得到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">caller</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> msg = greet(); <span class="comment">// 调用 greet() 函数 </span></span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">caller();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>带参数函数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func_name</span>(<span class="params"> param1 [:datatype], param2 [:datatype]</span>) </span>&#123;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>param1、param2 为参数名。</li>
<li>datatype 为参数类型。</li>
</ul>
</li>
<li><p>可选参数和默认参数</p>
<p>可选参数：可选参数使用问号标识 ？。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastName)</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">" "</span> + lastName;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">"Bob"</span>);  <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>, <span class="string">"Sr."</span>);  <span class="comment">// 错误，参数太多了</span></span><br><span class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>);  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<p>可选参数必须跟在必需参数后面。</p>
<p>设置参数的默认值</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">function_name</span>(<span class="params">param1[:<span class="keyword">type</span>],param2[:<span class="keyword">type</span>] = default_value</span>) </span>&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：参数不能同时设置为可选和默认。</p>
<p>实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function calculate_discount(price:number,rate:number &#x3D; 0.50) &#123; </span><br><span class="line">    var discount &#x3D; price * rate; </span><br><span class="line">    console.log(&quot;计算结果: &quot;,discount); </span><br><span class="line">&#125; </span><br><span class="line">calculate_discount(1000) </span><br><span class="line">calculate_discount(1000,0.30)</span><br></pre></td></tr></table></figure>
<p>编译得到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculate_discount</span>(<span class="params">price, rate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rate === <span class="keyword">void</span> <span class="number">0</span>) &#123; rate = <span class="number">0.50</span>; &#125;</span><br><span class="line">    <span class="keyword">var</span> discount = price * rate;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"计算结果: "</span>, discount);</span><br><span class="line">&#125;</span><br><span class="line">calculate_discount(<span class="number">1000</span>);</span><br><span class="line">calculate_discount(<span class="number">1000</span>, <span class="number">0.30</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>剩余参数</p>
<p>剩余参数语法允许我们将一个不确定数量的参数作为一个数组传入。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">" "</span> + restOfName.join(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> employeeName = buildName(<span class="string">"Joseph"</span>, <span class="string">"Samuel"</span>, <span class="string">"Lucas"</span>, <span class="string">"MacKinzie"</span>);</span><br></pre></td></tr></table></figure>
<p>函数的最后一个命名参数 restOfName 以 … 为前缀，它将成为一个由剩余参数组成的数组，索引值从0（包括）到 restOfName.length（不包括）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addNumbers</span>(<span class="params">...nums:<span class="built_in">number</span>[]</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> i;   </span><br><span class="line">    <span class="keyword">var</span> sum:<span class="built_in">number</span> = <span class="number">0</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;nums.length;i++) &#123; </span><br><span class="line">       sum = sum + nums[i]; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"和为："</span>,sum) </span><br><span class="line"> &#125; </span><br><span class="line"> addNumbers(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line"> addNumbers(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>编译得到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addNumbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nums = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> _i = <span class="number">0</span>; _i &lt; <span class="built_in">arguments</span>.length; _i++) &#123;</span><br><span class="line">        nums[_i] = <span class="built_in">arguments</span>[_i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> i;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sum = sum + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"和为："</span>, sum);</span><br><span class="line">&#125;</span><br><span class="line">addNumbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">addNumbers(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>匿名参数</p>
<p>匿名函数是一个没有函数名的函数。</p>
<p>匿名函数在程序运行时动态声明，除了没有函数名外，其他的与标准函数一样。</p>
<p>匿名函数赋值给一个变量，这种表达式就成为函数表达式。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="function"><span class="keyword">function</span>(<span class="params"> [<span class="built_in">arguments</span>] </span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>实例</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world"</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(msg())</span><br></pre></td></tr></table></figure>
<p>编译得到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(msg());</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="function"><span class="keyword">function</span>(<span class="params">a:<span class="built_in">number</span>,b:<span class="built_in">number</span></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> a*b;  </span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">console</span>.log(res(<span class="number">12</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>编译得到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(res(<span class="number">12</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>匿名函数自调用</p>
<p>匿名函数自调用在函数后使用 () 即可：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">"Hello!!"</span>;   </span><br><span class="line">    <span class="built_in">console</span>.log(x)     </span><br><span class="line"> &#125;)()</span><br></pre></td></tr></table></figure>
<p>编译得到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">"Hello!!"</span>;   </span><br><span class="line">    <span class="built_in">console</span>.log(x)    </span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>构造函数</p>
<p>TypeScript 也支持使用 JavaScript 内置的构造函数 Function() 来定义函数：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="keyword">new</span> <span class="built_in">Function</span>( [<span class="built_in">arguments</span>] ) &#123; ... &#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunction = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"return a * b"</span>); </span><br><span class="line"><span class="keyword">var</span> x = myFunction(<span class="number">4</span>, <span class="number">3</span>); </span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure>
<p>编译得到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunction = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"return a * b"</span>); </span><br><span class="line"><span class="keyword">var</span> x = myFunction(<span class="number">4</span>, <span class="number">3</span>); </span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>递归函数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params"><span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">number</span> &lt;= <span class="number">0</span>) &#123;         <span class="comment">// 停止执行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;     </span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">number</span> * factorial(<span class="built_in">number</span> - <span class="number">1</span>));     <span class="comment">// 调用自身</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">6</span>));      <span class="comment">// 输出 720</span></span><br></pre></td></tr></table></figure>
<p>编译得到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number &lt;= <span class="number">0</span>) &#123; <span class="comment">// 停止执行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (number * factorial(number - <span class="number">1</span>)); <span class="comment">// 调用自身</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">;</span><br><span class="line"><span class="built_in">console</span>.log(factorial(<span class="number">6</span>)); <span class="comment">// 输出 720</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>Lambda函数</p>
<p>Lambda 函数也称之为箭头函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">( [param1, parma2,…param n] )=&gt;statement;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function">(<span class="params">x:<span class="built_in">number</span></span>)=&gt;</span><span class="number">10</span> + x </span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">100</span>))      <span class="comment">//输出结果为 110</span></span><br></pre></td></tr></table></figure>
<p>编译得到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> <span class="number">10</span> + x; &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">100</span>)); <span class="comment">//输出结果为 110</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>函数重载</p>
<p>重载是方法名字相同，而参数不同，返回类型可以相同也可以不同。</p>
<p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p>
</li>
</ol>
<h2 id="类型细节"><a href="#类型细节" class="headerlink" title="类型细节"></a>类型细节</h2><h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>Number 对象是原始数值的包装对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var num &#x3D; new Number(value);</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 如果一个参数值不能转换为一个数字将返回 NaN (非数字值)。</p>
<p>Number 对象支持的属性：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">属性 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1.</td>
<td style="text-align:center"><strong>MAX_VALUE</strong>可表示的最大的数，MAX_VALUE 属性值接近于 1.79E+308。大于 MAX_VALUE 的值代表 “Infinity”。</td>
</tr>
<tr>
<td style="text-align:center">2.</td>
<td style="text-align:center"><strong>MIN_VALUE</strong>可表示的最小的数，即最接近 0 的正数 (实际上不会变成 0)。最大的负数是 -MIN_VALUE，MIN_VALUE 的值约为 5e-324。小于 MIN_VALUE (“underflow values”) 的值将会转换为 0。</td>
</tr>
<tr>
<td style="text-align:center">3.</td>
<td style="text-align:center"><strong>NaN</strong>非数字值（Not-A-Number）。</td>
</tr>
<tr>
<td style="text-align:center">4.</td>
<td style="text-align:center"><strong>NEGATIVE_INFINITY</strong>负无穷大，溢出时返回该值。该值小于 MIN_VALUE。</td>
</tr>
<tr>
<td style="text-align:center">5.</td>
<td style="text-align:center"><strong>POSITIVE_INFINITY</strong>正无穷大，溢出时返回该值。该值大于 MAX_VALUE。</td>
</tr>
<tr>
<td style="text-align:center">6.</td>
<td style="text-align:center"><strong>prototype</strong>Number 对象的静态属性。使您有能力向对象添加属性和方法。</td>
</tr>
<tr>
<td style="text-align:center">7.</td>
<td style="text-align:center"><strong>constructor</strong>返回对创建此对象的 Number 函数的引用。</td>
</tr>
</tbody>
</table>
</div>
<p>Number对象 支持以下方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">方法 &amp; 描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1.</td>
<td style="text-align:center">toExponential()把对象的值转换为指数计数法。</td>
<td style="text-align:center"><code>//toExponential()  var num1 = 1225.30  var val = num1.toExponential();  console.log(val) // 输出： 1.2253e+3</code></td>
</tr>
<tr>
<td style="text-align:center">2.</td>
<td style="text-align:center">toFixed()把数字转换为字符串，并对小数点指定位数。</td>
<td style="text-align:center"><code>var num3 = 177.234  console.log(&quot;num3.toFixed() 为 &quot;+num3.toFixed())    // 输出：177 console.log(&quot;num3.toFixed(2) 为 &quot;+num3.toFixed(2))  // 输出：177.23 console.log(&quot;num3.toFixed(6) 为 &quot;+num3.toFixed(6))  // 输出：177.234000</code></td>
</tr>
<tr>
<td style="text-align:center">3.</td>
<td style="text-align:center">toLocaleString()把数字转换为字符串，使用本地数字格式顺序。</td>
<td style="text-align:center"><code>var num = new Number(177.1234);  console.log( num.toLocaleString());  // 输出：177.1234</code></td>
</tr>
<tr>
<td style="text-align:center">4.</td>
<td style="text-align:center">toPrecision()把数字格式化为指定的长度。</td>
<td style="text-align:center"><code>var num = new Number(7.123456);  console.log(num.toPrecision());  // 输出：7.123456  console.log(num.toPrecision(1)); // 输出：7 console.log(num.toPrecision(2)); // 输出：7.1</code></td>
</tr>
<tr>
<td style="text-align:center">5.</td>
<td style="text-align:center">toString()把数字转换为字符串，使用指定的基数。数字的基数是 2 ~ 36 之间的整数。若省略该参数，则使用基数 10。</td>
<td style="text-align:center"><code>var num = new Number(10);  console.log(num.toString());  // 输出10进制：10 console.log(num.toString(2)); // 输出2进制：1010 console.log(num.toString(8)); // 输出8进制：12</code></td>
</tr>
<tr>
<td style="text-align:center">6.</td>
<td style="text-align:center">valueOf()返回一个 Number 对象的原始数字值。</td>
<td style="text-align:center"><code>var num = new Number(10);  console.log(num.valueOf()); // 输出：10</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String 对象用于处理文本（字符串）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> txt = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"string"</span>);</span><br><span class="line">或者更简单方式：</span><br><span class="line"><span class="keyword">var</span> txt = <span class="string">"string"</span>;</span><br></pre></td></tr></table></figure>
<p>String 对象支持的属性：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">属性 &amp; 描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1.</td>
<td style="text-align:center">constructor对创建该对象的函数的引用。</td>
<td style="text-align:center"><code>var str = new String( &quot;This is string&quot; );  console.log(&quot;str.constructor is:&quot; + str.constructor)</code>输出结果：<code>str.constructor is:function String() { [native code] }</code></td>
</tr>
<tr>
<td style="text-align:center">2.</td>
<td style="text-align:center">length返回字符串的长度。</td>
<td style="text-align:center"><code>var uname = new String(&quot;Hello World&quot;)  console.log(&quot;Length &quot;+uname.length)  // 输出 11</code></td>
</tr>
<tr>
<td style="text-align:center">3.</td>
<td style="text-align:center">prototype允许您向对象添加属性和方法。</td>
<td style="text-align:center"><code>function employee(id:number,name:string) {     this.id = id     this.name = name  }  var emp = new employee(123,&quot;admin&quot;)  employee.prototype.email=&quot;admin@runoob.com&quot; // 添加属性 email console.log(&quot;员工号: &quot;+emp.id)  console.log(&quot;员工姓名: &quot;+emp.name)  console.log(&quot;员工邮箱: &quot;+emp.email)</code></td>
</tr>
</tbody>
</table>
</div>
<p>下表列出了 String 对象支持的方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">方法 &amp; 描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1.</td>
<td style="text-align:center">charAt()返回在指定位置的字符。</td>
<td style="text-align:center"><code>var str = new String(&quot;RUNOOB&quot;);  console.log(&quot;str.charAt(0) 为:&quot; + str.charAt(0)); // R console.log(&quot;str.charAt(1) 为:&quot; + str.charAt(1)); // U  console.log(&quot;str.charAt(2) 为:&quot; + str.charAt(2)); // N  console.log(&quot;str.charAt(3) 为:&quot; + str.charAt(3)); // O  console.log(&quot;str.charAt(4) 为:&quot; + str.charAt(4)); // O  console.log(&quot;str.charAt(5) 为:&quot; + str.charAt(5)); // B</code></td>
</tr>
<tr>
<td style="text-align:center">2.</td>
<td style="text-align:center">charCodeAt()返回在指定的位置的字符的 Unicode 编码。</td>
<td style="text-align:center"><code>var str = new String(&quot;RUNOOB&quot;);  console.log(&quot;str.charCodeAt(0) 为:&quot; + str.charCodeAt(0)); // 82 console.log(&quot;str.charCodeAt(1) 为:&quot; + str.charCodeAt(1)); // 85  console.log(&quot;str.charCodeAt(2) 为:&quot; + str.charCodeAt(2)); // 78  console.log(&quot;str.charCodeAt(3) 为:&quot; + str.charCodeAt(3)); // 79  console.log(&quot;str.charCodeAt(4) 为:&quot; + str.charCodeAt(4)); // 79 console.log(&quot;str.charCodeAt(5) 为:&quot; + str.charCodeAt(5)); // 66</code></td>
</tr>
<tr>
<td style="text-align:center">3.</td>
<td style="text-align:center">concat()连接两个或更多字符串，并返回新的字符串。</td>
<td style="text-align:center"><code>var str1 = new String( &quot;RUNOOB&quot; );  var str2 = new String( &quot;GOOGLE&quot; );  var str3 = str1.concat( str2 );  console.log(&quot;str1 + str2 : &quot;+str3) // RUNOOBGOOGLE</code></td>
</tr>
<tr>
<td style="text-align:center">4.</td>
<td style="text-align:center">indexOf()返回某个指定的字符串值在字符串中首次出现的位置。</td>
<td style="text-align:center"><code>var str1 = new String( &quot;RUNOOB&quot; );  var index = str1.indexOf( &quot;OO&quot; );  console.log(&quot;查找的字符串位置 :&quot; + index );  // 3</code></td>
</tr>
<tr>
<td style="text-align:center">5.</td>
<td style="text-align:center">lastIndexOf()从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置。</td>
<td style="text-align:center"><code>var str1 = new String( &quot;This is string one and again string&quot; );  var index = str1.lastIndexOf( &quot;string&quot; ); console.log(&quot;lastIndexOf 查找到的最后字符串位置 :&quot; + index ); // 29     index = str1.lastIndexOf( &quot;one&quot; );  console.log(&quot;lastIndexOf 查找到的最后字符串位置 :&quot; + index ); // 15</code></td>
</tr>
<tr>
<td style="text-align:center">6.</td>
<td style="text-align:center">localeCompare()用本地特定的顺序来比较两个字符串。</td>
<td style="text-align:center"><code>var str1 = new String( &quot;This is beautiful string&quot; );   var index = str1.localeCompare( &quot;This is beautiful string&quot;);   console.log(&quot;localeCompare first :&quot; + index );  // 0</code></td>
</tr>
<tr>
<td style="text-align:center">7.</td>
<td style="text-align:center"><strong>match()</strong>查找找到一个或多个正则表达式的匹配。</td>
<td style="text-align:center"><code>var str=&quot;The rain in SPAIN stays mainly in the plain&quot;;  var n=str.match(/ain/g);  // ain,ain,ain</code></td>
</tr>
<tr>
<td style="text-align:center">8.</td>
<td style="text-align:center">replace()替换与正则表达式匹配的子串</td>
<td style="text-align:center"><code>var re = /(\w+)\s(\w+)/;  var str = &quot;zara ali&quot;;  var newstr = str.replace(re, &quot;$2, $1&quot;);  console.log(newstr); // ali, zara</code></td>
</tr>
<tr>
<td style="text-align:center">9.</td>
<td style="text-align:center">search()检索与正则表达式相匹配的值</td>
<td style="text-align:center"><code>var re = /apples/gi;  var str = &quot;Apples are round, and apples are juicy.&quot;; if (str.search(re) == -1 ) {    console.log(&quot;Does not contain Apples&quot; );  } else {    console.log(&quot;Contains Apples&quot; );  }</code></td>
</tr>
<tr>
<td style="text-align:center">10.</td>
<td style="text-align:center">slice()提取字符串的片断，并在新的字符串中返回被提取的部分。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">11.</td>
<td style="text-align:center">split()把字符串分割为子字符串数组。</td>
<td style="text-align:center"><code>var str = &quot;Apples are round, and apples are juicy.&quot;;  var splitted = str.split(&quot; &quot;, 3);  console.log(splitted)  // [ &#39;Apples&#39;, &#39;are&#39;, &#39;round,&#39; ]</code></td>
</tr>
<tr>
<td style="text-align:center">12.</td>
<td style="text-align:center">substr()从起始索引号提取字符串中指定数目的字符。</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">13.</td>
<td style="text-align:center">substring()提取字符串中两个指定的索引号之间的字符。</td>
<td style="text-align:center"><code>var str = &quot;RUNOOB GOOGLE TAOBAO FACEBOOK&quot;;  console.log(&quot;(1,2): &quot;    + str.substring(1,2));   // U console.log(&quot;(0,10): &quot;   + str.substring(0, 10)); // RUNOOB GOO console.log(&quot;(5): &quot;      + str.substring(5));     // B GOOGLE TAOBAO FACEBOOK</code></td>
</tr>
<tr>
<td style="text-align:center">14.</td>
<td style="text-align:center">toLocaleLowerCase()根据主机的语言环境把字符串转换为小写，只有几种语言（如土耳其语）具有地方特有的大小写映射。</td>
<td style="text-align:center"><code>var str = &quot;Runoob Google&quot;;  console.log(str.toLocaleLowerCase( ));  // runoob google</code></td>
</tr>
<tr>
<td style="text-align:center">15.</td>
<td style="text-align:center">toLocaleUpperCase()据主机的语言环境把字符串转换为大写，只有几种语言（如土耳其语）具有地方特有的大小写映射。</td>
<td style="text-align:center"><code>var str = &quot;Runoob Google&quot;;  console.log(str.toLocaleUpperCase( ));  // RUNOOB GOOGLE</code></td>
</tr>
<tr>
<td style="text-align:center">16.</td>
<td style="text-align:center">toLowerCase()把字符串转换为小写。</td>
<td style="text-align:center"><code>var str = &quot;Runoob Google&quot;;  console.log(str.toLowerCase( ));  // runoob google</code></td>
</tr>
<tr>
<td style="text-align:center">17.</td>
<td style="text-align:center">toString()返回字符串。</td>
<td style="text-align:center"><code>var str = &quot;Runoob&quot;;  console.log(str.toString( )); // Runoob</code></td>
</tr>
<tr>
<td style="text-align:center">18.</td>
<td style="text-align:center">toUpperCase()把字符串转换为大写。</td>
<td style="text-align:center"><code>var str = &quot;Runoob Google&quot;;  console.log(str.toUpperCase( ));  // RUNOOB GOOGLE</code></td>
</tr>
<tr>
<td style="text-align:center">19.</td>
<td style="text-align:center">valueOf()返回指定字符串对象的原始值。</td>
<td style="text-align:center"><code>var str = new String(&quot;Runoob&quot;);  console.log(str.valueOf( ));  // Runoob</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p>数组对象是使用单独的变量名来存储一系列的值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array_name:datatype[];        <span class="comment">//声明 </span></span><br><span class="line">array_name = [val1,val2,valn..]   <span class="comment">//初始化</span></span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numlist:<span class="built_in">number</span>[] = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sites:<span class="built_in">string</span>[]; </span><br><span class="line">sites = [<span class="string">"Google"</span>,<span class="string">"Runoob"</span>,<span class="string">"Taobao"</span>] </span><br><span class="line"><span class="built_in">console</span>.log(sites[<span class="number">0</span>]); </span><br><span class="line"><span class="built_in">console</span>.log(sites[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p>编译得到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sites;</span><br><span class="line">sites = [<span class="string">"Google"</span>, <span class="string">"Runoob"</span>, <span class="string">"Taobao"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(sites[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(sites[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p>也可以使用 Array 对象创建数组。</p>
<p>Array 对象的构造函数接受以下两种值：</p>
<ul>
<li>表示数组大小的数值。</li>
<li>初始化的数组列表，元素使用逗号分隔值。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr_names:<span class="built_in">number</span>[] = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">4</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;arr_names.length; i++) &#123; </span><br><span class="line">        arr_names[i] = i * <span class="number">2</span> </span><br><span class="line">        <span class="built_in">console</span>.log(arr_names[i]) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sites:<span class="built_in">string</span>[] = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"Google"</span>,<span class="string">"Runoob"</span>,<span class="string">"Taobao"</span>,<span class="string">"Facebook"</span>) </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;sites.length;i++) &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(sites[i]) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组解构</p>
<p>数组元素赋值给变量，如下所示</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr:<span class="built_in">number</span>[] = [<span class="number">12</span>,<span class="number">13</span>] </span><br><span class="line"><span class="keyword">var</span>[x,y] = arr <span class="comment">// 将数组的两个元素赋值给变量 x 和 y</span></span><br><span class="line"><span class="built_in">console</span>.log(x) </span><br><span class="line"><span class="built_in">console</span>.log(y)</span><br></pre></td></tr></table></figure>
<p>编译得到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">12</span>, <span class="number">13</span>];</span><br><span class="line"><span class="keyword">var</span> x = arr[<span class="number">0</span>], y = arr[<span class="number">1</span>]; <span class="comment">// 将数组的两个元素赋值给变量 x 和 y</span></span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="built_in">console</span>.log(y);</span><br></pre></td></tr></table></figure>
<p>数组迭代</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> j:<span class="built_in">any</span>; </span><br><span class="line"><span class="keyword">var</span> nums:<span class="built_in">number</span>[] = [<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>] </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(j <span class="keyword">in</span> nums) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(nums[j]) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多维数组</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr_name:datatype[][]=[ [val1,val2,val3],[v1,v2,v3] ]</span><br></pre></td></tr></table></figure>
<p>常用的数组方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">方法 &amp; 描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1.</td>
<td style="text-align:center">concat()连接两个或更多的数组，并返回结果。</td>
<td style="text-align:center"><code>var alpha = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];  var numeric = [1, 2, 3]; var alphaNumeric = alpha.concat(numeric);  console.log(&quot;alphaNumeric : &quot; + alphaNumeric );    // a,b,c,1,2,3</code></td>
</tr>
<tr>
<td style="text-align:center">2.</td>
<td style="text-align:center">every()检测数值元素的每个元素是否都符合条件。</td>
<td style="text-align:center"><code>function isBigEnough(element, index, array) {         return (element &gt;= 10);  }          var passed = [12, 5, 8, 130, 44].every(isBigEnough);  console.log(&quot;Test Value : &quot; + passed ); // false</code></td>
</tr>
<tr>
<td style="text-align:center">3.</td>
<td style="text-align:center">filter()检测数值元素，并返回符合条件所有元素的数组。</td>
<td style="text-align:center"><code>function isBigEnough(element, index, array) {    return (element &gt;= 10);  }            var passed = [12, 5, 8, 130, 44].filter(isBigEnough);  console.log(&quot;Test Value : &quot; + passed ); // 12,130,44</code></td>
</tr>
<tr>
<td style="text-align:center">4.</td>
<td style="text-align:center">forEach()数组每个元素都执行一次回调函数。</td>
<td style="text-align:center"><code>let num = [7, 8, 9]; num.forEach(function (value) {    console.log(value); });</code>编译成 JavaScript 代码：<code>var num = [7, 8, 9]; num.forEach(function (value) {    console.log(value);  // 7   8   9 });</code></td>
</tr>
<tr>
<td style="text-align:center">5.</td>
<td style="text-align:center">indexOf()搜索数组中的元素，并返回它所在的位置。</td>
<td style="text-align:center"><code>var index = [12, 5, 8, 130, 44].indexOf(8);  console.log(&quot;index is : &quot; + index );  // 2</code></td>
</tr>
<tr>
<td style="text-align:center">6.</td>
<td style="text-align:center">join()把数组的所有元素放入一个字符串。</td>
<td style="text-align:center"><code>var arr = new Array(&quot;First&quot;,&quot;Second&quot;,&quot;Third&quot;);            var str = arr.join();  console.log(&quot;str : &quot; + str );  // First,Second,Third            var str = arr.join(&quot;, &quot;);  console.log(&quot;str : &quot; + str );  // First, Second, Third           var str = arr.join(&quot; + &quot;);  console.log(&quot;str : &quot; + str );  // First + Second + Third</code></td>
</tr>
<tr>
<td style="text-align:center">7.</td>
<td style="text-align:center">lastIndexOf()返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。</td>
<td style="text-align:center"><code>var index = [12, 5, 8, 130, 44].lastIndexOf(8);  console.log(&quot;index is : &quot; + index );  // 2</code></td>
</tr>
<tr>
<td style="text-align:center">8.</td>
<td style="text-align:center">map()通过指定函数处理数组的每个元素，并返回处理后的数组。</td>
<td style="text-align:center"><code>var numbers = [1, 4, 9];  var roots = numbers.map(Math.sqrt);  console.log(&quot;roots is : &quot; + roots );  // 1,2,3</code></td>
</tr>
<tr>
<td style="text-align:center">9.</td>
<td style="text-align:center">pop()删除数组的最后一个元素并返回删除的元素。</td>
<td style="text-align:center"><code>var numbers = [1, 4, 9];            var element = numbers.pop();  console.log(&quot;element is : &quot; + element );  // 9           var element = numbers.pop();  console.log(&quot;element is : &quot; + element );  // 4</code></td>
</tr>
<tr>
<td style="text-align:center">10.</td>
<td style="text-align:center">push()向数组的末尾添加一个或更多元素，并返回新的长度。</td>
<td style="text-align:center"><code>var numbers = new Array(1, 4, 9);  var length = numbers.push(10);  console.log(&quot;new numbers is : &quot; + numbers );  // 1,4,9,10  length = numbers.push(20);  console.log(&quot;new numbers is : &quot; + numbers );  // 1,4,9,10,20</code></td>
</tr>
<tr>
<td style="text-align:center">11.</td>
<td style="text-align:center">reduce()将数组元素计算为一个值（从左到右）。</td>
<td style="text-align:center"><code>var total = [0, 1, 2, 3].reduce(function(a, b){ return a + b; });  console.log(&quot;total is : &quot; + total );  // 6</code></td>
</tr>
<tr>
<td style="text-align:center">12.</td>
<td style="text-align:center">reduceRight()将数组元素计算为一个值（从右到左）。</td>
<td style="text-align:center"><code>var total = [0, 1, 2, 3].reduceRight(function(a, b){ return a + b; });  console.log(&quot;total is : &quot; + total );  // 6</code></td>
</tr>
<tr>
<td style="text-align:center">13.</td>
<td style="text-align:center">reverse()反转数组的元素顺序。</td>
<td style="text-align:center"><code>var arr = [0, 1, 2, 3].reverse();  console.log(&quot;Reversed array is : &quot; + arr );  // 3,2,1,0</code></td>
</tr>
<tr>
<td style="text-align:center">14.</td>
<td style="text-align:center">shift()删除并返回数组的第一个元素。</td>
<td style="text-align:center"><code>var arr = [10, 1, 2, 3].shift();  console.log(&quot;Shifted value is : &quot; + arr );  // 10</code></td>
</tr>
<tr>
<td style="text-align:center">15.</td>
<td style="text-align:center">slice()选取数组的的一部分，并返回一个新数组。</td>
<td style="text-align:center"><code>var arr = [&quot;orange&quot;, &quot;mango&quot;, &quot;banana&quot;, &quot;sugar&quot;, &quot;tea&quot;];  console.log(&quot;arr.slice( 1, 2) : &quot; + arr.slice( 1, 2) );  // mango console.log(&quot;arr.slice( 1, 3) : &quot; + arr.slice( 1, 3) );  // mango,banana</code></td>
</tr>
<tr>
<td style="text-align:center">16.</td>
<td style="text-align:center">some()检测数组元素中是否有元素符合指定条件。</td>
<td style="text-align:center"><code>function isBigEnough(element, index, array) {    return (element &gt;= 10);            }            var retval = [2, 5, 8, 1, 4].some(isBigEnough); console.log(&quot;Returned value is : &quot; + retval );  // false           var retval = [12, 5, 8, 1, 4].some(isBigEnough);  console.log(&quot;Returned value is : &quot; + retval );  // true</code></td>
</tr>
<tr>
<td style="text-align:center">17.</td>
<td style="text-align:center">sort()对数组的元素进行排序。</td>
<td style="text-align:center"><code>var arr = new Array(&quot;orange&quot;, &quot;mango&quot;, &quot;banana&quot;, &quot;sugar&quot;);  var sorted = arr.sort();  console.log(&quot;Returned string is : &quot; + sorted );  // banana,mango,orange,sugar</code></td>
</tr>
<tr>
<td style="text-align:center">18.</td>
<td style="text-align:center">splice()从数组中添加或删除元素。</td>
<td style="text-align:center"><code>var arr = [&quot;orange&quot;, &quot;mango&quot;, &quot;banana&quot;, &quot;sugar&quot;, &quot;tea&quot;];   var removed = arr.splice(2, 0, &quot;water&quot;);   console.log(&quot;After adding 1: &quot; + arr );    // orange,mango,water,banana,sugar,tea  console.log(&quot;removed is: &quot; + removed);            removed = arr.splice(3, 1);   console.log(&quot;After removing 1: &quot; + arr );  // orange,mango,water,sugar,tea  console.log(&quot;removed is: &quot; + removed);  // banana</code></td>
</tr>
<tr>
<td style="text-align:center">19.</td>
<td style="text-align:center">toString()把数组转换为字符串，并返回结果。</td>
<td style="text-align:center"><code>var arr = new Array(&quot;orange&quot;, &quot;mango&quot;, &quot;banana&quot;, &quot;sugar&quot;);          var str = arr.toString();  console.log(&quot;Returned string is : &quot; + str );  // orange,mango,banana,sugar</code></td>
</tr>
<tr>
<td style="text-align:center">20.</td>
<td style="text-align:center">unshift()向数组的开头添加一个或更多元素，并返回新的长度。</td>
<td style="text-align:center"><code>var arr = new Array(&quot;orange&quot;, &quot;mango&quot;, &quot;banana&quot;, &quot;sugar&quot;);  var length = arr.unshift(&quot;water&quot;);  console.log(&quot;Returned array is : &quot; + arr );  // water,orange,mango,banana,sugar  console.log(&quot;Length of the array is : &quot; + length ); // 5</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组中允许存储不同类型的元素，元组可以作为参数传递给函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tuple_name = [value1,value2,value3,…value n]</span><br></pre></td></tr></table></figure>
<p>两个函数向元组添加新元素或者删除元素：</p>
<ul>
<li>push() 向元组添加元素，添加在最后面。</li>
<li>pop() 从元组中移除元素（最后一个），并返回移除的元素。</li>
</ul>
<p>解构元组</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a =[<span class="number">10</span>,<span class="string">"Runoob"</span>] </span><br><span class="line"><span class="keyword">var</span> [b,c] = a </span><br><span class="line"><span class="built_in">console</span>.log( b )    </span><br><span class="line"><span class="built_in">console</span>.log( c )</span><br></pre></td></tr></table></figure>
<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型（Union Types）可以通过管道(|)将变量设置多种类型，赋值时可以根据设置的类型来赋值。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">Type1|Type2|Type3</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> val:<span class="built_in">string</span>|<span class="built_in">number</span> </span><br><span class="line">val = <span class="number">12</span> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"数字为 "</span>+ val) </span><br><span class="line">val = <span class="string">"Runoob"</span> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"字符串为 "</span> + val)</span><br></pre></td></tr></table></figure>
<p>将数组声明为联合类型：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr:<span class="built_in">number</span>[]|<span class="built_in">string</span>[]; </span><br><span class="line"><span class="keyword">var</span> i:<span class="built_in">number</span>; </span><br><span class="line">arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>] </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"**数字数组**"</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;arr.length;i++) &#123; </span><br><span class="line">   <span class="built_in">console</span>.log(arr[i]) </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line">arr = [<span class="string">"Runoob"</span>,<span class="string">"Google"</span>,<span class="string">"Taobao"</span>] </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"**字符串数字**"</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;arr.length;i++) &#123; </span><br><span class="line">   <span class="built_in">console</span>.log(arr[i]) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> interface_name &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123; </span><br><span class="line">    firstName:<span class="built_in">string</span>, </span><br><span class="line">    lastName:<span class="built_in">string</span>, </span><br><span class="line">    sayHi: <span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">string</span> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> customer:IPerson = &#123; </span><br><span class="line">    firstName:<span class="string">"Tom"</span>,</span><br><span class="line">    lastName:<span class="string">"Hanks"</span>, </span><br><span class="line">    sayHi: ():<span class="function"><span class="params">string</span> =&gt;</span>&#123;<span class="keyword">return</span> <span class="string">"Hi there"</span>&#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Customer 对象 "</span>) </span><br><span class="line"><span class="built_in">console</span>.log(customer.firstName) </span><br><span class="line"><span class="built_in">console</span>.log(customer.lastName) </span><br><span class="line"><span class="built_in">console</span>.log(customer.sayHi())  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> employee:IPerson = &#123; </span><br><span class="line">    firstName:<span class="string">"Jim"</span>,</span><br><span class="line">    lastName:<span class="string">"Blakes"</span>, </span><br><span class="line">    sayHi: ():<span class="function"><span class="params">string</span> =&gt;</span>&#123;<span class="keyword">return</span> <span class="string">"Hello!!!"</span>&#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Employee  对象 "</span>) </span><br><span class="line"><span class="built_in">console</span>.log(employee.firstName) </span><br><span class="line"><span class="built_in">console</span>.log(employee.lastName)</span><br></pre></td></tr></table></figure>
<p>编译得到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> customer = &#123;</span><br><span class="line">    firstName: <span class="string">"Tom"</span>,</span><br><span class="line">    lastName: <span class="string">"Hanks"</span>,</span><br><span class="line">    sayHi: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">"Hi there"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Customer 对象 "</span>);</span><br><span class="line"><span class="built_in">console</span>.log(customer.firstName);</span><br><span class="line"><span class="built_in">console</span>.log(customer.lastName);</span><br><span class="line"><span class="built_in">console</span>.log(customer.sayHi());</span><br><span class="line"><span class="keyword">var</span> employee = &#123;</span><br><span class="line">    firstName: <span class="string">"Jim"</span>,</span><br><span class="line">    lastName: <span class="string">"Blakes"</span>,</span><br><span class="line">    sayHi: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">"Hello!!!"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Employee  对象 "</span>);</span><br><span class="line"><span class="built_in">console</span>.log(employee.firstName);</span><br><span class="line"><span class="built_in">console</span>.log(employee.lastName);</span><br></pre></td></tr></table></figure>
<p>联合类型和接口</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> RunOptions &#123; </span><br><span class="line">    program:<span class="built_in">string</span>; </span><br><span class="line">    commandline:<span class="built_in">string</span>[]|<span class="built_in">string</span>|<span class="function">(<span class="params">(<span class="params"></span>)=&gt;<span class="built_in">string</span></span>); </span></span><br><span class="line"><span class="function">&#125; </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">// <span class="params">commandline</span> 是字符串</span></span><br><span class="line"><span class="function"><span class="params">var</span> <span class="params">options</span>:<span class="params">RunOptions</span> = &#123;<span class="params">program</span>:"<span class="params">test1</span>",<span class="params">commandline</span>:"<span class="params">Hello</span>"&#125;; </span></span><br><span class="line"><span class="function"><span class="params">console</span>.<span class="params">log</span>(<span class="params">options.commandline</span>)  </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">// <span class="params">commandline</span> 是字符串数组</span></span><br><span class="line"><span class="function"><span class="params">options</span> = &#123;<span class="params">program</span>:"<span class="params">test1</span>",<span class="params">commandline</span>:["<span class="params">Hello</span>","<span class="params">World</span>"]&#125;; </span></span><br><span class="line"><span class="function"><span class="params">console</span>.<span class="params">log</span>(<span class="params">options.commandline[0]</span>); </span></span><br><span class="line"><span class="function"><span class="params">console</span>.<span class="params">log</span>(<span class="params">options.commandline[1]</span>);  </span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">// <span class="params">commandline</span> 是一个函数表达式</span></span><br><span class="line"><span class="function"><span class="params">options</span> = &#123;<span class="params">program</span>:"<span class="params">test1</span>",<span class="params">commandline</span>:<span class="params">()</span>=&gt;</span>&#123;<span class="keyword">return</span> <span class="string">"**Hello World**"</span>;&#125;&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> fn:<span class="built_in">any</span> = options.commandline; </span><br><span class="line"><span class="built_in">console</span>.log(fn());</span><br></pre></td></tr></table></figure>
<p>编译得到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// commandline 是字符串</span></span><br><span class="line"><span class="keyword">var</span> options = &#123; <span class="attr">program</span>: <span class="string">"test1"</span>, <span class="attr">commandline</span>: <span class="string">"Hello"</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(options.commandline);</span><br><span class="line"><span class="comment">// commandline 是字符串数组</span></span><br><span class="line">options = &#123; <span class="attr">program</span>: <span class="string">"test1"</span>, <span class="attr">commandline</span>: [<span class="string">"Hello"</span>, <span class="string">"World"</span>] &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(options.commandline[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(options.commandline[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">// commandline 是一个函数表达式</span></span><br><span class="line">options = &#123; <span class="attr">program</span>: <span class="string">"test1"</span>, <span class="attr">commandline</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">"**Hello World**"</span>; &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> fn = options.commandline;</span><br><span class="line"><span class="built_in">console</span>.log(fn());</span><br></pre></td></tr></table></figure>
<p>接口和数组</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> namelist &#123; </span><br><span class="line">   [index:<span class="built_in">number</span>]:<span class="built_in">string</span> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> list2:namelist = [<span class="string">"John"</span>,<span class="number">1</span>,<span class="string">"Bran"</span>] / 错误元素 <span class="number">1</span> 不是 <span class="built_in">string</span> 类型</span><br><span class="line"><span class="keyword">interface</span> ages &#123; </span><br><span class="line">   [index:<span class="built_in">string</span>]:<span class="built_in">number</span> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> agelist:ages; </span><br><span class="line">agelist[<span class="string">"John"</span>] = <span class="number">15</span>   <span class="comment">// 正确 </span></span><br><span class="line">agelist[<span class="number">2</span>] = <span class="string">"nine"</span>   <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>接口继承</p>
<p>接口继承就是说接口可以通过其他接口来扩展自己。</p>
<p>Typescript 允许接口继承多个接口。</p>
<p>继承使用关键字 <strong>extends</strong>。</p>
<p>单接口继承语法格式：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">Child_interface_name <span class="keyword">extends</span> super_interface_name</span><br></pre></td></tr></table></figure>
<p>多接口继承语法格式：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">Child_interface_name <span class="keyword">extends</span> super_interface1_name, super_interface2_name,…,super_interfaceN_name</span><br></pre></td></tr></table></figure>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>TypeScript 是面向对象的 JavaScript。</p>
<p>类描述了所创建的对象共同的属性和方法。</p>
<p>TypeScript 支持面向对象的所有特性，比如 类、接口等。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> class_name &#123; </span><br><span class="line">    <span class="comment">// 类作用域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义类的关键字为 class，后面紧跟类名，类可以包含以下几个模块（类的数据成员）：</p>
<ul>
<li><strong>字段</strong> − 字段是类里面声明的变量。字段表示对象的有关数据。</li>
<li><strong>构造函数</strong> − 类实例化时调用，可以为类的对象分配内存。</li>
<li><strong>方法</strong> − 方法为对象要执行的操作。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Car &#123; </span><br><span class="line">    <span class="comment">// 字段 </span></span><br><span class="line">    engine:<span class="built_in">string</span>; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 构造函数 </span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">engine:<span class="built_in">string</span></span>) &#123; </span><br><span class="line">        <span class="keyword">this</span>.engine = engine </span><br><span class="line">    &#125;  </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 方法 </span></span><br><span class="line">    disp():<span class="built_in">void</span> &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"发动机为 :   "</span>+<span class="keyword">this</span>.engine) </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译得到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Car = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数 </span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">engine</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法 </span></span><br><span class="line">    Car.prototype.disp = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"发动机为 :   "</span> + <span class="keyword">this</span>.engine);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> Car;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>创建实例化对象</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> object_name = <span class="keyword">new</span> class_name([ <span class="built_in">arguments</span> ])</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">obj.field_name </span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问方法</span></span><br><span class="line">obj.function_name()</span><br></pre></td></tr></table></figure>
<p>完整案例</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Car &#123; </span><br><span class="line">   <span class="comment">// 字段</span></span><br><span class="line">   engine:<span class="built_in">string</span>; </span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 构造函数</span></span><br><span class="line">   <span class="keyword">constructor</span>(<span class="params">engine:<span class="built_in">string</span></span>) &#123; </span><br><span class="line">      <span class="keyword">this</span>.engine = engine </span><br><span class="line">   &#125;  </span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 方法</span></span><br><span class="line">   disp():<span class="built_in">void</span> &#123; </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"函数中显示发动机型号  :   "</span>+<span class="keyword">this</span>.engine) </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建一个对象</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Car(<span class="string">"XXSY1"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 访问字段</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"读取发动机型号 :  "</span>+obj.engine)  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 访问方法</span></span><br><span class="line">obj.disp()</span><br></pre></td></tr></table></figure>
<p>TypeScript 支持继承类，即我们可以在创建类的时候继承一个已存在的类，这个已存在的类称为父类，继承它的类称为子类。</p>
<p>类继承使用关键字 <strong>extends</strong>，子类除了不能继承父类的私有成员(方法和属性)和构造函数，其他的都可以继承。</p>
<p>TypeScript 一次只能继承一个类，不支持继承多个类，但 TypeScript 支持多重继承（A 继承 B，B 继承 C）。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> child_class_name <span class="keyword">extends</span> parent_class_name</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Shape &#123; </span><br><span class="line">   Area:<span class="built_in">number</span> </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">constructor</span>(<span class="params">a:<span class="built_in">number</span></span>) &#123; </span><br><span class="line">      <span class="keyword">this</span>.Area = a </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> Circle <span class="keyword">extends</span> Shape &#123; </span><br><span class="line">   disp():<span class="built_in">void</span> &#123; </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"圆的面积:  "</span>+<span class="keyword">this</span>.Area) </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Circle(<span class="number">223</span>); </span><br><span class="line">obj.disp()</span><br></pre></td></tr></table></figure>
<p>类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。</p>
<p>其中 super 关键字是对父类的直接引用，该关键字可以引用父类的属性和方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> PrinterClass &#123; </span><br><span class="line">   doPrint():<span class="built_in">void</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"父类的 doPrint() 方法。"</span>) </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> StringPrinter <span class="keyword">extends</span> PrinterClass &#123; </span><br><span class="line">   doPrint():<span class="built_in">void</span> &#123; </span><br><span class="line">      <span class="keyword">super</span>.doPrint() <span class="comment">// 调用父类的函数</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"子类的 doPrint()方法。"</span>)</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>static 关键字用于定义类的数据成员（属性和方法）为静态的，静态成员可以直接通过类名调用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> StaticMem &#123;  </span><br><span class="line">   <span class="keyword">static</span> num:<span class="built_in">number</span>; </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">static</span> disp():<span class="built_in">void</span> &#123; </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"num 值为 "</span>+ StaticMem.num) </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">StaticMem.num = <span class="number">12</span>     <span class="comment">// 初始化静态变量</span></span><br><span class="line">StaticMem.disp()</span><br></pre></td></tr></table></figure>
<p>instanceof 运算符用于判断对象是否是指定的类型，如果是返回 true，否则返回 false。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person&#123; &#125; </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person() </span><br><span class="line"><span class="keyword">var</span> isPerson = obj <span class="keyword">instanceof</span> Person; </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"obj 对象是 Person 类实例化来的吗？ "</span> + isPerson);</span><br></pre></td></tr></table></figure>
<p>TypeScript 中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。TypeScript 支持 3 种不同的访问权限。</p>
<ul>
<li><strong>public（默认）</strong> : 公有，可以在任何地方被访问。</li>
<li><strong>protected</strong> : 受保护，可以被其自身以及其子类和父类访问。</li>
<li><strong>private</strong> : 私有，只能被其定义所在的类访问。</li>
</ul>
<p>类可以实现接口，使用关键字 implements，并将 interest 字段作为类的属性使用。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ILoan &#123; </span><br><span class="line">   interest:<span class="built_in">number</span> </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> AgriLoan <span class="keyword">implements</span> ILoan &#123; </span><br><span class="line">   interest:<span class="built_in">number</span> </span><br><span class="line">   rebate:<span class="built_in">number</span> </span><br><span class="line">   </span><br><span class="line">   <span class="keyword">constructor</span>(<span class="params">interest:<span class="built_in">number</span>,rebate:<span class="built_in">number</span></span>) &#123; </span><br><span class="line">      <span class="keyword">this</span>.interest = interest </span><br><span class="line">      <span class="keyword">this</span>.rebate = rebate </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> AgriLoan(<span class="number">10</span>,<span class="number">1</span>) </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"利润为 : "</span>+obj.interest+<span class="string">"，抽成为 : "</span>+obj.rebate )</span><br></pre></td></tr></table></figure>
<p>对象是包含一组键值对的实例。 值可以是标量、函数、数组、对象等，如下实例：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> object_name = &#123; </span><br><span class="line">    key1: <span class="string">"value1"</span>, <span class="comment">// 标量</span></span><br><span class="line">    key2: <span class="string">"value"</span>,  </span><br><span class="line">    key3: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 函数</span></span><br><span class="line">    &#125;, </span><br><span class="line">    key4:[<span class="string">"content1"</span>, <span class="string">"content2"</span>] <span class="comment">//集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sites = &#123;</span><br><span class="line">    site1: <span class="string">"Runoob"</span>,</span><br><span class="line">    site2: <span class="string">"Google"</span>,</span><br><span class="line">    sayHello: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125; <span class="comment">// 类型模板</span></span><br><span class="line">&#125;;</span><br><span class="line">sites.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello "</span> + sites.site1);</span><br><span class="line">&#125;;</span><br><span class="line">sites.sayHello();</span><br></pre></td></tr></table></figure>
<p>对象也可以作为一个参数传递给函数</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sites = &#123; </span><br><span class="line">    site1:<span class="string">"Runoob"</span>, </span><br><span class="line">    site2:<span class="string">"Google"</span>,</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">var</span> invokesites = <span class="function"><span class="keyword">function</span>(<span class="params">obj: &#123; site1:<span class="built_in">string</span>, site2 :<span class="built_in">string</span> &#125;</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"site1 :"</span>+obj.site1) </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"site2 :"</span>+obj.site2) </span><br><span class="line">&#125; </span><br><span class="line">invokesites(sites)</span><br></pre></td></tr></table></figure>
<p>鸭子类型（Duck Typing）</p>
<p>鸭子类型（英语：duck typing）是动态类型的一种风格，是多态(polymorphism)的一种形式。</p>
<p>在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前方法和属性的集合”决定。</p>
<p>在鸭子类型中，关注点在于对象的行为，能作什么；而不是关注对象所属的类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPoint &#123; </span><br><span class="line">    x:<span class="built_in">number</span> </span><br><span class="line">    y:<span class="built_in">number</span> </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addPoints</span>(<span class="params">p1:IPoint,p2:IPoint</span>):<span class="title">IPoint</span> </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> x = p1.x + p2.x </span><br><span class="line">    <span class="keyword">var</span> y = p1.y + p2.y </span><br><span class="line">    <span class="keyword">return</span> &#123;x:x,y:y&#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> newPoint = addPoints(&#123;x:<span class="number">3</span>,y:<span class="number">4</span>&#125;,&#123;x:<span class="number">5</span>,y:<span class="number">1</span>&#125;)  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 错误 </span></span><br><span class="line"><span class="keyword">var</span> newPoint2 = addPoints(&#123;x:<span class="number">1</span>&#125;,&#123;x:<span class="number">4</span>,y:<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>命名空间一个最明确的目的就是解决重名问题。</p>
<p>TypeScript 中命名空间使用 <strong>namespace</strong> 来定义，语法格式如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SomeNameSpaceName &#123; </span><br><span class="line">   <span class="keyword">export</span> <span class="keyword">interface</span> ISomeInterfaceName &#123;      &#125;  </span><br><span class="line">   <span class="keyword">export</span> <span class="keyword">class</span> SomeClassName &#123;      &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上定义了一个命名空间 SomeNameSpaceName，如果我们需要在外部可以调用 SomeNameSpaceName 中的类和接口，则需要在类和接口添加 <strong>export</strong> 关键字。</p>
<p>要在另外一个命名空间调用语法格式为：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">SomeNameSpaceName.SomeClassName;</span><br></pre></td></tr></table></figure>
<p>如果一个命名空间在一个单独的 TypeScript 文件中，则应使用三斜杠 /// 引用它，语法格式如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path = "SomeFileName.ts" /&gt;</span></span><br></pre></td></tr></table></figure>
<p>IShape.ts 文件代码</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Drawing &#123; </span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">interface</span> IShape &#123; </span><br><span class="line">        draw(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Circle.ts 文件嗲名</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path = "IShape.ts" /&gt; </span></span><br><span class="line"><span class="keyword">namespace</span> Drawing &#123; </span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> Circle <span class="keyword">implements</span> IShape &#123; </span><br><span class="line">        <span class="keyword">public</span> draw() &#123; </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Circle is drawn"</span>); </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Triangle.ts 文件代码</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path = "IShape.ts" /&gt; </span></span><br><span class="line"><span class="keyword">namespace</span> Drawing &#123; </span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> Triangle <span class="keyword">implements</span> IShape &#123; </span><br><span class="line">        <span class="keyword">public</span> draw() &#123; </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Triangle is drawn"</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path = "IShape.ts" /&gt;   </span></span><br><span class="line"><span class="comment">/// &lt;reference path = "Circle.ts" /&gt; </span></span><br><span class="line"><span class="comment">/// &lt;reference path = "Triangle.ts" /&gt;  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawAllShapes</span>(<span class="params">shape:Drawing.IShape</span>) </span>&#123; </span><br><span class="line">    shape.draw(); </span><br><span class="line">&#125; </span><br><span class="line">drawAllShapes(<span class="keyword">new</span> Drawing.Circle());</span><br><span class="line">drawAllShapes(<span class="keyword">new</span> Drawing.Triangle());</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tsc --out app.js TestShape.ts</span><br></pre></td></tr></table></figure>
<p>得到</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path = "IShape.ts" /&gt; </span></span><br><span class="line"><span class="keyword">var</span> Drawing;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Drawing</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Circle = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        Circle.prototype.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Circle is drawn"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> Circle;</span><br><span class="line">    &#125;());</span><br><span class="line">    Drawing.Circle = Circle;</span><br><span class="line">&#125;)(Drawing || (Drawing = &#123;&#125;));</span><br><span class="line"><span class="comment">/// &lt;reference path = "IShape.ts" /&gt; </span></span><br><span class="line"><span class="keyword">var</span> Drawing;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Drawing</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Triangle = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Triangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        Triangle.prototype.draw = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Triangle is drawn"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> Triangle;</span><br><span class="line">    &#125;());</span><br><span class="line">    Drawing.Triangle = Triangle;</span><br><span class="line">&#125;)(Drawing || (Drawing = &#123;&#125;));</span><br><span class="line"><span class="comment">/// &lt;reference path = "IShape.ts" /&gt;   </span></span><br><span class="line"><span class="comment">/// &lt;reference path = "Circle.ts" /&gt; </span></span><br><span class="line"><span class="comment">/// &lt;reference path = "Triangle.ts" /&gt;  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawAllShapes</span>(<span class="params">shape</span>) </span>&#123;</span><br><span class="line">    shape.draw();</span><br><span class="line">&#125;</span><br><span class="line">drawAllShapes(<span class="keyword">new</span> Drawing.Circle());</span><br><span class="line">drawAllShapes(<span class="keyword">new</span> Drawing.Triangle());</span><br></pre></td></tr></table></figure>
<p>命名空间支持嵌套，即你可以将命名空间定义在另外一个命名空间里头。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> namespace_name1 &#123; </span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">namespace</span> namespace_name2 &#123;</span><br><span class="line">        <span class="keyword">export</span> <span class="keyword">class</span> class_name &#123;    &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>TypeScript 模块的设计理念是可以更换的组织代码。</p>
<p>模块是在其自身的作用域里执行，并不是在全局作用域，这意味着定义在模块里面的变量、函数和类等在模块外部是不可见的，除非明确地使用 export 导出它们。类似地，我们必须通过 import 导入其他模块导出的变量、函数、类等。</p>
<p>两个模块之间的关系是通过在文件级别上使用 import 和 export 建立的。</p>
<p>模块使用模块加载器去导入其它的模块。 在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块的所有依赖。</p>
<p>模块导出使用关键字 <strong>export</strong> 关键字，语法格式如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件名 : SomeInterface.ts </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> SomeInterface &#123; </span><br><span class="line">   <span class="comment">// 代码部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> someInterfaceRef = <span class="built_in">require</span>(<span class="string">"./SomeInterface"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h2><blockquote>
<p>TypeScript 作为 JavaScript 的超集，在开发过程中不可避免要引用其他第三方的 JavaScript 的库。虽然通过直接引用可以调用库的类和方法，但是却无法使用TypeScript 诸如类型检查等特性功能。为了解决这个问题，需要将这些库里的函数和方法体去掉后只保留导出类型声明，而产生了一个描述 JavaScript 库和模块信息的声明文件。通过引用这个声明文件，就可以借用 TypeScript 的各种特性来使用库文件了。</p>
</blockquote>
<p>假如我们想使用第三方库，比如 jQuery，我们通常这样获取一个 id 是 foo 的元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&#39;#foo&#39;);</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">jQuery(&#39;#foo&#39;);</span><br></pre></td></tr></table></figure>
<p>但是在 TypeScript 中，我们并不知道 $ 或 jQuery 是什么东西：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery(&#39;#foo&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; index.ts(1,1): error TS2304: Cannot find name &#39;jQuery&#39;.</span><br></pre></td></tr></table></figure>
<p>这时，我们需要使用 declare 关键字来定义它的类型，帮助 TypeScript 判断我们传入的参数类型对不对：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare var jQuery: (selector: string) &#x3D;&gt; any;</span><br><span class="line"></span><br><span class="line">jQuery(&#39;#foo&#39;);</span><br></pre></td></tr></table></figure>
<p>declare 定义的类型只会用于编译时的检查，编译结果中会被删除。</p>
<p>上例的编译结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery(&#39;#foo&#39;);</span><br></pre></td></tr></table></figure>
<p>声明文件以 <strong>.d.ts</strong> 为后缀，例如：</p>
<p>声明文件或模块的语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">declare module Module_Name &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TypeScript 引入声明文件语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;reference path &#x3D; &quot; runoob.d.ts&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>当然，很多流行的第三方库的声明文件不需要我们定义了，比如 jQuery 已经有人帮我们定义好了：<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/jquery/index.d.ts" target="_blank" rel="noopener">jQuery in DefinitelyTyped</a>。</p>
<p>CalcThirdPartyJsLib.js 文件代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Runoob;  </span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">Runoob</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Calc = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Calc</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;)</span><br><span class="line">    Calc.prototype.doSum = <span class="function"><span class="keyword">function</span> (<span class="params">limit</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= limit; i++) &#123; </span><br><span class="line">            sum = sum + i; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum; </span><br><span class="line">    &#125;</span><br><span class="line">    Runoob.Calc = Calc; </span><br><span class="line">    <span class="keyword">return</span> Calc; </span><br><span class="line">&#125;)(Runoob || (Runoob = &#123;&#125;)); </span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Runoob.Calc();</span><br></pre></td></tr></table></figure>
<p>Calc.d.ts 文件代码</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> Runoob &#123; </span><br><span class="line">   <span class="keyword">export</span> <span class="keyword">class</span> Calc &#123; </span><br><span class="line">      doSum(limit:<span class="built_in">number</span>) : <span class="built_in">number</span>; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明文件不包含实现，它只是类型声明，把声明文件加入到 TypeScript 中：</p>
<p>CalcTest.ts 文件代码</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path = "Calc.d.ts" /&gt; </span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Runoob.Calc(); </span><br><span class="line"><span class="comment">// obj.doSum("Hello"); // 编译错误</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.doSum(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.runoob.com/typescript" target="_blank" rel="noopener">https://www.runoob.com/typescript</a></p>
<p>大部分资料来源于上面网站</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
  </entry>
  <entry>
    <title>neo4j基础教程</title>
    <url>/2020/02/18/neo4j%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="Neo4j-教程-基础版"><a href="#Neo4j-教程-基础版" class="headerlink" title="Neo4j 教程 基础版"></a>Neo4j 教程 基础版</h1><h2 id="Create-a-node"><a href="#Create-a-node" class="headerlink" title="Create a node"></a>Create a node</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE (ee:Person &#123; name: &quot;Emil&quot;, from: &quot;China&quot;, Age: 22&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>CREATE</code> : create data</li>
<li><code>()</code>: indicate a node</li>
<li><code>ee:Person</code>: a variable ‘ee’ and label ‘Person’ for the new node</li>
<li>brackets to add properties to the node</li>
</ul>
<h2 id="Finding-nodes"><a href="#Finding-nodes" class="headerlink" title="Finding nodes"></a>Finding nodes</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MATCH (ee:Person) WHERE ee.name&#x3D;&quot;Emil&quot; RETURN ee;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>MATCH</code>: specify a pattern of nodes and relationship</li>
<li><code>(ee:Person)</code>: a single node pattern with label ‘Person’ which will assign matches to the variable ‘ee’ </li>
<li><code>WHERE</code>: constrain results</li>
<li><code>ee.name=&quot;Emil&quot;</code>: compare name property to the value ‘Emil’</li>
<li><code>RETURN</code>: request particular results</li>
</ul>
<h2 id="Create-more"><a href="#Create-more" class="headerlink" title="Create more"></a>Create more</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MATCH (ee:Person) WHERE ee.name &#x3D; &quot;Emil&quot;</span><br><span class="line">CREATE (js:Person &#123; name: &quot;Johan&quot;, from: &quot;Sweden&quot;, learn: &quot;surfing&quot; &#125;),</span><br><span class="line">(ir:Person &#123; name: &quot;Ian&quot;, from: &quot;England&quot;, title: &quot;author&quot; &#125;),</span><br><span class="line">(rvb:Person &#123; name: &quot;Rik&quot;, from: &quot;Belgium&quot;, pet: &quot;Orval&quot; &#125;),</span><br><span class="line">(ally:Person &#123; name: &quot;Allison&quot;, from: &quot;California&quot;, hobby: &quot;surfing&quot; &#125;),</span><br><span class="line">(ee)-[:KNOWS &#123;since: 2001&#125;]-&gt;(js),(ee)-[:KNOWS &#123;rating: 5&#125;]-&gt;(ir),</span><br><span class="line">(js)-[:KNOWS]-&gt;(ir),(js)-[:KNOWS]-&gt;(rvb),</span><br><span class="line">(ir)-[:KNOWS]-&gt;(js),(ir)-[:KNOWS]-&gt;(ally),</span><br><span class="line">(rvb)-[:KNOWS]-&gt;(ally)</span><br></pre></td></tr></table></figure>
<p> create many nodes and relationships at once.</p>
<h2 id="Pattern-matching"><a href="#Pattern-matching" class="headerlink" title="Pattern matching"></a>Pattern matching</h2><p>Describe what to find in the graph</p>
<p>For instance, a pattern can be used to find Emil’s friends:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MATCH (ee:Person)-[:KNOWS]-(friends)</span><br><span class="line">WHERE ee.name &#x3D; &quot;Emil&quot; RETURN ee, friends</span><br></pre></td></tr></table></figure>
<ul>
<li><code>MATCH</code>clause to describe the pattern from known Nodes to found Nodes</li>
<li><code>(ee)</code>starts the pattern with a Person (qualified by WHERE)</li>
<li><code>-[:KNOWS]-</code>matches “KNOWS” relationships (in either direction)</li>
<li><code>(friends)</code>will be bound to Emil’s friends </li>
</ul>
<h2 id="Recommend"><a href="#Recommend" class="headerlink" title="Recommend"></a>Recommend</h2><p>Using patterns</p>
<p>Pattern matching can be used to make recommendations. Johan is learning to surf, so he may want to find a new friend who already does:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MATCH (js:Person)-[:KNOWS]-()-[:KNOWS]-(surfer)</span><br><span class="line">WHERE js.name &#x3D; &quot;Johan&quot; AND surfer.hobby &#x3D; &quot;surfing&quot;</span><br><span class="line">RETURN DISTINCT surfer</span><br></pre></td></tr></table></figure>
<ul>
<li><code>()</code>empty parenthesis to ignore these nodes</li>
<li><code>DISTINCT</code>because more than one path will match the pattern</li>
<li><code>surfer</code>will contain Allison, a friend of a friend who surfs</li>
</ul>
<h2 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h2><p>Using the visual query plan</p>
<p>Understand how your query works by prepending <code>EXPLAIN</code> or <code>PROFILE</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PROFILE MATCH (js:Person)-[:KNOWS]-()-[:KNOWS]-(surfer)</span><br><span class="line">WHERE js.name &#x3D; &quot;Johan&quot; AND surfer.hobby &#x3D; &quot;surfing&quot;</span><br><span class="line">RETURN DISTINCT surfer</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>vim基本操作</title>
    <url>/2019/12/01/vim%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="vim-基础操作"><a href="#vim-基础操作" class="headerlink" title="vim 基础操作"></a>vim 基础操作</h1><blockquote>
<p>来源于 <code>vimtutor</code></p>
</blockquote>
<a id="more"></a>
<h2 id="第一讲小结"><a href="#第一讲小结" class="headerlink" title="第一讲小结"></a>第一讲小结</h2><ol>
<li><p>光标在屏幕文本中的移动既可以用箭头键，也可以使用 <code>hjkl</code> 字母键。</p>
<ul>
<li>h (左移)</li>
<li>j (下行)</li>
<li>k (上行)</li>
<li>l (右移)</li>
</ul>
</li>
<li><p>欲进入 Vim 编辑器(从命令行提示符)，请输入：vim 文件名 &lt;回车&gt;</p>
</li>
<li><p>欲退出 Vim 编辑器，请输入 \<ESC>   :q!   &lt;回车&gt; 放弃所有改动。<br>或者输入 \<ESC>   :wq   &lt;回车&gt; 保存改动。</p>
</li>
<li><p>在正常模式下删除光标所在位置的字符，请按： x</p>
</li>
<li><p>欲插入或添加文本，请输入：</p>
<ul>
<li>i   输入欲插入文本   \<ESC> 在光标前插入文本</li>
<li>A   输入欲添加文本   \<ESC>             在一行后添加文本</li>
</ul>
</li>
</ol>
<p>特别提示：按下 \<ESC> 键会带您回到正常模式或者撤消一个不想输入或部分完整<br>的命令。</p>
<h2 id="第二讲小结"><a href="#第二讲小结" class="headerlink" title="第二讲小结"></a>第二讲小结</h2><ol>
<li>欲从当前光标删除至下一个单词，请输入：dw</li>
<li>欲从当前光标删除至当前行末尾，请输入：d$</li>
<li>欲删除整行，请输入：dd</li>
<li>欲重复一个动作，请在它前面加上一个数字：2w</li>
<li><p>在正常模式下修改命令的格式是：<br> <code>operator   [number]   motion</code><br>  其中：</p>
<ul>
<li>operator - 操作符，代表要做的事情，比如 d 代表删除</li>
<li>[number] - 可以附加的数字，代表动作重复的次数</li>
<li>motion   - 动作，代表在所操作的文本上的移动，例如 w 代表单词(word)， $ 代表行末等等。</li>
</ul>
</li>
<li><p>欲移动光标到行首，请按数字0键：0</p>
</li>
<li>欲撤消以前的操作，请输入：u (小写的u)<br>  欲撤消在一行中所做的改动，请输入：U (大写的U)<br>  欲撤消以前的撤消命令，恢复以前的操作结果，请输入：CTRL-R</li>
</ol>
<h2 id="第三讲小结"><a href="#第三讲小结" class="headerlink" title="第三讲小结"></a>第三讲小结</h2><ol>
<li><p>要重新置入已经删除的文本内容，请按小写字母 p 键。该操作可以将已删除的文本内容置于光标之后。如果最后一次删除的是一个整行，那么该行将置于当前光标所在行的下一行。</p>
</li>
<li><p>要替换光标所在位置的字符，请输入小写的 r 和要替换掉原位置字符的新字符即可。</p>
</li>
<li><p>更改类命令允许您改变从当前光标所在位置直到动作指示的位置中间的文本。</p>
<p> 比如输入 ce 可以替换当前光标到单词的末尾的内容；输入 c$ 可以替换当前光标到行末的内容。</p>
</li>
<li><p>更改类命令的格式是：<code>c   [number]   motion</code></p>
</li>
</ol>
<h2 id="第四讲小结"><a href="#第四讲小结" class="headerlink" title="第四讲小结"></a>第四讲小结</h2><ol>
<li><p>CTRL-G 用于显示当前光标所在位置和文件状态信息。<br>  G 用于将光标跳转至文件最后一行。<br>  先敲入一个行号然后输入大写 G 则是将光标移动至该行号代表的行。<br>  gg 用于将光标跳转至文件第一行。</p>
</li>
<li><p>输入 / 然后紧随一个字符串是在当前所编辑的文档中正向查找该字符串。<br>  输入 ? 然后紧随一个字符串则是在当前所编辑的文档中反向查找该字符串。<br>  完成一次查找之后按 n 键是重复上一次的命令，可在同一方向上查<br>  找下一个匹配字符串所在；或者按大写 N 向相反方向查找下一匹配字符串所在。<br>  CTRL-O 带您跳转回较旧的位置，CTRL-I 则带您到较新的位置。</p>
</li>
<li><p>如果光标当前位置是括号(、)、[、]、{、}，按 % 会将光标移动到配对的括号上。</p>
</li>
<li><p>在一行内替换头一个字符串 old 为新的字符串 new，请输入  <code>:s/old/new</code><br> 在一行内替换所有的字符串 old 为新的字符串 new，请输入<code>:s/old/new/g</code><br> 在两行内替换所有的字符串 old 为新的字符串 new，请输入  <code>:#,#s/old/new/g</code><br> 在文件内替换所有的字符串 old 为新的字符串 new，请输入  <code>:%s/old/new/g</code><br> 进行全文替换时询问用户确认每个替换需添加 c 标志<code>:%s/old/new/gc</code></p>
</li>
</ol>
<h2 id="第五讲小结"><a href="#第五讲小结" class="headerlink" title="第五讲小结"></a>第五讲小结</h2><ol>
<li><p>:!command 用于执行一个外部命令 command。</p>
<p>  请看一些实际例子：<br> | (ms-dos)       | (unix)        |                                |<br> | ——————— | ——————- | ——————————————— |<br> | :!dir          | :!ls          | 用于显示当前目录的内容。       |<br> | :!del filename | :!rm filename | 用于删除名为 filename 的文件。 |</p>
</li>
<li><p><code>:w filename</code>  可将当前 vim 中正在编辑的文件保存到名为 filename 的文件中。</p>
</li>
<li><p><code>v motion :w filename</code> 可将当前编辑文件中可视模式下选中的内容保存到文件filename 中。</p>
</li>
<li><p><code>:r filename</code> 可提取磁盘文件 filename 并将其插入到当前文件的光标位置后面。</p>
</li>
<li><p><code>:r !dir</code> 可以读取 dir 命令的输出并将其放置到当前文件的光标位置后面。</p>
</li>
</ol>
<h2 id="第六讲小结"><a href="#第六讲小结" class="headerlink" title="第六讲小结"></a>第六讲小结</h2><ol>
<li><p>输入小写的 o 可以在光标下方打开新的一行并进入插入模式。输入大写的 o 可以在光标上方打开新的一行。</p>
</li>
<li><p>输入小写的 a 可以在光标所在位置之后插入文本。输入大写的 a 可以在光标所在行的行末之后插入文本。</p>
</li>
<li><p>e 命令可以使光标移动到单词末尾。</p>
</li>
<li><p>操作符 y 复制文本，p 粘贴先前复制的文本。</p>
</li>
<li><p>输入大写的 r 将进入替换模式，直至按 \<ESC> 键回到正常模式。</p>
</li>
<li><p>输入 :set xxx 可以设置 xxx 选项。一些有用的选项如下：<br> |                   |                        |<br> | ————————- | ——————————— |<br> | ‘ic’ ‘ignorecase’ | 查找时忽略字母大小写   |<br> | ‘is’ ‘incsearch’  | 查找短语时显示部分匹配 |<br> | ‘hls’ ‘hlsearch’  | 高亮显示所有的匹配短语 |</p>
<p> 选项名可以用完整版本，也可以用缩略版本。</p>
</li>
<li><p>在选项前加上 no 可以关闭选项：  <code>:set noic</code></p>
</li>
</ol>
<h2 id="第七讲小结"><a href="#第七讲小结" class="headerlink" title="第七讲小结"></a>第七讲小结</h2><ol>
<li><p>输入 <code>:help</code> 或者按 <code>&lt;f1&gt;</code> 键或 <code>&lt;help&gt;</code> 键可以打开帮助窗口。</p>
</li>
<li><p>输入入 <code>:help cmd</code> 可以找到关于 cmd 命令的帮助。</p>
</li>
<li><p>输入 <code>ctrl-w ctrl-w</code>  可以使您在窗口之间跳转。</p>
</li>
<li><p>输入 <code>:q</code> 以关闭帮助窗口</p>
</li>
<li><p>您可以创建一个 vimrc 启动脚本文件用来保存您偏好的设置。</p>
</li>
<li><p>当输入 <code>:</code> 命令时，按 <code>ctrl-d</code> 可以查看可能的补全结果。按 <code>&lt;tab&gt;</code> 可以使用一个补全。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>numpy &amp; panda 基础教程</title>
    <url>/2019/06/30/numpy-and-pandas/</url>
    <content><![CDATA[<h1 id="Numpy-和-Pandas"><a href="#Numpy-和-Pandas" class="headerlink" title="Numpy 和 Pandas"></a>Numpy 和 Pandas</h1><h2 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h2><h3 id="基本数学"><a href="#基本数学" class="headerlink" title="基本数学"></a>基本数学</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">array = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">                  [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line">print(array)</span><br><span class="line">print(<span class="string">'number of dim:'</span>,array.ndim)</span><br><span class="line">print(<span class="string">'shape:'</span>,array.shape)</span><br><span class="line">print(<span class="string">'size:'</span>,array.size)</span><br></pre></td></tr></table></figure>
<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],dtype=np.int)</span><br><span class="line">print(a.dtype)</span><br><span class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],dtype=np.int32)</span><br><span class="line">print(a.dtype)</span><br><span class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],dtype=np.int16)</span><br><span class="line">print(a.dtype)</span><br><span class="line">a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],dtype=np.float)</span><br><span class="line">print(a.dtype)</span><br><span class="line">a = np.zeros((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">print(a)</span><br><span class="line">a = np.ones((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">print(a)</span><br><span class="line">a = np.empty((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">print(a)</span><br><span class="line">a = np.arange(<span class="number">10</span>,<span class="number">20</span>,<span class="number">2</span>)</span><br><span class="line">print(a)</span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># 生成线段，1-10 分成20段</span></span><br><span class="line">a = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<h3 id="Numpy-运算"><a href="#Numpy-运算" class="headerlink" title="Numpy 运算"></a>Numpy 运算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">b= np.arange(<span class="number">4</span>)</span><br><span class="line">c = a-b</span><br><span class="line">print(a,b)</span><br><span class="line">print(c)</span><br><span class="line">print(b**<span class="number">2</span>)</span><br><span class="line">print(b&lt;<span class="number">3</span>)</span><br><span class="line">print(b==<span class="number">3</span>)</span><br><span class="line">print(a<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">             [<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">b = np.arange(<span class="number">4</span>).reshape((<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">c = a*b</span><br><span class="line">c_dot = np.dot(a,b) <span class="comment"># 矩阵乘法</span></span><br><span class="line">c_dot_2 = a.dot(b)</span><br><span class="line">print(c)</span><br><span class="line">print(c_dot)</span><br><span class="line">print(c_dot_2)</span><br><span class="line"></span><br><span class="line">a = np.random.random((<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">print(a)</span><br><span class="line">print(np.sum(a))</span><br><span class="line">print(np.min(a))</span><br><span class="line">print(np.max(a))</span><br><span class="line"></span><br><span class="line">print(np.sum(a,axis=<span class="number">1</span>)) <span class="comment"># 行里求和</span></span><br><span class="line">print(np.min(a,axis=<span class="number">0</span>)) <span class="comment"># 列里找最小值</span></span><br><span class="line">print(np.max(a,axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Numpy-的索引"><a href="#Numpy-的索引" class="headerlink" title="Numpy 的索引"></a>Numpy 的索引</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.arange(<span class="number">2</span>,<span class="number">14</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print(A)</span><br><span class="line">print(np.argmin(A)) <span class="comment"># 最小值索引</span></span><br><span class="line">print(np.argmax(A))</span><br><span class="line">print(np.mean(A)) <span class="comment"># 平均值</span></span><br><span class="line">print(A.mean())</span><br><span class="line">print(np.average(A))</span><br><span class="line">print(np.median(A)) <span class="comment"># 矩阵的中位数</span></span><br><span class="line">print(np.cumsum(A)) <span class="comment"># 累加</span></span><br><span class="line">print(np.diff(A)) <span class="comment"># 累差 相邻元素的差 3*4 = &gt; 3*3</span></span><br><span class="line">print(np.nonzero(A)) <span class="comment"># 非零，两个Array，第一个行数，第二个列数</span></span><br><span class="line">B = np.arange(<span class="number">14</span>,<span class="number">2</span>,<span class="number">-1</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print(np.sort(B))</span><br><span class="line">print(np.transpose(A)) <span class="comment"># 矩阵转置</span></span><br><span class="line">print((A.T).dot(A))</span><br><span class="line"></span><br><span class="line">print(np.clip(A,<span class="number">5</span>,<span class="number">9</span>)) <span class="comment"># 截取，小于5变成5，大于9变成9</span></span><br><span class="line"><span class="comment"># 以上都可以指定axis计算</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.arange(<span class="number">3</span>,<span class="number">15</span>)</span><br><span class="line">print(A)</span><br><span class="line">print(A[<span class="number">3</span>])</span><br><span class="line">A = np.reshape(A,(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print(A)</span><br><span class="line">print(A[<span class="number">2</span>])</span><br><span class="line">print(A[<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">print(A[<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">print(A[<span class="number">2</span>,:])</span><br><span class="line">print(A[<span class="number">2</span>,<span class="number">1</span>:<span class="number">2</span>])</span><br><span class="line">print(A[<span class="number">2</span>,<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line">print(A[:,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">print(A)</span><br><span class="line">print(<span class="string">'*'</span>*<span class="number">3</span>,<span class="string">'行迭代：'</span>)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> A:</span><br><span class="line">    print(row)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'*'</span>*<span class="number">3</span>,<span class="string">'列迭代：'</span>)</span><br><span class="line">print(A.T)</span><br><span class="line"><span class="keyword">for</span> column <span class="keyword">in</span> A.T:</span><br><span class="line">    print(column)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'*'</span>*<span class="number">3</span>,<span class="string">'元素迭代：'</span>)</span><br><span class="line">print(A.flatten())</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> A.flat: <span class="comment"># A编程一行 A.flat 是迭代器</span></span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>
<h3 id="Numpy的array-合并"><a href="#Numpy的array-合并" class="headerlink" title="Numpy的array 合并"></a>Numpy的array 合并</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">B = np.array([<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])</span><br><span class="line">C = np.vstack((A,B))<span class="comment"># vertical stack 垂直合并</span></span><br><span class="line">D = np.hstack((A,B)) <span class="comment"># horizontal stack 水平合并</span></span><br><span class="line">print(C)</span><br><span class="line">print(A.shape,C.shape)</span><br><span class="line"></span><br><span class="line">print(D)</span><br><span class="line">print(A.shape,D.shape)</span><br><span class="line"></span><br><span class="line">print(A[np.newaxis,:]) <span class="comment"># 在行上面加维度</span></span><br><span class="line">print(A[np.newaxis,:].shape) <span class="comment"># 在行上面加维度</span></span><br><span class="line"></span><br><span class="line">print(A[:,np.newaxis]) <span class="comment"># 在行上面加维度</span></span><br><span class="line">print(A[:,np.newaxis].shape) <span class="comment"># 在列上面加维度</span></span><br><span class="line"></span><br><span class="line">A = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])[:,np.newaxis]</span><br><span class="line">B = np.array([<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])[:,np.newaxis]</span><br><span class="line">E = np.concatenate((A,B,B,A),axis=<span class="number">0</span>) <span class="comment"># 纵向合并</span></span><br><span class="line">F = np.concatenate((A,B,B,A),axis=<span class="number">1</span>) <span class="comment"># 横向合并</span></span><br><span class="line">print(E)</span><br><span class="line">print(F)</span><br></pre></td></tr></table></figure>
<h3 id="Numpy-的-array-分割"><a href="#Numpy-的-array-分割" class="headerlink" title="Numpy 的 array 分割"></a>Numpy 的 array 分割</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">A = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">print(A)</span><br><span class="line"></span><br><span class="line"><span class="comment"># split 只能均分</span></span><br><span class="line"></span><br><span class="line">print(np.split(A,<span class="number">3</span>,axis=<span class="number">0</span>)) <span class="comment"># 纵向分割</span></span><br><span class="line"></span><br><span class="line">print(np.split(A,<span class="number">2</span>,axis=<span class="number">1</span>)) <span class="comment"># 横向分割</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># array_split 可以不均分</span></span><br><span class="line"></span><br><span class="line">print(np.array_split(A,<span class="number">2</span>,axis=<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">print(np.vsplit(A,<span class="number">3</span>)) <span class="comment"># vertical split</span></span><br><span class="line"></span><br><span class="line">print(np.hsplit(A,<span class="number">1</span>)) <span class="comment"># horizontal split</span></span><br></pre></td></tr></table></figure>
<h3 id="Numpy-的-copy-amp-deep-copy"><a href="#Numpy-的-copy-amp-deep-copy" class="headerlink" title="Numpy 的 copy &amp; deep copy"></a>Numpy 的 copy &amp; deep copy</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">4</span>)</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">b = a</span><br><span class="line">c = a</span><br><span class="line">d = b</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">11</span></span><br><span class="line">print(a,b,c,d)</span><br><span class="line"></span><br><span class="line">print(b <span class="keyword">is</span> a)</span><br><span class="line">print(d <span class="keyword">is</span> a)</span><br><span class="line"></span><br><span class="line">b = a.copy() <span class="comment"># deep copy 将a的值赋给b，两者之间没有关联。</span></span><br><span class="line"></span><br><span class="line">a[<span class="number">1</span>:<span class="number">3</span>] = [<span class="number">22</span>,<span class="number">33</span>]</span><br><span class="line">b[<span class="number">3</span>] = <span class="number">44</span></span><br><span class="line">print(a,b)</span><br></pre></td></tr></table></figure>
<h2 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,np.nan,<span class="number">44</span>]) <span class="comment"># pandas 序列</span></span><br><span class="line">print(s)</span><br><span class="line"></span><br><span class="line">dates = pd.date_range(start=<span class="string">'20190629'</span>,periods=<span class="number">6</span>) <span class="comment"># 日期 index</span></span><br><span class="line">print(dates)</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">4</span>),index=dates,columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</span><br><span class="line">print(df)</span><br><span class="line"></span><br><span class="line">df1 = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line">print(df1)</span><br><span class="line"></span><br><span class="line">df2 = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">'A'</span>:<span class="number">1.0</span>,</span><br><span class="line">    <span class="string">'B'</span>:pd.Timestamp(<span class="string">'20181215'</span>),</span><br><span class="line">    <span class="string">'C'</span>:pd.Series(<span class="number">1</span>,index=list(range(<span class="number">4</span>)),dtype=<span class="string">'float64'</span>),</span><br><span class="line">    <span class="string">'D'</span>:np.array([<span class="number">3</span>]*<span class="number">4</span>,dtype=<span class="string">'int32'</span>),</span><br><span class="line">    <span class="string">'E'</span>:pd.Categorical([<span class="string">'test'</span>,<span class="string">'train'</span>,<span class="string">'test'</span>,<span class="string">'train'</span>]),</span><br><span class="line">    <span class="string">'F'</span>:<span class="string">'foo'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">print(df2)</span><br><span class="line">print(<span class="string">f'dtype:\n<span class="subst">&#123;df2.dtypes&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'index:\n<span class="subst">&#123;df2.index&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'columns:\n<span class="subst">&#123;df2.columns&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'values:\n<span class="subst">&#123;df2.values&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'Desc:\n<span class="subst">&#123;df2.describe()&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">f'T:\n<span class="subst">&#123;df2.T&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">print(df2.sort_index(axis=<span class="number">0</span>,ascending=<span class="literal">False</span>))</span><br><span class="line">print(df2.sort_index(axis=<span class="number">1</span>,ascending=<span class="literal">False</span>))</span><br><span class="line">print(df2.sort_values(by=<span class="string">'E'</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Pandas-选择数据"><a href="#Pandas-选择数据" class="headerlink" title="Pandas 选择数据"></a>Pandas 选择数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">dates = pd.date_range(start=<span class="string">'20190629'</span>,periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">24</span>).reshape((<span class="number">6</span>,<span class="number">4</span>)),index=dates,columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</span><br><span class="line"></span><br><span class="line">print(df,end=<span class="string">'\n\n'</span>)</span><br><span class="line"></span><br><span class="line">print(df[<span class="string">'A'</span>],df.A,end=<span class="string">'\n\n'</span>,sep=<span class="string">'\n\n'</span>) <span class="comment"># 列</span></span><br><span class="line">print(df[<span class="number">0</span>:<span class="number">3</span>],df[<span class="string">'20190629'</span>:<span class="string">'20190701'</span>],end=<span class="string">'\n\n'</span>,sep=<span class="string">'\n\n'</span>) <span class="comment"># 行</span></span><br><span class="line">print(df[<span class="number">0</span>:<span class="number">3</span>][<span class="string">'A'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># select by label: loc</span></span><br><span class="line">print(df.loc[<span class="string">'20190629'</span>],</span><br><span class="line">      df.loc[<span class="string">'20190629'</span>,[<span class="string">'A'</span>,<span class="string">'B'</span>]],sep=<span class="string">'\n\n'</span>,end=<span class="string">'\n\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># select by position: iloc</span></span><br><span class="line">print(df.iloc[<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">      df.iloc[:,<span class="number">1</span>:<span class="number">3</span>],</span><br><span class="line">      df.iloc[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],<span class="number">1</span>:<span class="number">4</span>],sep=<span class="string">'\n\n'</span>,end=<span class="string">'\n\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># mixed selection: ix :: this way is deprecated.</span></span><br><span class="line"><span class="comment"># print(df.ix[:3,['A','B']])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Boolean indexing</span></span><br><span class="line">print(df[df.A &gt; <span class="number">6</span>])</span><br></pre></td></tr></table></figure>
<h3 id="Pandas-设置值"><a href="#Pandas-设置值" class="headerlink" title="Pandas 设置值"></a>Pandas 设置值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">dates = pd.date_range(start=<span class="string">'20190629'</span>,periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">24</span>).reshape((<span class="number">6</span>,<span class="number">4</span>)),index=dates,columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</span><br><span class="line"></span><br><span class="line">df.iloc[<span class="number">1</span>,<span class="number">2</span>] = <span class="number">2222</span></span><br><span class="line">df.loc[<span class="string">'20190701'</span>,<span class="string">'C'</span>] = <span class="number">3333</span></span><br><span class="line">df.B[df.A &gt; <span class="number">8</span>] = <span class="number">0</span></span><br><span class="line">print(df)</span><br><span class="line"></span><br><span class="line">df[<span class="string">'E'</span>] = np.nan</span><br><span class="line">df[<span class="string">'F'</span>] = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],index=pd.date_range(start=<span class="string">'20190629'</span>,periods=<span class="number">6</span>))</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure>
<h3 id="Pandas-处理丢失数据"><a href="#Pandas-处理丢失数据" class="headerlink" title="Pandas 处理丢失数据"></a>Pandas 处理丢失数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">dates = pd.date_range(start=<span class="string">'20190629'</span>,periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">24</span>).reshape((<span class="number">6</span>,<span class="number">4</span>)),index=dates,columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</span><br><span class="line"></span><br><span class="line">df.iloc[<span class="number">0</span>,<span class="number">1</span>] = np.nan</span><br><span class="line">df.iloc[<span class="number">1</span>,<span class="number">2</span>] = <span class="literal">None</span></span><br><span class="line">print(df)</span><br><span class="line"></span><br><span class="line">print(df.dropna(axis=<span class="number">0</span>,how=<span class="string">'any'</span>)) <span class="comment"># how = &#123;'any','all'&#125; 删除丢失数据</span></span><br><span class="line">print(df.dropna(axis=<span class="number">1</span>,how=<span class="string">'any'</span>)) <span class="comment"># how = &#123;'any','all'&#125;</span></span><br><span class="line"></span><br><span class="line">print(df.fillna(value=<span class="number">0</span>)) <span class="comment"># 使用value填充丢失数据</span></span><br><span class="line"></span><br><span class="line">print(df.isnull()) <span class="comment"># 判断是否丢失数据</span></span><br><span class="line"></span><br><span class="line">print(np.any(df.isnull()) == <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Pandas-导入-amp-导出-数据"><a href="#Pandas-导入-amp-导出-数据" class="headerlink" title="Pandas 导入 &amp; 导出 数据"></a>Pandas 导入 &amp; 导出 数据</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Format Type</th>
<th>Data Description</th>
<th>Reader</th>
<th>Writer</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">text</td>
<td>CSV</td>
<td>read_csv</td>
<td>to_csv</td>
</tr>
<tr>
<td style="text-align:left">text</td>
<td>JSON</td>
<td>read_json</td>
<td>to_json</td>
</tr>
<tr>
<td style="text-align:left">text</td>
<td>HTML</td>
<td>read_html</td>
<td>to_html</td>
</tr>
<tr>
<td style="text-align:left">text</td>
<td>Local clipboard</td>
<td>read_clipboard</td>
<td>to_clipboard</td>
</tr>
<tr>
<td style="text-align:left">binary</td>
<td>MS Excel</td>
<td>read_excel</td>
<td>to_excel</td>
</tr>
<tr>
<td style="text-align:left">binary</td>
<td>HDF5 Format</td>
<td>read_hdf</td>
<td>to_hdf</td>
</tr>
<tr>
<td style="text-align:left">binary</td>
<td>Feather Format</td>
<td>read_feather</td>
<td>to_feather</td>
</tr>
<tr>
<td style="text-align:left">binary</td>
<td>Parquet Format</td>
<td>read_parquet</td>
<td>to_parquet</td>
</tr>
<tr>
<td style="text-align:left">binary</td>
<td>Msgpack</td>
<td>read_msgpack</td>
<td>to_msgpack</td>
</tr>
<tr>
<td style="text-align:left">binary</td>
<td>Stata</td>
<td>read_stata</td>
<td>to_stata</td>
</tr>
<tr>
<td style="text-align:left">binary</td>
<td>SAS</td>
<td>read_sas</td>
<td></td>
</tr>
<tr>
<td style="text-align:left">binary</td>
<td>Python Pickle Format</td>
<td>read_pickle</td>
<td>to_pickle</td>
</tr>
<tr>
<td style="text-align:left">SQL</td>
<td>SQL</td>
<td>read_sql</td>
<td>to_sql</td>
</tr>
<tr>
<td style="text-align:left">SQL</td>
<td>Google Big Query</td>
<td>read_gbq</td>
<td>to_gbq</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">'Student.csv'</span>)</span><br><span class="line">print(df)</span><br><span class="line"></span><br><span class="line">df.to_pickle(<span class="string">'student.pickle'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Pandas-合并-concat"><a href="#Pandas-合并-concat" class="headerlink" title="Pandas 合并  concat"></a>Pandas 合并  concat</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># concatenating</span></span><br><span class="line"></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df3 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">2</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line"></span><br><span class="line">res = pd.concat([df1,df2,df3],axis=<span class="number">0</span>)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line">res = pd.concat([df1,df2,df3],axis=<span class="number">0</span>,ignore_index=<span class="literal">True</span>)<span class="comment"># ignore_index 重新对index排序</span></span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line">res = pd.concat([df1,df2,df3],axis=<span class="number">1</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># join = ['inner','outer']  default:outer</span></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>],index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>,columns=[<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>],index=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># res = pd.concat([df1,df2],axis=0)</span></span><br><span class="line">res = pd.concat([df1,df2],axis=<span class="number">0</span>,join=<span class="string">'inner'</span>,ignore_index=<span class="literal">True</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># join axes</span></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>],index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>,columns=[<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>],index=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># res = pd.concat([df1,df2],axis=1,join_axes=[df1.index]) # 横向合并时，指定合并的index，</span></span><br><span class="line">res = pd.concat([df1,df2],axis=<span class="number">0</span>,join_axes=[df1.columns])</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># append</span></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df3 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>,columns=[<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>],index=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># res = df1.append(df2,ignore_index=True)</span></span><br><span class="line"><span class="comment"># res = df1.append([df2,df3])</span></span><br><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">res = df1.append(s,ignore_index=<span class="literal">True</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<h3 id="Pandas-合并-merge"><a href="#Pandas-合并-merge" class="headerlink" title="Pandas 合并  merge"></a>Pandas 合并  merge</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">merge two df by key/keys (may be used in database)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">left = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">'key'</span>:[<span class="string">'K0'</span>,<span class="string">'K1'</span>,<span class="string">'K2'</span>,<span class="string">'K3'</span>],</span><br><span class="line">    <span class="string">'A'</span>:[<span class="string">'A0'</span>,<span class="string">'A1'</span>,<span class="string">'A2'</span>,<span class="string">'A3'</span>],</span><br><span class="line">    <span class="string">'B'</span>:[<span class="string">'B0'</span>,<span class="string">'B1'</span>,<span class="string">'B2'</span>,<span class="string">'B3'</span>],</span><br><span class="line">&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">'key'</span>:[<span class="string">'K0'</span>,<span class="string">'K1'</span>,<span class="string">'K2'</span>,<span class="string">'K3'</span>],</span><br><span class="line">    <span class="string">'C'</span>:[<span class="string">'C0'</span>,<span class="string">'C1'</span>,<span class="string">'C2'</span>,<span class="string">'C3'</span>],</span><br><span class="line">    <span class="string">'D'</span>:[<span class="string">'D0'</span>,<span class="string">'D1'</span>,<span class="string">'D2'</span>,<span class="string">'D3'</span>],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">print(left)</span><br><span class="line">print(right)</span><br><span class="line"></span><br><span class="line">res = pd.merge(left,right,on=<span class="string">'key'</span>) <span class="comment"># merge by the column named 'key'</span></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">consider two keys</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">left = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">'key1'</span>:[<span class="string">'K0'</span>,<span class="string">'K1'</span>,<span class="string">'K1'</span>,<span class="string">'K3'</span>],</span><br><span class="line">    <span class="string">'key2'</span>:[<span class="string">'K0'</span>,<span class="string">'K0'</span>,<span class="string">'K0'</span>,<span class="string">'K2'</span>],</span><br><span class="line">    <span class="string">'A'</span>:[<span class="string">'A0'</span>,<span class="string">'A1'</span>,<span class="string">'A2'</span>,<span class="string">'A3'</span>],</span><br><span class="line">    <span class="string">'B'</span>:[<span class="string">'B0'</span>,<span class="string">'B1'</span>,<span class="string">'B2'</span>,<span class="string">'B3'</span>],</span><br><span class="line">&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">'key1'</span>:[<span class="string">'K0'</span>,<span class="string">'K1'</span>,<span class="string">'K2'</span>,<span class="string">'K3'</span>],</span><br><span class="line">    <span class="string">'key2'</span>:[<span class="string">'K0'</span>,<span class="string">'K0'</span>,<span class="string">'K2'</span>,<span class="string">'K3'</span>],</span><br><span class="line">    <span class="string">'C'</span>:[<span class="string">'C0'</span>,<span class="string">'C1'</span>,<span class="string">'C2'</span>,<span class="string">'C3'</span>],</span><br><span class="line">    <span class="string">'D'</span>:[<span class="string">'D0'</span>,<span class="string">'D1'</span>,<span class="string">'D2'</span>,<span class="string">'D3'</span>],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">print(left)</span><br><span class="line">print(right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># res = pd.merge(left,right,on=['key1','key2'])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># how = ['left', 'right', 'outer', 'inner'] default:inner 合并方式</span></span><br><span class="line">res = pd.merge(left,right,on=[<span class="string">'key1'</span>,<span class="string">'key2'</span>],how=<span class="string">'left'</span>)</span><br><span class="line"></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># indicator</span></span><br><span class="line"></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'col1'</span>:[<span class="number">0</span>,<span class="number">1</span>],<span class="string">'col_left'</span>:[<span class="string">'a'</span>,<span class="string">'b'</span>]&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'col1'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],<span class="string">'col_right'</span>:[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]&#125;)</span><br><span class="line"></span><br><span class="line">print(df1)</span><br><span class="line">print(df2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># res = pd.merge(df1,df2,on='col1',how='outer',indicator=True)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># give the indicator a custome name</span></span><br><span class="line">res = pd.merge(df1,df2,on=<span class="string">'col1'</span>,how=<span class="string">'outer'</span>,indicator=<span class="string">'indicator_name'</span>)</span><br><span class="line"></span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># merge by index</span></span><br><span class="line"></span><br><span class="line">left = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">'A'</span>:[<span class="string">'A0'</span>,<span class="string">'A1'</span>,<span class="string">'A2'</span>,<span class="string">'A3'</span>],</span><br><span class="line">    <span class="string">'B'</span>:[<span class="string">'B0'</span>,<span class="string">'B1'</span>,<span class="string">'B2'</span>,<span class="string">'B3'</span>],</span><br><span class="line">&#125;,index=[<span class="string">'K0'</span>,<span class="string">'K1'</span>,<span class="string">'K2'</span>,<span class="string">'K3'</span>])</span><br><span class="line"></span><br><span class="line">right = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">'C'</span>:[<span class="string">'C0'</span>,<span class="string">'C1'</span>,<span class="string">'C2'</span>,<span class="string">'C3'</span>],</span><br><span class="line">    <span class="string">'D'</span>:[<span class="string">'D0'</span>,<span class="string">'D1'</span>,<span class="string">'D2'</span>,<span class="string">'D3'</span>],</span><br><span class="line">&#125;,index=[<span class="string">'K0'</span>,<span class="string">'K2'</span>,<span class="string">'K3'</span>,<span class="string">'K4'</span>])</span><br><span class="line"></span><br><span class="line">print(left)</span><br><span class="line">print(right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># res = pd.merge(left,right,left_index=True,right_index=True,how='outer')</span></span><br><span class="line">res = pd.merge(left,right,left_index=<span class="literal">True</span>,right_index=<span class="literal">True</span>,how=<span class="string">'inner'</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># handle overlapping</span></span><br><span class="line"></span><br><span class="line">boys = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">'k'</span>:[<span class="string">'K0'</span>,<span class="string">'K1'</span>,<span class="string">'K2'</span>],</span><br><span class="line">    <span class="string">'age'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">girls = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">'k'</span>:[<span class="string">'K0'</span>,<span class="string">'K0'</span>,<span class="string">'K1'</span>],</span><br><span class="line">    <span class="string">'age'</span>:[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">res = pd.merge(boys,girls,on=<span class="string">'k'</span>,suffixes=[<span class="string">'_boy'</span>,<span class="string">'_girl'</span>],how=<span class="string">'inner'</span>)</span><br><span class="line">print(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># join</span></span><br></pre></td></tr></table></figure>
<h3 id="Pandas-plot-图表"><a href="#Pandas-plot-图表" class="headerlink" title="Pandas plot 图表"></a>Pandas plot 图表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># Series</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># data = pd.Series(np.random.randn(1000),index=np.arange(1000))</span></span><br><span class="line"></span><br><span class="line">data = pd.DataFrame(np.random.randn(<span class="number">1000</span>,<span class="number">4</span>),index=np.arange(<span class="number">1000</span>),columns=list(<span class="string">'ABCD'</span>))</span><br><span class="line">data = data.cumsum() <span class="comment"># 类是reduce，累加</span></span><br><span class="line">data.plot()</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot method:</span></span><br><span class="line"><span class="comment"># 'bar','hist','plot','scatter','kde','area','box','hexbin','pie'</span></span><br><span class="line"></span><br><span class="line">ax = data.plot.scatter(x=<span class="string">'A'</span>,y=<span class="string">'B'</span>,color=<span class="string">'DarkBlue'</span>,label=<span class="string">'Class 1'</span>)</span><br><span class="line">data.plot.scatter(x=<span class="string">'A'</span>,y=<span class="string">'C'</span>,color=<span class="string">'DarkGreen'</span>,label=<span class="string">'Class 2'</span>,ax=ax)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/my/images/numpy_and_pandas/output_40_0.png" alt="png"></p>
<p><img src="/my/images/numpy_and_pandas/output_40_1.png" alt="png"></p>
]]></content>
      <categories>
        <category>框架</category>
      </categories>
  </entry>
  <entry>
    <title>vue使用</title>
    <url>/2020/03/18/vue%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Vue-js使用"><a href="#Vue-js使用" class="headerlink" title="Vue.js使用"></a>Vue.js使用</h1><script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

<h2 id="Vue-Instance"><a href="#Vue-Instance" class="headerlink" title="Vue Instance"></a>Vue Instance</h2><p>Vue应用都是通过创建一个新的Vue 实例开始的:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">//选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Vue应用是通过<code>new Vue</code>创建<strong>根Vue实例</strong>，以及可选的、嵌套的、可复用的组建树组成。</p>
<a id="more"></a>
<h3 id="数据和方法"><a href="#数据和方法" class="headerlink" title="数据和方法"></a>数据和方法</h3><p>Vue Instance被创建的时候它将<code>data</code>对象中的所有的属性加入到Vue的<strong>响应式系统</strong>中。当这些属性的值发生改变，视图匹配更新为新的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们的数据对象</span></span><br><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该对象被加入到一个 Vue 实例中</span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得这个实例上的属性</span></span><br><span class="line"><span class="comment">// 返回源数据中对应的字段</span></span><br><span class="line">vm.a == data.a <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置属性也会影响到原始数据</span></span><br><span class="line">vm.a = <span class="number">2</span></span><br><span class="line">data.a <span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……反之亦然</span></span><br><span class="line">data.a = <span class="number">3</span></span><br><span class="line">vm.a <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>
<p>注意：只有当Instance被创建的时就以及存在与<code>data</code>中的属性才是<strong>响应式</strong>的。</p>
<p>其次，当使用<code>Object.freeze()</code>，这也会阻止修改现有的属性，也意味着响应式系统无法trace变化。</p>
<h3 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h3><p>因为生命周期钩子的函数的存在，用户可以在不同的阶段添加自己的代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a is: '</span> + <span class="keyword">this</span>.a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// =&gt; "a is: 1"</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/vue/lifecycle.png" alt="lifecycle"></p>
<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><blockquote>
<p>vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。</p>
<p>在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。</p>
<p>如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，<a href="https://cn.vuejs.org/v2/guide/render-function.html" target="_blank" rel="noopener">直接写渲染 (render) 函数</a>，使用可选的 JSX 语法。</p>
</blockquote>
<h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><ol>
<li><p>文本</p>
<p>最常见的形式是使用”Mustache”语法（双大括号）的文本插值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span> Message: &#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Mustache标签将会被替换为对应数据对象上<code>msg</code>属性的值。当数据对象<code>msg</code>属性发生改变，插值处的内容也会改变。</p>
<p>通过使用<code>v-once</code>指令，可以执行一次插值，当数据改变，插值处内容不会更新。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>这个将不会改变: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>原始的HTML</p>
<p>Mustache标签将数据解释乘plain text，而不是HTML代码。</p>
<p>为了输出真正的HTML，需要使用<code>v-html</code>指令。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Using mustache: &#123;&#123;rawHtml&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">"rawHtml"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>span</code>的内容将会被替换乘属性值<code>rawHTML</code>，直接作为HTML——会忽略属性值中的数据绑定，因此不是不能使用<code>v-html</code>来复合局部模板。对于界面，组件作为可重用和可组合的基本单位。</p>
</li>
<li><p>Attribute</p>
<p>Mustache语法无法作用在HTML attribute上，这种情况下应使用<code>v-bind</code>指令：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"dynameicId"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于Bool attribute（只要binding的对象存在就意味这<code>true</code>）<code>v-bind</code>工作略有不同，</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-bind:disabled</span>=<span class="string">"isButtonDisabled"</span>&gt;</span></span><br><span class="line">    Button</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果<code>isButtonDisabled</code>的值为<code>null</code>，<code>undefined</code>或<code>false</code>，则<code>disabled</code> attribute 不会包含在渲染出来的节点元素中。</p>
</li>
<li><p>使用JS表达式</p>
<p>Vue.js提供了完全的JavaScript表达式的支持：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">"'list-' + id"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这些表达式会在所属的Vue Instance的数据作用域下作为JavaScript被解析。唯一的限制就是，每个绑定只能包含<strong>单个表达式</strong>，下面的情况都无法使用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这是语句，不是表达式 --&gt;</span></span><br><span class="line">&#123;&#123; var a = 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span></span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>模板表达式是在沙盒中，只能访问到全局变量的一个白名单，比如<code>Math</code>和<code>Date</code>。不应该在模板表达式中来访问用户定义的全局变量。</p>
</li>
</ol>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><blockquote>
<p>指令 (Directives) 是带有 <code>v-</code> 前缀的特殊 attribute。指令 attribute 的值预期是<strong>单个 JavaScript 表达式</strong> (<code>v-for</code> 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"seen"</span>&gt;</span></span><br><span class="line">    现在你看到我了</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里<code>v-if</code>指令将根据表达式<code>seen</code>的值的真假来插入/移除<code>&lt;p&gt;</code>元素。</p>
<ol>
<li><p>参数</p>
<p>部分指令可以接受一个Parameter，在指令名称后面用冒号表示。比如<code>v-bind</code>指令用于响应式的更新HTML Attribute：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里的<code>href</code>就是一个Parameter，<code>v-bind</code>指令将该元素的<code>href</code> attribute和表达式<code>url</code>的值绑定。</p>
<p>另一个例子是<code>v-on</code>指令，该指令被用于监听DOM事件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>动态参数</p>
<blockquote>
<p>2.6.0 增加，可用用方括号扩起来的JavaScript表达式作为一个指令的参数。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">attributeName</span>]=<span class="string">"url"</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中的<code>attributeName</code>被作为一个JavaScript表达式进行动态求值，求得的值作为最终的Parameter来使用。</p>
<p>如果<code>attributeName</code>为<code>href</code>，那么就等价与<code>v-bind:href</code>。</p>
<p>同样，也可以使用动态参数为一个动态事件绑定处理函数。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:</span>[<span class="attr">eventName</span>]=<span class="string">"doSomething"</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当<code>eventName</code>的值为<code>focus</code>时，等价于<code>v-on：focus</code></p>
<ul>
<li><p>对动态参数的值的约束</p>
<p>动态参数预期求出一个字符串，出现异常值为<code>null</code>。这个特殊的<code>null</code>值表示移除绑定。任何其他非字符串类型的值都会触发一个alert。</p>
</li>
<li><p>对动态参数表达式的约束</p>
<p>动态参数表达式有一些约束，因为某些字符比如空格和引号，对于HTML attribute是无效的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这会触发一个编译警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>['<span class="attr">foo</span>' + <span class="attr">bar</span>]=<span class="string">"value"</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>变通的方法是使用没有空格或引号的表达式，或者使用计算属性来替换这种复杂的表达式。</p>
<p>避免使用大写字母来命名键名，因为Brower会将attribute名全部强制转为小写。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。</span></span><br><span class="line"><span class="comment">除非在实例中有一个名为“someattr”的 property，否则代码不会工作。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">someAttr</span>]=<span class="string">"value"</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>修饰符</p>
<blockquote>
<p>修饰符 (modifier) 是以半角句号 <code>.</code> 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。</p>
</blockquote>
<p>比如<code>.prevent</code>修饰符告诉<code>v-on</code>指令对于触发的事件调用<code>event.preventDefault()</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><blockquote>
<p><code>v-</code> 前缀作为一种视觉提示，用来识别模板中 Vue 特定的 attribute。当你在使用 Vue.js 为现有标签添加动态行为 (dynamic behavior) 时，<code>v-</code> 前缀很有帮助，然而，对于一些频繁用到的指令来说，就会感到使用繁琐。同时，在构建由 Vue 管理所有模板的<a href="https://en.wikipedia.org/wiki/Single-page_application" target="_blank" rel="noopener">单页面应用程序 (SPA - single page application)</a> 时，<code>v-</code> 前缀也变得没那么重要了。因此，Vue 为 <code>v-bind</code> 和 <code>v-on</code> 这两个最常用的指令，提供了特定简写：</p>
</blockquote>
<ol>
<li><p><code>v-bind</code>缩写</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:</span>[<span class="attr">key</span>]=<span class="string">"url"</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>v-on</code>缩写</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">event</span>]=<span class="string">"doSomething"</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h2><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>模板中使用表达式非常方便，但是只能用于简单计算。如果在模板放入太多逻辑会导致模板过重且难以维护。</p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  &#123;&#123; message.split('').reverse().join('') &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因此，对于任何的复杂逻辑，应该使用<strong>计算属性</strong></p>
<ol>
<li><p>基础例子</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Original message: "&#123;&#123; message &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Computed reversed message: "&#123;&#123; reversedMessage &#125;&#125;"<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'Hello'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 计算属性的 getter</span></span><br><span class="line">    reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Original message: “Hello”</p>
<p>Computed reversed message: “olleH”</p>
</li>
</ol>
<p>   这里声明了一个计算属性<code>reverseMessage</code>。我们提供的函数作为属性<code>vm.reverseMessage</code>的getter函数。</p>
   <figure class="highlight"><table><tr><td class="code"><pre><span class="line">console.log(vm.reversedMessage) // =&gt; 'olleH'</span><br><span class="line">vm.message = 'Goodbye'</span><br><span class="line">console.log(vm.reversedMessage) // =&gt; 'eybdooG'</span><br></pre></td></tr></table></figure>
<ol>
<li><p>计算属性缓存 versus 方法</p>
<p>同样，我们也可以在表达式中调用方法达到和计算属性同样的效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Reversed message: "&#123;&#123; reversedMessage() &#125;&#125;"</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在组件中</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  reversedMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.message.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实完全相同。但是<strong>计算属性是基于它们的响应式以来进行缓存的</strong>。只要相关的响应式依赖发生改变时它们才会重新求值。</p>
<p>这就意味着只要<code>message</code>没有发生改变，多次访问<code>reverseMessage</code>计算属性就会返回之前的计算结果，而不需要再次执行函数。</p>
<p>这就意味着下面的计算属性不再更新，因为<code>Date.now()</code>不是响应式依赖。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  now: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Date</span>.now()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比较，每次触发渲染时，调用方法<strong>总会</strong>再次执行函数。</p>
</li>
</ol>
<p>   缓存的目的：</p>
<p>   假设有一个性能开销比较大的计算属性A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于A。如果没有缓存，我们将不可避免的多次执行A的getter。如果不需要缓存，请用方法替代。</p>
<ol>
<li><p>计算属性 versus 侦听属性</p>
<p>Vue提供了一种更通用的方式来观察和响应Vue 实例上的数据变动：<strong>侦听属性</strong>。</p>
<p>当一些数据需要随着其他数据变动而变动时，很容易滥用<code>watch</code>。然而，通常更好的做法是使用计算属性而不是<code>watch</code>回调。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span>&#123;&#123; fullName &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Foo'</span>,</span><br><span class="line">    lastName: <span class="string">'Bar'</span>,</span><br><span class="line">    fullName: <span class="string">'Foo Bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    firstName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fullName = val + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    lastName: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.fullName = <span class="keyword">this</span>.firstName + <span class="string">' '</span> + val</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面的代码过于重复。下面是计算属性的version：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">'Foo'</span>,</span><br><span class="line">    lastName: <span class="string">'Bar'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    fullName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算属性的setter</p>
<p>计算属性默认只有getter，不过有时候也需要一个setter：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>这个时候运行<code>vm.fullName = &#39;John Doe&#39;</code>，setter会被调用，<code>vm.firstName</code>和<code>vm.lastName</code>也会相应的被更新。</p>
</li>
</ol>
<h3 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h3><p>计算属性在大多数情况下是更合适的，但有时也需要一个自定义的侦听器。</p>
<p>这就是为什么Vue通过<code>watch</code>选项提供了一个更加通用的方法，来响应数据的变化。当需要在<strong>数据变化执行异步或开销较大</strong>的操作时，这个方式是最有用的。</p>
<p>例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"watch-example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Ask a yes/no question:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"question"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; answer &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> watchExampleVM = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">  el: <span class="string">'#watch-example'</span>,</span></span><br><span class="line">  data: &#123;</span><br><span class="line"><span class="actionscript">    question: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">    answer: <span class="string">'I cannot give you an answer until you ask a question!'</span></span></span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line"><span class="actionscript">    <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span></span><br><span class="line"><span class="actionscript">    question: <span class="function"><span class="keyword">function</span> <span class="params">(newQuestion, oldQuestion)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.answer = <span class="string">'Waiting for you to stop typing...'</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.debouncedGetAnswer()</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="actionscript">  created: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 请参考：https://lodash.com/docs#debounce</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">this</span>.debouncedGetAnswer = _.debounce(<span class="keyword">this</span>.getAnswer, <span class="number">500</span>)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="actionscript">    getAnswer: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">if</span> (<span class="keyword">this</span>.question.indexOf(<span class="string">'?'</span>) === <span class="number">-1</span>) &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.answer = <span class="string">'Questions usually contain a question mark. ;-)'</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span></span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.answer = <span class="string">'Thinking...'</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> vm = <span class="keyword">this</span></span></span><br><span class="line"><span class="actionscript">      axios.get(<span class="string">'https://yesno.wtf/api'</span>)</span></span><br><span class="line"><span class="actionscript">        .then(<span class="function"><span class="keyword">function</span> <span class="params">(response)</span> </span>&#123;</span></span><br><span class="line">          vm.answer = _.capitalize(response.data.answer)</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="actionscript">        .catch(<span class="function"><span class="keyword">function</span> <span class="params">(error)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          vm.answer = <span class="string">'Error! Could not reach the API. '</span> + error</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里使用<code>watch</code>允许我们执行异步操作，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些是计算属性无法做到的。除了<code>watch</code>选项，还可以使用命令式的<a href="https://cn.vuejs.org/v2/api/#vm-watch" target="_blank" rel="noopener">vm.$watch API</a>。</p>
<h2 id="Class-和-Style-绑定"><a href="#Class-和-Style-绑定" class="headerlink" title="Class 和 Style 绑定"></a>Class 和 Style 绑定</h2><blockquote>
<p>操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是属性，所以我们可以用 <code>v-bind</code> 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 <code>v-bind</code> 用于 <code>class</code> 和 <code>style</code> 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。</p>
</blockquote>
<h3 id="绑定HTML-Class"><a href="#绑定HTML-Class" class="headerlink" title="绑定HTML Class"></a>绑定HTML Class</h3><ol>
<li><p>对象语法</p>
<p>可以传给 <code>v-bind:class</code>一个对象，以动态的切换class:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123; active: isActive &#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的例子表示<code>active</code>这个class存在与否取决于数据属性<code>isActive</code>的truthiness真值</p>
<p>也可以在对象中传入更多属性来动态的切换多个class。此外，<code>v-class:class</code>指令可以于普通的class属性共存：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"static"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:class</span>=<span class="string">"&#123; active: isActive, 'text-danger': hasError &#125;"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  hasError: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"static active"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当isActive或hasError变化时，class列表将会相应的更新。</p>
<p>除了上面的这种方式，也可以将绑定的对象不必内联定义在模板中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"classObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">'text-danger'</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>渲染结果和上面一样。</p>
<p>此外我们也可以绑定一个计算属性。这是常用且非常强大的方式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"classObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      active: <span class="keyword">this</span>.isActive &amp;&amp; !<span class="keyword">this</span>.error,</span><br><span class="line">      <span class="string">'text-danger'</span>: <span class="keyword">this</span>.error &amp;&amp; <span class="keyword">this</span>.error.type === <span class="string">'fatal'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组语法</p>
<p>可以将一个数组传给<code>v-bind：class</code>来应用一个class列表：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[activeClass,errorClass]"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    activeClass: <span class="string">'active'</span>,</span><br><span class="line">    errorClass: <span class="string">'text-danger'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>渲染结果为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"active text-danger"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以使用三元表达式来根据条件切换列表中的class:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[isActive ? activeClass : '', errorClass]"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当有多个条件时，上面的写法也比较繁琐。所有在数组语法中也可以使用对象语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[ &#123; active: isActive&#125; , errorClass]"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在组件上使用</p>
<p>在一个自定义组件上使用<code>class</code>属性时，这些class将被添加到该组件的根元素上面。元素上面已经存在的class不会被覆盖。</p>
<p>例如：声明一个组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>,&#123;</span><br><span class="line">    template: <span class="string">'&lt;p class="foo bar"&gt;Hi&lt;/p&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用的时候添加class:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">class</span>=<span class="string">"baz boo"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"foo bar baz boo"</span>&gt;</span></span><br><span class="line">  Hi  </span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于带数据绑定的class也同样适用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123;active: isActive&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当<code>isActive</code>为真值的时，结果为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"foo bar active"</span>&gt;</span></span><br><span class="line">    Hi</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="绑定内联样式"><a href="#绑定内联样式" class="headerlink" title="绑定内联样式"></a>绑定内联样式</h3><ol>
<li><p>对象语法</p>
<p><code>v-bind:style</code>的对象语法十分直观——看起来象CSS，但实际上是一个JavaScript对象。CSS属性名可以用驼峰式（camelCase）或者短横线分割（kebab-case）来命名：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"&#123; color: activeColor, fontSize: fontSize + 'px'&#125;"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    activeColor: <span class="string">'red'</span>,</span><br><span class="line">    fontSize: <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接绑定到一个样式对象更加清晰：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"styleObject"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    styleObject: &#123;</span><br><span class="line">        color: <span class="string">'red'</span>,</span><br><span class="line">       	fontSize: <span class="string">'13px'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，对象语法常常结合返回对象的<strong>计算属性</strong>使用。</p>
</li>
</ol>
<ol>
<li><p>数组语法</p>
<p><code>v-bind:style</code>的数组语法可以将多个样式对象应用到同一个元素上：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"[baseStyles, overridingStyles]"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自动添加前缀</p>
<p>当<code>v-bind:style</code>使用需要添加<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Vendor_Prefix" target="_blank" rel="noopener">浏览器引擎前缀</a>的 CSS 属性时，如 <code>transform</code>，Vue.js 会自动侦测并添加相应的前缀。</p>
</li>
<li><p>多重值</p>
<blockquote>
<p>2.3.0+</p>
</blockquote>
<p>可以为<code>style</code>绑定中的属性提供一个包含多个值的数组，常用以提供多个带前缀的值。例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"&#123; display: ['-webkit-box', '-ms-flexbox', 'flex']&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样只会渲染数组中最后一个被浏览器支持的值。</p>
</li>
</ol>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a><code>v-if</code></h3><blockquote>
<p><code>v-if</code> 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">"awesome"</span>&gt;</span></span><br><span class="line">    Vue is awesome!</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以使用<code>v-else</code>添加一个“else” 块</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-if</span>=<span class="string">"awesome"</span>&gt;</span></span><br><span class="line">    Vue is awesome!</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    Oh no 😢</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>在<code>&lt;template&gt;</code>元素上使用<code>v-if</code>条件渲染分组</p>
<p><code>v-if</code>作为一个指令，必须将它添加到一个元素上，但是如果想切换多个元素呢？此时可以将一个<code>&lt;template&gt;</code>元素当作不可见的包裹元素，并在上面使用<code>v-if</code>。最终渲染结果将不包含<code>&lt;template&gt;</code>元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Paragraph 2<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><code>v-else</code></p>
<p>使用<code>v-else</code>指令来表示<code>v-if</code>的“else”块</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"Math.random() &gt; 0.5"</span>&gt;</span></span><br><span class="line">  Now you see me</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Now you don't</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>v-else</code>元素必须紧跟在<code>v-if</code>或<code>v-else-if</code>的元素的后面，否则无法识别。</p>
</li>
<li><p><code>v-else-if</code></p>
<blockquote>
<p>2.1.0 增加</p>
</blockquote>
<p>充当<code>v-if</code>的“else-if”块，可以连续使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"type === 'A'"</span>&gt;</span></span><br><span class="line">  A</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'B'"</span>&gt;</span></span><br><span class="line">  B</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'C'"</span>&gt;</span></span><br><span class="line">  C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Not A/B/C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>类似<code>v-else</code>，<code>v-else-if</code>必须紧跟在<code>v-if</code>或<code>v-else-if</code>的元素的后面。</p>
</li>
<li><p>用<code>key</code>管理可复用的元素</p>
<blockquote>
<p>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your username"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your email address"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么上面的代码中切换<code>loginType</code>不会清除用户已有的输入内容。因为两个模板使用了相同的元素，<code>&lt;input&gt;</code>不会被替换掉，只是替换了它的<code>placeholder</code>。</p>
<p>当然，有时候这也不一定符合实际的需求，所以Vue提供了一种方式表明两个元素是完全独立的，不要复用它们。只需要添加一个具有唯一值的<code>key</code>属性即可：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"loginType === 'username'"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your username"</span> <span class="attr">key</span>=<span class="string">"username-input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Enter your email address"</span> <span class="attr">key</span>=<span class="string">"email-input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样，每次切换时，输入框都会被重新渲染。但是其中的<code>&lt;label&gt;</code>元素仍然被高效的复用，因为它们没有添加<code>key</code> attribute。</p>
</li>
</ol>
<h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a><code>v-show</code></h3><p><code>v-show</code>是一个根据条件展示元素的指令。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">"ok"</span>&gt;</span></span><br><span class="line">    Hello !</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不同的时<code>v-show</code>的元素始终被渲染和保持在DOM中。<code>v-show</code>只是简单的切换元素的CSS attribute <code>display</code>。</p>
<p><strong>注意</strong>：<code>v-show</code>不支持<code>&lt;template&gt;</code>元素，也不支持<code>v-else</code></p>
<h3 id="v-if-versusv-show"><a href="#v-if-versusv-show" class="headerlink" title="v-if versusv-show"></a><code>v-if</code> versus<code>v-show</code></h3><blockquote>
<p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p>
<p><code>v-if</code> 也是<strong>惰性的</strong>：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p>
<p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好。</p>
</blockquote>
<h3 id="v-if-和-v-for一起使用"><a href="#v-if-和-v-for一起使用" class="headerlink" title="v-if 和 v-for一起使用"></a><code>v-if</code> 和 <code>v-for</code>一起使用</h3><blockquote>
<p><strong>不推荐</strong>同时使用 <code>v-if</code> 和 <code>v-for</code></p>
<p>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级。请查阅<a href="https://cn.vuejs.org/v2/guide/list.html#v-for-with-v-if" target="_blank" rel="noopener">列表渲染指南</a> 以获取详细信息。</p>
</blockquote>
<h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><h3 id="用v-for把一个数组对应为一组元素"><a href="#用v-for把一个数组对应为一组元素" class="headerlink" title="用v-for把一个数组对应为一组元素"></a>用<code>v-for</code>把一个数组对应为一组元素</h3><blockquote>
<p>我们可以用 <code>v-for</code> 指令基于一个数组来渲染一个列表。<code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，其中 <code>items</code> 是源数据数组，而 <code>item</code> 则是被迭代的数组元素的<strong>别名</strong>。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">    	&#123;&#123; item.message &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> exampel1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">   el: <span class="string">"#example-1"</span>,</span><br><span class="line">   data: &#123;</span><br><span class="line">       items: [</span><br><span class="line">           &#123;<span class="attr">message</span>: <span class="string">'Foo'</span>&#125;,</span><br><span class="line">           &#123;<span class="attr">message</span>: <span class="string">'Bar'</span>&#125;</span><br><span class="line">       ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在<code>v-for</code>块中，我们可以访问到所有的父作用域的属性。</p>
<p><code>v-for</code>还支持一个可选的第二个参数，当前项的索引。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span>&gt;</span></span><br><span class="line">    &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-2'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    parentMessage: <span class="string">'Parent'</span>,</span><br><span class="line">    items: [</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">'Foo'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">message</span>: <span class="string">'Bar'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>也可以使用<code>of</code>替换<code>in</code> 作为分隔符，更加接近JavaScript迭代器的语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item of items"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="在v-for里使用对象"><a href="#在v-for里使用对象" class="headerlink" title="在v-for里使用对象"></a>在<code>v-for</code>里使用对象</h3><p>使用<code>v-for</code>来遍历对象的属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"v-for-obj"</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"value in object"</span>&gt;</span></span><br><span class="line">    	&#123;&#123; value &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#v-for-obj"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        object: &#123;</span><br><span class="line">            title: <span class="string">'How to do lists in Vue'</span>,</span><br><span class="line">            author: <span class="string">'Jane Doe'</span>,</span><br><span class="line">            publishedAt: <span class="string">'2016-04-10'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>也可以提供第二个参数为property名称，键名：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(value, name) in object"</span>&gt;</span></span><br><span class="line">    &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>还可以使用第三个参数作为索引：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(value, name, index) in object"</span>&gt;</span></span><br><span class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：在遍历对象，会按照Object.keys()的结果遍历，不能保证结果在不同的JS引擎下是一致的。</p>
<h3 id="维护状态"><a href="#维护状态" class="headerlink" title="维护状态"></a>维护状态</h3><blockquote>
<p>当 Vue 正在更新使用 <code>v-for</code> 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个类似 Vue 1.x 的 <code>track-by=&quot;$index&quot;</code>。</p>
</blockquote>
<p>这个默认的模式是高效的，但是<strong>只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出</strong>。</p>
<p>为了让Vue能够跟踪每个节点的身份，从而重用和重新排序现有元素，需要为每项提供一个唯一的<code>key</code> attribute。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">v-bind:key</span>=<span class="string">"item.id"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议尽可能在使用 <code>v-for</code> 时提供 <code>key</code> attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</p>
<p>因为它是 Vue 识别节点的一个通用机制，<code>key</code> 并不仅与 <code>v-for</code> 特别关联。后面我们将在指南中看到，它还具有其它用途。</p>
</blockquote>
<p>注意：不要使用对象或数组之类的非基本类型值作为<code>v-for</code>的<code>key</code>。尽可能使用字符串或数值类型的值。</p>
<p><a href="https://cn.vuejs.org/v2/api/#key" target="_blank" rel="noopener"><code>key</code> 的 API 文档</a>。</p>
<h3 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h3><ol>
<li><p>变异方法 （mutation method）</p>
<p>Vue对侦听的数组的变异方法进行了包裹，所以数组的变异方法也会触发视图更新。被包裹的方法包括：</p>
<ul>
<li><code>push()</code></li>
<li><code>pop()</code></li>
<li><code>shift()</code></li>
<li><code>unshift()</code></li>
<li><code>splice()</code></li>
<li><code>sort()</code></li>
<li><code>reverse()</code></li>
</ul>
</li>
<li><p>替换数组</p>
<blockquote>
<p> 变异方法：会改变了调用这些方法的元素数组。</p>
</blockquote>
<p>非变异方法，例如<code>filter()</code>、<code>concate()</code>、<code>slice()</code>。它们不会改变原始数组，而<strong>总是返回一个新的数组</strong>。</p>
<p>当使用非变异方法时，可以用新数组替换旧数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">example.items = example.items.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item.message.match(<span class="regexp">/Foo/</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意事项</p>
<p>Vue无法检测以下数组的变动：</p>
<ol>
<li>当你使用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li>
<li>当你修改数组的长度时，例如<code>vm.items.length = newLength</code></li>
</ol>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">     data: &#123;</span><br><span class="line">         items: [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.items[<span class="number">1</span>] = <span class="string">'x'</span> <span class="comment">//不是响应式的</span></span><br><span class="line">vm.items.length = <span class="number">2</span> <span class="comment">//不是响应式的</span></span><br></pre></td></tr></table></figure>
<p>为了解决第一种问题，Vue提供了两种方法实现了<code>vm.items[indexOfItem] = newValue</code>相同的效果，并且也可以在响应式系统中触发状态更新：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem,  newValue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, newValue)</span><br></pre></td></tr></table></figure>
<p>你也可以使用 <a href="https://cn.vuejs.org/v2/api/#vm-set" target="_blank" rel="noopener"><code>vm.$set</code></a> 实例方法，该方法是全局方法 <code>Vue.set</code> 的一个别名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$<span class="keyword">set</span>(vm.items, indexOfItem, newValue)</span><br></pre></td></tr></table></figure>
<p>为了解决第二类问题，你可以使用 <code>splice</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="对象变更检测注意事项"><a href="#对象变更检测注意事项" class="headerlink" title="对象变更检测注意事项"></a>对象变更检测注意事项</h3><p>Vue无法检测对象属性的添加和删除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// `vm.a` 现在是响应式的</span></span><br><span class="line"></span><br><span class="line">vm.b = <span class="number">2</span></span><br><span class="line"><span class="comment">// `vm.b` 不是响应式的</span></span><br></pre></td></tr></table></figure>
<p>对于已经创建的实例，Vue不允许动态的添加根级别的响应式属性，但是可以使用<code>Vue.set(object, propertyName, value)</code> 方法向嵌套对象添加响应式属性。例如，对于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    userProfile: &#123;</span><br><span class="line">      name: <span class="string">'Anika'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.set(vm.userProfile, <span class="string">'age'</span>, <span class="number">27</span>)</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$<span class="keyword">set</span>(vm.userProfile, 'age', 27)</span><br></pre></td></tr></table></figure>
<p>有时候需要为已有对象赋值多个新属性，比如使用<code>Object.assign()</code>或<code>_.extend()</code>。你应该用两个对象的属性创建一个新的对象。如果想要添加新的响应式属性，不能像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(vm.userProfile,&#123;</span><br><span class="line">    age: <span class="number">27</span>,</span><br><span class="line">    favoriteColor: <span class="string">'Vue Green'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>而应该这样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.userProfile = <span class="built_in">Object</span>.assign(&#123;&#125;, vm.userProfile, &#123;</span><br><span class="line">  age: <span class="number">27</span>,</span><br><span class="line">  favoriteColor: <span class="string">'Vue Green'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="显示过滤-排序后的结果"><a href="#显示过滤-排序后的结果" class="headerlink" title="显示过滤/排序后的结果"></a>显示过滤/排序后的结果</h3><p>当想要显示一个数组经过过滤或排序后的版本，而不实际改变或重置原始数据。这种情况下，可以创建一个计算属性，来返回过滤或排序的数组。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"n in evenNumbers"</span>&gt;</span> &#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    number: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">    evenNumbers: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> number % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当计算属性不合适的情况下，可以使用一个方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"n in even(numbers)"</span>&gt;</span>&#123;&#123; n &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  numbers: [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ]</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  even: <span class="function"><span class="keyword">function</span> (<span class="params">numbers</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numbers.filter(<span class="function"><span class="keyword">function</span> (<span class="params">number</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> number % <span class="number">2</span> === <span class="number">0</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="v-for使用值范围"><a href="#v-for使用值范围" class="headerlink" title="v-for使用值范围"></a><code>v-for</code>使用值范围</h3><p><code>v-for</code>可以接受整数。这种情况下表示，它会把模板重复对应次数。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-for</span>=<span class="string">"n in 10"</span>&gt;</span>&#123;&#123; n &#125;&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-template-gt-中使用v-for"><a href="#lt-template-gt-中使用v-for" class="headerlink" title="&lt;template&gt;中使用v-for"></a><code>&lt;template&gt;</code>中使用<code>v-for</code></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; item.msg &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"divider"</span> <span class="attr">role</span>=<span class="string">"presentation"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="v-for和v-if一起使用"><a href="#v-for和v-if一起使用" class="headerlink" title="v-for和v-if一起使用"></a><code>v-for</code>和<code>v-if</code>一起使用</h3><p>注意：不推荐</p>
<p>当它们处于同一节点，<code>v-for</code> 的优先级比 <code>v-if</code> 更高，这意味着 <code>v-if</code> 将分别重复运行于每个 <code>v-for</code> 循环中。当你只想为<em>部分</em>项渲染节点时，这种优先级的机制会十分有用，如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span> <span class="attr">v-if</span>=<span class="string">"!todo.isComplete"</span>&gt;</span></span><br><span class="line">  &#123;&#123; todo &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码将只渲染未完成的 todo。</p>
<p>而如果你的目的是有条件地跳过循环的执行，那么可以将 <code>v-if</code> 置于外层元素 (或 <a href="https://cn.vuejs.org/v2/guide/conditional.html#在-lt-template-gt-中配合-v-if-条件渲染一整组" target="_blank" rel="noopener">`</a>)上。如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">"todos.length"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"todo in todos"</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No todos left!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="在组件上使用v-for"><a href="#在组件上使用v-for" class="headerlink" title="在组件上使用v-for"></a>在组件上使用<code>v-for</code></h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.2.0+ 的版本里，当在组件上使用 <code>v-for</code> 时，<code>key</code> 现在是必须的。</p>
</blockquote>
<p>然而，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要使用 prop：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-for&#x3D;&quot;(item, index) in items&quot;</span><br><span class="line">  v-bind:item&#x3D;&quot;item&quot;</span><br><span class="line">  v-bind:index&#x3D;&quot;index&quot;</span><br><span class="line">  v-bind:key&#x3D;&quot;item.id&quot;</span><br><span class="line">&gt;&lt;&#x2F;my-component&gt;</span><br></pre></td></tr></table></figure>
<p>不自动将 <code>item</code> 注入到组件里的原因是，这会使得组件与 <code>v-for</code> 的运作紧密耦合。明确组件数据的来源能够使组件在其他场合重复使用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"todo-list-example"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"addNewTodo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"new-todo"</span>&gt;</span>Add a todo<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-model</span>=<span class="string">"newTodoText"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">"new-todo"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">placeholder</span>=<span class="string">"E.g. Feed the cat"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>Add<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">      <span class="attr">is</span>=<span class="string">"todo-item"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-for</span>=<span class="string">"(todo, index) in todos"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:key</span>=<span class="string">"todo.id"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:title</span>=<span class="string">"todo.title"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-on:remove</span>=<span class="string">"todos.splice(index, 1)"</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意这里的 <code>is=&quot;todo-item&quot;</code> 属性。这种做法在使用 DOM 模板时是十分必要的，因为在 <code>元素内只有</code> 元素会被看作有效内容。这样做实现的效果与 `` 相同，但是可以避开一些潜在的浏览器解析错误。查看 <a href="https://cn.vuejs.org/v2/guide/components.html#解析-DOM-模板时的注意事项" target="_blank" rel="noopener">DOM 模板解析说明</a> 来了解更多信息。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'todo-item'</span>, &#123;</span><br><span class="line">  template: <span class="string">'\</span></span><br><span class="line"><span class="string">    &lt;li&gt;\</span></span><br><span class="line"><span class="string">      &#123;&#123; title &#125;&#125;\</span></span><br><span class="line"><span class="string">      &lt;button v-on:click="$emit(\'remove\')"&gt;Remove&lt;/button&gt;\</span></span><br><span class="line"><span class="string">    &lt;/li&gt;\</span></span><br><span class="line"><span class="string">  '</span>,</span><br><span class="line">  props: [<span class="string">'title'</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#todo-list-example'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    newTodoText: <span class="string">''</span>,</span><br><span class="line">    todos: [</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">1</span>,</span><br><span class="line">        title: <span class="string">'Do the dishes'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">2</span>,</span><br><span class="line">        title: <span class="string">'Take out the trash'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">3</span>,</span><br><span class="line">        title: <span class="string">'Mow the lawn'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    nextTodoId: <span class="number">4</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addNewTodo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.todos.push(&#123;</span><br><span class="line">        id: <span class="keyword">this</span>.nextTodoId++,</span><br><span class="line">        title: <span class="keyword">this</span>.newTodoText</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.newTodoText = <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h3><p><code>v-on</code>指令监听DOM事件，并在触发时运行JavaScript代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"counter += 1"</span>&gt;</span>Add 1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>The button above has been clicked &#123;&#123; counter &#125;&#125; times.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example1 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-1'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    counter: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="事件处理方法"><a href="#事件处理方法" class="headerlink" title="事件处理方法"></a>事件处理方法</h3><p>大部分事件处理的逻辑是相当复杂的，所以直接将JavaScript代码写在<code>v-on</code>指令中是不可行的。因此<code>v-on</code>还可以接受一个需要调用的方法名称。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-2"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- `greet` 是在下面定义的方法名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"greet"</span>&gt;</span>Greet<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-2'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    name: <span class="string">'Vue.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 在 `methods` 对象中定义方法</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    greet: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// `this` 在方法里指向当前 Vue 实例</span></span><br><span class="line">      alert(<span class="string">'Hello '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>)</span><br><span class="line">      <span class="comment">// `event` 是原生 DOM 事件</span></span><br><span class="line">      <span class="keyword">if</span> (event) &#123;</span><br><span class="line">        alert(event.target.tagName)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以用 JavaScript 直接调用方法</span></span><br><span class="line">example2.greet() <span class="comment">// =&gt; 'Hello Vue.js!'</span></span><br></pre></td></tr></table></figure>
<h3 id="内联处理器中的方法"><a href="#内联处理器中的方法" class="headerlink" title="内联处理器中的方法"></a>内联处理器中的方法</h3><p>除了直接绑定到一个方法，也可以在内联JavaScript语句中调用方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-3"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say('hi')"</span>&gt;</span>Say hi<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"say('what')"</span>&gt;</span>Say what<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-3'</span>,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">      alert(message)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>有时也需要在内联语句处理器中访问原始的DOM事件，可以用特殊变量<code>$event</code>把它传入方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"warn('Form cannot be submitted yet.', $event)"</span>&gt;</span></span><br><span class="line">  Submit</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  warn: <span class="function"><span class="keyword">function</span> (<span class="params">message, event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 现在我们可以访问原生事件对象</span></span><br><span class="line">    <span class="keyword">if</span> (event) &#123;</span><br><span class="line">      event.preventDefault()</span><br><span class="line">    &#125;</span><br><span class="line">    alert(message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。</p>
<p>为了解决这个问题，Vue.js为<code>v-on</code>提供了<strong>事件修饰符</strong>。</p>
<p>修饰符是由点开头的指令后缀来表示的。</p>
<ul>
<li><code>.stop</code></li>
<li><code>.prevent</code></li>
<li><code>.capture</code></li>
<li><code>.self</code></li>
<li><code>.once</code></li>
<li><code>.passive</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">"onSubmit"</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">"doThat"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">"doThis"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">"doThat"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：使用修饰符，顺序很重要；相同的代码会以同样的顺序产生。因此因此，用 <code>v-on:click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击。</p>
<blockquote>
<p>2.1.4 增加</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不像其它只能对原生的 DOM 事件起作用的修饰符，<code>.once</code> 修饰符还能被用到自定义的<a href="https://cn.vuejs.org/v2/guide/components-custom-events.html" target="_blank" rel="noopener">组件事件</a>上。</p>
<blockquote>
<p>2.3.0 增加</p>
</blockquote>
<p>Vue 还对应 <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters" target="_blank" rel="noopener"><code>addEventListener</code> 中的 <code>passive</code> 选项</a>提供了 <code>.passive</code> 修饰符。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">"onScroll"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个 <code>.passive</code> 修饰符尤其能够提升移动端的性能。</p>
<blockquote>
<p>注意：不要把 <code>.passive</code> 和 <code>.prevent</code> 一起使用，因为 <code>.prevent</code> 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，<code>.passive</code> 会告诉浏览器你<em>不</em>想阻止事件的默认行为。</p>
</blockquote>
<h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><p>Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">"submit"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你可以直接将 <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values" target="_blank" rel="noopener"><code>KeyboardEvent.key</code></a> 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.page-down</span>=<span class="string">"onPageDown"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，处理函数只会在 <code>$event.key</code> 等于 <code>PageDown</code> 时被调用。</p>
<ul>
<li><code>.enter</code></li>
<li><code>.tab</code></li>
<li><code>.delete</code> (捕获“删除”和“退格”键)</li>
<li><code>.esc</code></li>
<li><code>.space</code></li>
<li><code>.up</code></li>
<li><code>.down</code></li>
<li><code>.left</code></li>
<li><code>.right</code></li>
</ul>
<p>你还可以通过全局 <code>config.keyCodes</code> 对象<a href="https://cn.vuejs.org/v2/api/#keyCodes" target="_blank" rel="noopener">自定义按键修饰符别名</a>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以使用 `v-on:keyup.f1`</span></span><br><span class="line">Vue.config.keyCodes.f1 = <span class="number">112</span></span><br></pre></td></tr></table></figure>
<h3 id="系统修饰键"><a href="#系统修饰键" class="headerlink" title="系统修饰键"></a>系统修饰键</h3><blockquote>
<p>2.1.0 增加</p>
</blockquote>
<p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p>
<ul>
<li><code>.ctrl</code></li>
<li><code>.alt</code></li>
<li><code>.shift</code></li>
<li><code>.meta</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Alt + C --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.alt.67</span>=<span class="string">"clear"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + Click --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.ctrl</span>=<span class="string">"doSomething"</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意修饰键与常规按键不同，在和 <code>keyup</code> 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 <code>ctrl</code> 的情况下释放其它按键，才能触发 <code>keyup.ctrl</code>。而单单释放 <code>ctrl</code> 也不会触发事件。如果你想要这样的行为，请为 <code>ctrl</code> 换用 <code>keyCode</code>：<code>keyup.17</code>。</p>
</blockquote>
<p><code>.exact</code>修饰符</p>
<blockquote>
<p>2.5.0 增加</p>
<p> 修饰符允许你控制由精确的系统修饰符组合触发的事件</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl</span>=<span class="string">"onClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl.exact</span>=<span class="string">"onCtrlClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.exact</span>=<span class="string">"onClick"</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>鼠标按钮修饰符</p>
<blockquote>
<p>2.2.0 新增</p>
</blockquote>
<ul>
<li><code>.left</code></li>
<li><code>.right</code></li>
<li><code>.middle</code></li>
</ul>
<p>这些修饰符会限制处理函数仅响应特定的鼠标按钮。</p>
<h2 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h2><blockquote>
<p>你可以用 <code>v-model</code> 指令在表单 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code> 及 <code>&lt;select&gt;</code> 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 <code>v-model</code> 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。</p>
</blockquote>
<p><code>v-model</code>会忽略所有表单元素的<code>value</code>、<code>checked</code>、<code>selected</code> attribute的初始值，而是将Vue Instance的数据作为数据来源。应该通过<code>data</code>选项来声明初始值。</p>
<p><code>v-model</code> 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>
<ul>
<li>text 和 textarea 元素使用 <code>value</code> 属性和 <code>input</code> 事件；</li>
<li>checkbox 和 radio 使用 <code>checked</code> 属性和 <code>change</code> 事件；</li>
<li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li>
</ul>
<ol>
<li><p>文本</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"edit me"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Message is : &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多行文本</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Multiline message is:<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"white-space: pre-line;"</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">placeholder</span>=<span class="string">"add multiple lines"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在文本区域插值 (<code>&lt;textare&gt;&lt;textarea&gt;</code>) 并不会生效，应用 <code>v-model</code> 来代替。</p>
</li>
<li><p>复选框</p>
<p>单个复选框，绑定到布尔值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"checked"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"checkbox"</span>&gt;</span>&#123;&#123; checked &#125;&#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>多个复选框，绑定到同一个数组：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'example-3'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"jack"</span> <span class="attr">value</span>=<span class="string">"Jack"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"jack"</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"john"</span> <span class="attr">value</span>=<span class="string">"John"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"john"</span>&gt;</span>John<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">id</span>=<span class="string">"mike"</span> <span class="attr">value</span>=<span class="string">"Mike"</span> <span class="attr">v-model</span>=<span class="string">"checkedNames"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"mike"</span>&gt;</span>Mike<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Checked names: &#123;&#123; checkedNames &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-3'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    checkedNames: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>单选按钮</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-4"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"one"</span> <span class="attr">value</span>=<span class="string">"One"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">id</span>=<span class="string">"two"</span> <span class="attr">value</span>=<span class="string">"Two"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Picked: &#123;&#123; picked &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-4'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    picked: <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>选择框</p>
<p>单选时：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-5"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>请选择<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'...'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>多选时：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"example-6"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span> <span class="attr">multiple</span> <span class="attr">style</span>=<span class="string">"width: 50px;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#example-6'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>用<code>v-for</code>渲染的动态选项</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-for</span>=<span class="string">"option in options"</span> <span class="attr">v-bind:value</span>=<span class="string">"option.value"</span>&gt;</span></span><br><span class="line">    &#123;&#123; option.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Selected: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'...'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    selected: <span class="string">'A'</span>,</span><br><span class="line">    options: [</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'One'</span>, <span class="attr">value</span>: <span class="string">'A'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'Two'</span>, <span class="attr">value</span>: <span class="string">'B'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">'Three'</span>, <span class="attr">value</span>: <span class="string">'C'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h3><p>对于单选按钮，复选框和选择框的选项，<code>v-model</code>绑定的值通常是静态的字符串（复选框也可以是布尔值）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当选中时，`picked` 为字符串 "a" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">v-model</span>=<span class="string">"picked"</span> <span class="attr">value</span>=<span class="string">"a"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- `toggle` 为 true 或 false --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">v-model</span>=<span class="string">"toggle"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 当选中第一个选项时，`selected` 为字符串 "abc" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"abc"</span>&gt;</span>ABC<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有时候想把值绑定到Vue Instance的一个动态属性上，这个时候可以用<code>v-bind</code>实现，并且这个属性的值可以不是字符串</p>
<ol>
<li><p>复选框</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">"checkbox"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">"toggle"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">true-value</span>=<span class="string">"yes"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">false-value</span>=<span class="string">"no"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当选中时</span></span><br><span class="line">vm.toggle === <span class="string">'yes'</span></span><br><span class="line"><span class="comment">// 当没有选中时</span></span><br><span class="line">vm.toggle === <span class="string">'no'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的 <code>true-value</code> 和 <code>false-value</code> attribute 并不会影响输入控件的 <code>value</code> attribute，因为浏览器在提交表单时并不会包含未被选中的复选框。如果要确保表单中这两个值中的一个能够被提交，(比如“yes”或“no”)，请换用单选按钮。</p>
</blockquote>
</li>
<li><p>单选按钮</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">v-model</span>=<span class="string">"pick"</span> <span class="attr">v-bind:value</span>=<span class="string">"a"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当选中时</span></span><br><span class="line">vm.pick === vm.a</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>选择框的选项</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">"selected"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 内联对象字面量 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">v-bind:value</span>=<span class="string">"&#123; number: 123 &#125;"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当选中时</span></span><br><span class="line"><span class="keyword">typeof</span> vm.selected <span class="comment">// =&gt; 'object'</span></span><br><span class="line">vm.selected.number <span class="comment">// =&gt; 123</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><ol>
<li><p><code>.lazy</code></p>
<p>默认情况下，<code>v-model</code>在每次<code>input</code>事件触发后将输入框的值与数据进行同步。</p>
<p>可以通过添加<code>lazy</code>修饰符，从而转变为使用<code>change</code>事件进行同步：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在“change”时而非“input”时更新 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.lazy</span>=<span class="string">"msg"</span> &gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><code>.number</code></p>
<p>如果想自动将用户的输入值转为数值类型，可以给 <code>v-model</code> 添加 <code>number</code> 修饰符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">"age"</span> <span class="attr">type</span>=<span class="string">"number"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>即使在<code>type=&#39;number&#39;</code>时，HTML输入元素的值还是返回字符串。如果这个值无法被<code>parseFloat()</code>解析，则会返回原始的值。</p>
</li>
<li><p><code>.trim</code></p>
<p>自动过滤用户输入的首尾空白符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">"msg"</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="在组件上使用v-model"><a href="#在组件上使用v-model" class="headerlink" title="在组件上使用v-model"></a>在组件上使用<code>v-model</code></h3><blockquote>
<p>HTML 原生的输入元素类型并不总能满足需求。幸好，Vue 的组件系统允许你创建具有完全自定义行为且可复用的输入组件。这些输入组件甚至可以和 <code>v-model</code> 一起使用！要了解更多，请参阅组件指南中的<a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#自定义组件的-v-model" target="_blank" rel="noopener">自定义输入组件</a>。</p>
</blockquote>
<h2 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h2><h3 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个名为 button-counter 的新组件</span></span><br><span class="line">Vue.component(<span class="string">'button-counter'</span>, &#123;</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">'&lt;button v-on:click="count++"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>组件是可复用的 Vue 实例，且带有一个名字：在这个例子中是 <code>`。我们可以在一个通过</code>new Vue` 创建的 Vue 根实例中，把这个组件作为自定义元素来使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"components-demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">'#components-demo'</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>组件是可复用的Vue实例，所以它和<code>new Vue</code>接受相同的选项，例如<code>data</code>、<code>computed</code>、<code>watch</code>、<code>method</code>以及生命周期钩子等。唯一的例外是项<code>el</code>这样根实例特有的选项。</p>
<h3 id="组件的复用"><a href="#组件的复用" class="headerlink" title="组件的复用"></a>组件的复用</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"components-demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当点击按钮后，每个组件各自独立维护它的<code>count</code>，因为每用一次组件，就会有一个它的新<strong>实例</strong>被创建</p>
<ol>
<li><p><code>data</code>必须是一个函数</p>
<p>组件的<code>data</code>选项和根实例不一样，必须是一个函数，因此每个是列可以维护一份被返回对象的独立的拷贝。</p>
<p>如果Vue没有这条规则，点击一个按钮可能影响所有组件实例</p>
</li>
</ol>
<h3 id="组件的组织"><a href="#组件的组织" class="headerlink" title="组件的组织"></a>组件的组织</h3><p>通常，一个Application会一颗嵌套的组件树的形式来组织：</p>
<p><img src="/images/vue/components.png" alt="components"></p>
<p>例如：可能有页头 、侧边栏、内容区等组件，每个组件又包含了其他的像导航链接、博文之类的组件。</p>
<p>为了能够在模板中使用，这些组件必须先注册以便Vue能够识别。</p>
<p>两种组件的注册类型：<strong>全局注册</strong>和<strong>局部注册</strong></p>
<p>全局注册</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component-name'</span>, &#123;</span><br><span class="line">  <span class="comment">// ... options ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>全局注册的组件可以用在其被注册之后的任何新创建的Vue根实例，也包括其组件树中的所有子组件的模板中。</p>
<h3 id="通过Prop向子组件传递数据"><a href="#通过Prop向子组件传递数据" class="headerlink" title="　通过Prop向子组件传递数据"></a>　通过Prop向子组件传递数据</h3><p>Prop是在组件上注册的一些自定义attribute。当一个值传递给一个prop attribute的时候，它就变成了那个组件实例的一个属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'blog-post'</span>,&#123;</span><br><span class="line">    props: [<span class="string">'title'</span>],</span><br><span class="line">    template: <span class="string">'&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>一个组件默认可以拥有任意数量的prop，任何值都可以传递给任何prop。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">"My journey with Vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">"Blogging with Vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">"Why Vue is so fun"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在一个典型的应用中，可能在<code>data</code>里有一个数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#blog-post-demo'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    posts: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">'My journey with Vue'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">title</span>: <span class="string">'Blogging with Vue'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">title</span>: <span class="string">'Why Vue is so fun'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">"post in posts"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:key</span>=<span class="string">"post.id"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">"post.title"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面所示，我们可以用<code>v-bind</code>来动态传递prop。</p>
<h3 id="单个根元素"><a href="#单个根元素" class="headerlink" title="单个根元素"></a>单个根元素</h3><p>当构建组件时，模板内通常包含多个内容：</p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><br><span class="line">    &#123;&#123;title&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是如果模板像上面这样写，Vue会提出错误，<code>every component must have a single root element</code>。我们需要将模板的内容包裹在一个复元素内，来修复这个问题，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"blog-post"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当组件变得越来月复杂的时候，为每个相关的信息定义一个prop会变得很麻烦。</p>
<p>这个时候需要对组件进行重构，将它变成接受一个单独的prop</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-for</span>=<span class="string">"post in posts"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:key</span>=<span class="string">"post.id"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:post</span>=<span class="string">"post"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'post'</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="blog-post"&gt;</span></span><br><span class="line"><span class="string">      &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-html="post.content"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的示例使用了JavaScript的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="noopener">模板字符串</a>来让多行的模板更易读。它们在 IE 下并没有被支持，所以如果你需要在不 (经过 Babel 或 TypeScript 之类的工具) 编译的情况下支持 IE，请使用<a href="https://css-tricks.com/snippets/javascript/multiline-string-variables-in-javascript/" target="_blank" rel="noopener">折行转义字符</a>取而代之。</p>
</blockquote>
<h3 id="监听子组件事件"><a href="#监听子组件事件" class="headerlink" title="监听子组件事件"></a>监听子组件事件</h3><p>在上面定义的组件中，可能存在它的一些功能和父级组件进行沟通。</p>
<p>例如：引入一个辅助功能来放大部分内容字体，同时其他部分保持默认的字号。</p>
<p>在其父组件中，通过添加一个<code>postFontSize</code>数据属性来支持这个功能：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">"#blog-posts-events-demo"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        post: [<span class="comment">/* ...*/</span>],</span><br><span class="line">        postFontSize: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这个属性可以在模板中用来控制文字的字号</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"blog-posts-events-demo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"&#123;fontSize: postFontSize + 'em'&#125;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">      		<span class="attr">v-for</span>=<span class="string">"post in posts"</span></span></span><br><span class="line"><span class="tag">      		<span class="attr">v-bind:key</span>=<span class="string">"post.id"</span></span></span><br><span class="line"><span class="tag">      		<span class="attr">v-bind:post</span>=<span class="string">"post"</span></span></span><br><span class="line"><span class="tag">    	&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在子组件添加按钮来放大字号：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'post'</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="blog-post"&gt;</span></span><br><span class="line"><span class="string">      &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt;</span></span><br><span class="line"><span class="string">      &lt;button&gt;</span></span><br><span class="line"><span class="string">        Enlarge text</span></span><br><span class="line"><span class="string">      &lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;div v-html="post.content"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这个时候按钮不会做任何事。</p>
<p>需要当点击按钮后告诉父级组件放大所有文本。</p>
<p>Vue实例提供了一个自定义事件系统来解决，让父级组件能够像处理原生DOM一样通过<code>v-on</code>来监听子组件实例的任意事件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag"> <span class="attr">...</span></span></span><br><span class="line"><span class="tag"> <span class="attr">v-on:enlarge-text</span>=<span class="string">"postFontSize += 0.1"</span></span></span><br><span class="line"><span class="tag">           &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同时子组件可以通过调用内建的<code>$emit</code>方法并传入事件名称来触发一个事件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"$emit('enlarge-text')"</span>&gt;</span></span><br><span class="line">    Enlarge text</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有了这个 <code>v-on:enlarge-text=&quot;postFontSize += 0.1&quot;</code> 监听器，父级组件就会接收该事件并更新 <code>postFontSize</code> 的值。</p>
<ol>
<li><p>使用事件抛出一个值</p>
<p>有时候用一个事件来抛出一个特定的值是有用的。</p>
<p>例如：想要让组件决定它的文本要放大多少。</p>
<p>可以使用<code>$emit</code>的第二个参数来提供这个值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"$emit('enlarge-text', 0.1)"</span>&gt;</span></span><br><span class="line">    Enlarge text</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在父级组件监听这个事件的时候，可以通过<code>$event</code>来访问这个被抛出的值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enlarge-text</span>=<span class="string">"postFontSize+= $event"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者，如果父级组件采用事件处理方法来处理：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">...</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:enlarge-text</span>=<span class="string">"onEnlargeText"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么这个值作为第一个参数传入这个方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    onEnlargeText: <span class="function"><span class="keyword">function</span>(<span class="params">enlargeAmount</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.postFontSize += enlargeAmount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>在组件上使用<code>v-model</code></p>
<p>自定义事件也可以用于创建支持<code>v-model</code>的自定义输入组件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">"searchText"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">"searchText"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">v-on:input</span>=<span class="string">"searchText = $event.target.value"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当在组件上使用时，<code>v-model</code>则会这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:value</span>=<span class="string">"searchText"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:input</span>=<span class="string">"searchText = $event"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了让它正常工作，这个组件内的<code>&lt;input&gt;</code>必须：</p>
<ul>
<li>将其 <code>value</code> attribute 绑定到一个名叫 <code>value</code> 的 prop 上</li>
<li>在其 <code>input</code> 事件被触发时，将新的值通过自定义的 <code>input</code> 事件抛出</li>
</ul>
<p>写成代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'custom-input'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'value'</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      v-bind:value="value"</span></span><br><span class="line"><span class="string">      v-on:input="$emit('input', $event.target.value)"</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>现在<code>v-model</code>就可以在组件上运行起来：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">custom-input</span> <span class="attr">v-model</span>=<span class="string">"searchText"</span>&gt;</span><span class="tag">&lt;/<span class="name">custom-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="通过插槽分发内容"><a href="#通过插槽分发内容" class="headerlink" title="通过插槽分发内容"></a>通过插槽分发内容</h3><p>和HTML元素一样，我们也可能需要向一个组件传递内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">alert-box</span>&gt;</span></span><br><span class="line">Something bad happened.</span><br><span class="line"><span class="tag">&lt;/<span class="name">alert-box</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Vue通过定义<code>&lt;slot&gt;</code>元素可以实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'alert-box'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div class="demo-alert-box"&gt;</span></span><br><span class="line"><span class="string">      &lt;strong&gt;Error!&lt;/strong&gt;</span></span><br><span class="line"><span class="string">      &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>只需要在需要的地方加入插槽就行了。</p>
<h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>有的时候，在不同的组件之间进行动态切换是非常有用的，比如一个多标签的界面。</p>
<p>可以通过Vue的<code>&lt;component&gt;</code>元素加一个特殊的<code>is</code> attribute来实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>currentTabComponent</code> 可以包括</p>
<ul>
<li>已注册组件的名字，或</li>
<li>一个组件的选项对象</li>
</ul>
<p>你可以在<a href="https://jsfiddle.net/chrisvfritz/o3nycadu/" target="_blank" rel="noopener">这里</a>查阅并体验完整的代码，或在<a href="https://jsfiddle.net/chrisvfritz/b2qj69o1/" target="_blank" rel="noopener">这个版本</a>了解绑定组件选项对象，而不是已注册组件名的示例。</p>
<p>注意：<code>is</code>这个属性可以用于常规的HTML元素，但这些元素也将被视为组件。这意味着所有的attribute都会作为DOM attribute被绑定。</p>
<h3 id="解析DOM模板时的注意事项"><a href="#解析DOM模板时的注意事项" class="headerlink" title="解析DOM模板时的注意事项"></a>解析DOM模板时的注意事项</h3><p>有些HTML元素，比如<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;select&gt;</code>，对于那些元素可以出现在内部是有严格限制的。而有些元素只能出现在某些特定元素的内部，比如<code>&lt;li&gt;</code>、<code>&lt;tr&gt;</code>、<code>&lt;option&gt;</code></p>
<p>这就会导致一些问题：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">blog-post-row</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post-row</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个自定义组件会被作为无效的内容提升到外部，并导致最终渲染结果出错。</p>
<p>而<code>is</code> attribute提供了一种变通方法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span> <span class="attr">is</span>=<span class="string">"blog-post-row"</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：<strong>当我们从以下来源使用模板的话，这个限制是不存在的</strong></p>
<ul>
<li>字符串 (例如：<code>template: &#39;...&#39;</code>)</li>
<li><a href="https://cn.vuejs.org/v2/guide/single-file-components.html" target="_blank" rel="noopener">单文件组件 (<code>.vue</code>)</a></li>
<li><code>&lt;script type=&quot;text/x-template&quot;&gt;</code></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>vim快捷键篇</title>
    <url>/2019/11/12/vim%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%AF%87/</url>
    <content><![CDATA[<h1 id="vim-快捷键"><a href="#vim-快捷键" class="headerlink" title="vim 快捷键"></a>vim 快捷键</h1><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>normal 模式下 按下 <code>/</code> 进入查找模式，输入带查找的字符串按下回车，跳转到第一个匹配。使用<code>n</code>和<code>N</code>进行上下查找。查找支持正则表达式，如<code>/vim$</code>匹配行尾。特殊字符需要转义。</p>
<blockquote>
<p>查找回车用<code>\n</code>，替换回车用<code>\r</code></p>
</blockquote>
<p>在查找模式中加入<code>\c</code>表示大小写不敏感，<code>\C</code>表示大小写敏感查找</p>
<p>查找当前单词：在normal模式下按下<code>*</code>即可查找光标所在单词，要求前后为空白字符或标点符号。按下<code>g*</code>即可查找光标所在单词的单词序列，每次对前后字符无要求。</p>
<ul>
<li><code>/string</code>：向下搜索</li>
<li><code>？string</code>：向上搜索</li>
<li><code>/&lt;word\&gt;</code>：搜索单词，而不是字符串</li>
<li><code>n</code>：向下搜索，<code>N</code>：向上搜索</li>
</ul>
<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><p><code>:s(substitute)</code>命令用于查找和替换字符串，语法如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:&#123;作用范围&#125;s&#x2F;&#123;目标&#125;&#x2F;&#123;替换&#125;&#x2F;&#123;替换标志&#125;</span><br></pre></td></tr></table></figure>
<p>作用范围</p>
<ul>
<li>当前行：<code>:s/foo/bar/g</code> <code>/g</code>所以匹配都被替换</li>
<li>全文：<code>:%s/foo/bar/g</code></li>
<li>选区，在Visual模式下选择区域后输入<code>:</code>，<code>:&#39;&lt;,&#39;&gt;s/foo/bar/g</code></li>
<li>2-11行：<code>5,12s/foo/bar/g</code></li>
<li>当前行和接下来两行：<code>:.,+2s/foo/bar/g</code></li>
</ul>
<p>替换标志</p>
<ul>
<li><code>g</code>表示全局替换</li>
<li>无标志表示替换第一次出现</li>
<li><code>i</code>和<code>I</code>分别表示大小写不敏感和敏感：<code>:%s/foo/bar/i</code> &lt;==&gt; <code>:%s/foo\c/bar</code></li>
<li><code>c</code>表示需要确认：<code>:%s/foo/bar/gc</code></li>
</ul>
<p>大小写替换</p>
<ul>
<li><code>-</code>：将光标下的字母改变大小写</li>
<li><code>3~</code>：将光标位置开始的三个字母该变其大小写</li>
<li><code>g~~</code>：改变当前行字母的大小写</li>
<li><code>U</code> 将可视模式下选择的字母全改成大写字母</li>
<li><code>u</code> 将可视模式下选择的字母全改成小写</li>
<li><code>gUU</code> 将当前行的字母改成大写</li>
<li><code>3gUU</code> 将从光标开始到下面3行字母改成大写</li>
<li><code>guu</code> 将当前行的字母全改成小写</li>
<li><code>gUw</code> 将光标下的单词改成大写。</li>
<li><code>guw</code> 将光标下的单词改成小写。</li>
</ul>
<p>折叠命令</p>
<ul>
<li><code>zc</code> 关闭当前打开的折叠</li>
<li><code>zo</code> 打开当前的折叠</li>
<li><code>zm</code> 关闭所有折叠</li>
<li><code>zM</code> 关闭所有折叠及其嵌套的折叠</li>
<li><code>zr</code> 打开所有折叠</li>
<li><code>zR</code> 打开所有折叠及其嵌套的折叠</li>
<li><code>zd</code> 删除当前折叠</li>
<li><code>zE</code> 删除所有折叠</li>
<li><code>zj</code> 移动至下一个折叠</li>
<li><code>zk</code> 移动至上一个折叠</li>
<li><code>zn</code> 禁用折叠</li>
<li><code>zN</code> 启用折叠</li>
</ul>
<h2 id="参考网站"><a href="#参考网站" class="headerlink" title="参考网站"></a>参考网站</h2><ul>
<li><a href="https://harttle.land/2016/08/08/vim-search-in-file.html" target="_blank" rel="noopener">https://harttle.land/2016/08/08/vim-search-in-file.html</a></li>
<li><a href="https://blog.csdn.net/xzz_hust/article/details/72731307" target="_blank" rel="noopener">https://blog.csdn.net/xzz_hust/article/details/72731307</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>vue组件</title>
    <url>/2020/03/18/vue%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="Vue组件"><a href="#Vue组件" class="headerlink" title="　Vue组件"></a>　Vue组件</h1><h2 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h2><h3 id="组件名"><a href="#组件名" class="headerlink" title="组件名"></a>组件名</h3><p>在注册组件的时候，始终需要提供一个名字。</p>
<blockquote>
<p>当直接在DOM中使用一个组件（而不是字符串模板或<a href="https://cn.vuejs.org/v2/guide/single-file-components.html" target="_blank" rel="noopener">单文件组件</a>) 的时候，强烈推荐遵循 <a href="https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name" target="_blank" rel="noopener">W3C 规范</a>中的自定义组件名 (字母全小写且必须包含一个连字符)。这会帮助你避免和当前以及未来的 HTML 元素相冲突。</p>
</blockquote>
<a id="more"></a>
<p>组件名大小写</p>
<p>定义组件名的两种方式</p>
<ul>
<li><p>kebab-case</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component-name'</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>当使用kebab-case定义一个组件时，在引用这个自定义元素时使用kebab-case，比如<code>&lt;my-component-name&gt;</code></p>
</li>
<li><p>PascalCase</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'MyComponentName'</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>当使用PascalCase定义组件时，引用这个自定义元素时，两种命名法都可以使用。即<code>&lt;my-component-name&gt;</code>和<code>&lt;MyComponentName&gt;</code>都是可接受的。</p>
<p>注意：直接在DOM中使用时只有kebab-case是有效的。</p>
</li>
</ul>
<h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><p>比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component-name'</span>, &#123;</span><br><span class="line">    <span class="comment">// ...options...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这样就是<strong>全局注册</strong>的。也就是在全局注册之后就可以用在任何新创建的Vue Root Instance(<code>new Vue</code>)的模板中。比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'component-a'</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line">Vue.component(<span class="string">'component-b'</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line">Vue.component(<span class="string">'component-c'</span>, &#123; <span class="comment">/* ... */</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123; <span class="attr">el</span>: <span class="string">'#app'</span> &#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component-a</span>&gt;</span><span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component-b</span>&gt;</span><span class="tag">&lt;/<span class="name">component-b</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component-c</span>&gt;</span><span class="tag">&lt;/<span class="name">component-c</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在所有的子组件中也是如此，也就是说这三个组件内部也是可以互相使用。</p>
<h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><p>全局注册往往是不合理的。当在类似webpack这样的构建系统，全局注册所有组件意味着即便不在使用某个组件，但它仍然被包含在最终的构建结构中，这就造成JS无谓的增加。</p>
<p>在这些情况下，可以使用一个normal 的 JavaScript对象来定义组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentA = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> ComponentB = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> ComponentC = &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>然后在Vue根实例中通过<code>components</code>选项来定义想要使用的组件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">'component-a'</span>: ComponentA,</span><br><span class="line">    <span class="string">'component-b'</span>: ComponentB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>对于<code>components</code>对象中的每个属性来说，其属性名就是自定义元素的名字，其属性值就是组件的选项对象。</p>
<p>注意：<strong>局部注册的组件在其子组件中不可使用</strong>。</p>
<p>如果想要在<code>ComponentA</code>在<code>ComponentB</code>中使用，需要这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentA = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ComponentB = &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">'component-a'</span>: ComponentA</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者如果通过Babel和webpack使用ES2015模块，代码应该这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ComponentA <span class="keyword">from</span> <span class="string">'./ComponentA.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ComponentA</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意在 ES2015+ 中，在对象中放一个类似 <code>ComponentA</code> 的变量名其实是 <code>ComponentA: ComponentA</code> 的缩写，即这个变量名同时是：</p>
<ul>
<li>用在模板中的自定义元素的名称</li>
<li>包含了这个组件选项的变量名</li>
</ul>
<h3 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h3><blockquote>
<p>如果你还在阅读，说明你使用了诸如 Babel 和 webpack 的模块系统。在这些情况下，我们推荐创建一个 <code>components</code> 目录，并将每个组件放置在其各自的文件中。</p>
</blockquote>
<ol>
<li><p>在模块系统中局部注册</p>
<p>在局部注册之前导入每个想要使用的组件。例如在一个假设的<code>ComponentB.js</code>或<code>ComponentB.vue</code>文件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ComponentA <span class="keyword">from</span> <span class="string">'./ComponentA'</span></span><br><span class="line"><span class="keyword">import</span> ComponentC <span class="keyword">from</span> <span class="string">'./ComponentC'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ComponentA,</span><br><span class="line">    ComponentC</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样 <code>ComponentA</code> 和 <code>ComponentC</code> 都可以在 <code>ComponentB</code> 的模板中使用了。</p>
</li>
<li><p>基础组件的自动化全局注册</p>
<blockquote>
<p>可能你的许多组件只是包裹了一个输入框或按钮之类的元素，是相对通用的。我们有时候会把它们称为<a href="https://cn.vuejs.org/v2/style-guide/#基础组件名-强烈推荐" target="_blank" rel="noopener">基础组件</a>，它们会在各个组件中被频繁的用到。</p>
</blockquote>
<p>采用上述的局部注册会导致很多组件都会有一个包含基础组件的长列表。这会导致重复代码并且很难管理。</p>
<p>如果使用了webpack（或者在内部使用了webpack的<a href="https://github.com/vuejs/vue-cli" target="_blank" rel="noopener">Vue CLI 3+</a>），那么可以使用<code>require.context</code>来全局注册一些非常通用的基础组件。</p>
<p>下面是一份可以让我们在应用入口文件（比如：<code>src/main.js</code>）中全局导入基础组件的示例代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> upperFirst <span class="keyword">from</span> <span class="string">'lodash/upperFirst'</span></span><br><span class="line"><span class="keyword">import</span> camelCase <span class="keyword">from</span> <span class="string">'lodash/camelCase'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.context(</span><br><span class="line">  <span class="comment">// 其组件目录的相对路径</span></span><br><span class="line">  <span class="string">'./components'</span>,</span><br><span class="line">  <span class="comment">// 是否查询其子目录</span></span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 匹配基础组件文件名的正则表达式</span></span><br><span class="line">  /Base[A-Z]\w+\.(vue|js)$/</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">requireComponent.keys().forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取组件配置</span></span><br><span class="line">  <span class="keyword">const</span> componentConfig = requireComponent(fileName)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取组件的 PascalCase 命名</span></span><br><span class="line">  <span class="keyword">const</span> componentName = upperFirst(</span><br><span class="line">    camelCase(</span><br><span class="line">      <span class="comment">// 获取和目录深度无关的文件名</span></span><br><span class="line">      fileName</span><br><span class="line">        .split(<span class="string">'/'</span>)</span><br><span class="line">        .pop()</span><br><span class="line">        .replace(<span class="regexp">/\.\w+$/</span>, <span class="string">''</span>)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局注册组件</span></span><br><span class="line">  Vue.component(</span><br><span class="line">    componentName,</span><br><span class="line">    <span class="comment">// 如果这个组件选项是通过 `export default` 导出的，</span></span><br><span class="line">    <span class="comment">// 那么就会优先使用 `.default`，</span></span><br><span class="line">    <span class="comment">// 否则回退到使用模块的根。</span></span><br><span class="line">    componentConfig.default || componentConfig</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>全局注册的行为必须在根Vue实例创建之前发生。</p>
<p><a href="https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js" target="_blank" rel="noopener">这里</a>有一个真实项目情景下的示例。</p>
<h2 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h2><h3 id="Prop的大小写-camelCase-versus-kebab-case"><a href="#Prop的大小写-camelCase-versus-kebab-case" class="headerlink" title="Prop的大小写 (camelCase versus kebab-case)"></a>Prop的大小写 (camelCase versus kebab-case)</h3><p>HTML中的attribute名是大小写不敏感的，因此Browers会把所有的大写字符解释为小写字符。</p>
<p>因此，当使用DOM中的模板时，camelCase的prop名需要使用其等价的kebab-case命名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</span><br><span class="line">  <span class="comment">// 在 JavaScript 中是 camelCase 的</span></span><br><span class="line">  props: [<span class="string">'postTitle'</span>],</span><br><span class="line">  template: <span class="string">'&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在 HTML 中是 kebab-case 的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">post-title</span>=<span class="string">"hello!"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：如果使用字符串模板，就没有这个限制。</p>
<h3 id="Prop类型"><a href="#Prop类型" class="headerlink" title="Prop类型"></a>Prop类型</h3><p>到目前为止，我们只是用字符串数组形式列出prop。</p>
<p>但是，通常需要对每个prop指定值类型，这个时候需要使用对象形式列出prop。这些属性的名称和值分别是prop各自的名称和类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  title: <span class="built_in">String</span>,</span><br><span class="line">  likes: <span class="built_in">Number</span>,</span><br><span class="line">  isPublished: <span class="built_in">Boolean</span>,</span><br><span class="line">  commentIds: <span class="built_in">Array</span>,</span><br><span class="line">  author: <span class="built_in">Object</span>,</span><br><span class="line">  callback: <span class="built_in">Function</span>,</span><br><span class="line">  contactsPromise: <span class="built_in">Promise</span> <span class="comment">// or any other constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这不仅为你的组件提供了文档，还会在它们遇到错误的类型时从浏览器的 JavaScript 控制台提示用户。你会在这个页面接下来的部分看到<a href="https://cn.vuejs.org/v2/guide/components-props.html#Prop-验证" target="_blank" rel="noopener">类型检查和其它 prop 验证</a>。</p>
</blockquote>
<h3 id="传送静态或动态Prop"><a href="#传送静态或动态Prop" class="headerlink" title="传送静态或动态Prop"></a>传送静态或动态Prop</h3><p>传递静态值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">title</span>=<span class="string">"My journey with Vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可以通过<code>v-bind</code>指令来动态传值，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 动态赋予一个变量的值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:title</span>=<span class="string">"post.title"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态赋予一个复杂表达式的值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">"post.title + ' by ' + post.author.name"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>传入一个数字</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:likes</span>=<span class="string">"42"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:likes</span>=<span class="string">"post.likes"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>传入一个布尔值</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 包含该 prop 没有值的情况在内，都意味着 `true`。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">is-published</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:is-published</span>=<span class="string">"false"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:is-published</span>=<span class="string">"post.isPublished"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>传入一个数组</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:comment-ids</span>=<span class="string">"[234, 266, 273]"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:comment-ids</span>=<span class="string">"post.commentIds"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>传入一个对象</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这是一个 JavaScript 表达式而不是一个字符串。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:author</span>=<span class="string">"&#123;</span></span></span><br><span class="line"><span class="tag"><span class="string">    name: 'Veronica',</span></span></span><br><span class="line"><span class="tag"><span class="string">    company: 'Veridian Dynamics'</span></span></span><br><span class="line"><span class="tag"><span class="string">  &#125;"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 用一个变量进行动态赋值。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind:author</span>=<span class="string">"post.author"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>传入一个对象所有的属性</p>
<p>如果想要将一个对象的所有属性都作为prop传入，可以使用不带参数的<code>v-bind</code>（取代<code>v-bind:prop-name</code>）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">post: &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    title: <span class="string">'My Journey with Vue'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span> <span class="attr">v-bind</span>=<span class="string">"post"</span>&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>​        ===</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blog-post</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:id</span>=<span class="string">"post.id"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">"post.title"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p>所有的prop使得父子prop之间形成了一个<strong>单向下行绑定</strong>：父级prop的更新会向下流动到子组件中，但反过来则不行。这样防止了子组件意外改变父级组件的状态，从而导致数据流向难以理解。</p>
<p>另外，每次父级组件发生更新，子组件中所有的prop都会刷新。</p>
<p>这表明不应该在子组件内部改变prop。</p>
<p>下面是两种常见的试图改变一个prop的情况</p>
<ol>
<li><p>prop用来传递初始值；子组件希望将其作为一个本地的prop数据来使用。在这种情况下，最好定一个本地的data属性并将这个prop用作其初始值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'initialCounter'</span>],</span><br><span class="line">data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        counter: <span class="keyword">this</span>.initialCounter</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>prop以一种原始的值传入且需要转换。这种情况，最好使用这个prop值来定义一个计算属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">props: [<span class="string">'size'</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">    normalizedSize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size.trim().toLowerCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意：JavaScript中对象和数组是通过引用传入的，所以对数组或对象类型的prop来说，在子组件中改变这个对象或数组会影响父组件的状态。</p>
<h3 id="Prop验证"><a href="#Prop验证" class="headerlink" title="Prop验证"></a>Prop验证</h3><p>组件中的prop可以指定验证请求，如果存在要求没有满足，则Vue会在浏览器的Console警告你。</p>
<p>为了提供对prop的验证，可以为<code>props</code>中的值提供一个带有验证请求的对象，而不是一个字符串数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span></span><br><span class="line">    propA: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 多个可能的类型</span></span><br><span class="line">    propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">    <span class="comment">// 必填的字符串</span></span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的数字</span></span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: <span class="built_in">Number</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的对象</span></span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: <span class="built_in">Object</span>,</span><br><span class="line">      <span class="comment">// 对象或数组默认值必须从一个工厂函数获取</span></span><br><span class="line">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; <span class="attr">message</span>: <span class="string">'hello'</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'success'</span>, <span class="string">'warning'</span>, <span class="string">'danger'</span>].indexOf(value) !== <span class="number">-1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>注意：prop会在一个组件Instance被创建<strong>之前</strong>进行验证，所以Instance的属性（如<code>data</code>、<code>computed</code>等）无法在<code>default</code>或<code>valiator</code>函数中使用。</p>
<ol>
<li><p>类型检查</p>
<p><code>type</code> 可以是下列原生构造函数中的一个：</p>
<ul>
<li><code>String</code></li>
<li><code>Number</code></li>
<li><code>Boolean</code></li>
<li><code>Array</code></li>
<li><code>Object</code></li>
<li><code>Date</code></li>
<li><code>Function</code></li>
<li><code>Symbol</code></li>
</ul>
<p>另外，<code>type</code>也可以是一个自定义的构造函数，并通过<code>instanceof</code>来进行检查确认。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    author: Person</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>来验证 <code>author</code> prop 的值是否是通过 <code>new Person</code> 创建的。</p>
</li>
</ol>
<h3 id="非Prop的Attribute"><a href="#非Prop的Attribute" class="headerlink" title="非Prop的Attribute"></a>非Prop的Attribute</h3><p>非prop的Attribute是指传向一个组件，但是该组件并没有相应的prop定义的attribute。</p>
<p>显式定义的prop适用于向一个子组件传入信息，然而组件库的author不总能预见组件被用于什么样的场景。</p>
<p>这就是为什么组件可以接受任何的attribute，而这些attribute被添加到这个组件的根元素上。</p>
<blockquote>
<p>例如，想象一下你通过一个 Bootstrap 插件使用了一个第三方的 <code>组件，这个插件需要在其</code> 上用到一个 <code>data-date-picker</code> attribute。我们可以将这个 attribute 添加到你的组件实例上：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bootstrap-date-input</span> <span class="attr">data-date-picker</span>=<span class="string">"activated"</span>&gt;</span><span class="tag">&lt;/<span class="name">bootstrap-date-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后这个 <code>data-date-picker=&quot;activated&quot;</code> attribute 就会自动添加到 <code>&lt;bootstrap-date-input&gt;</code> 的根元素上。</p>
</blockquote>
<ol>
<li><p>替换/合并已有的Attribute</p>
<p>假设<code>&lt;bootstrap-date-input&gt;</code>的模板是这样的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'date'</span> <span class="attr">class</span>=<span class="string">'form-control'</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了给日期选择器定义一个主题，需要添加一个类名：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bootstrap-date-input</span>	</span></span><br><span class="line"><span class="tag">  <span class="attr">data-date-picker</span>=<span class="string">"activated"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"date-picker-theme-dark"</span>     &gt;</span><span class="tag">&lt;/<span class="name">bootstrap-date-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种情况下，我们定义了两个不同的<code>class</code>的值：</p>
<ul>
<li><code>form-control</code>，这是在组件的模板内设置好的</li>
<li><code>date-picker-theme-dark</code>，这是从组件的父级传入的</li>
</ul>
<p>对于绝大多数 attribute 来说，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 <code>type=&quot;text&quot;</code> 就会替换掉 <code>type=&quot;date&quot;</code> 并把它破坏！庆幸的是，<code>class</code> 和 <code>style</code> attribute 会稍微智能一些，即两边的值会被合并起来，从而得到最终的值：<code>form-control date-picker-theme-dark</code>。</p>
</li>
<li><p>禁用Attribute继承</p>
<p>如果<strong>不</strong>希望组件的根元素继承attribute，则需要在组件的选项中设置<code>inheritAttrs:false</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">    inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这适合配合实例的<code>$attrs</code>属性使用，该属性包含了传递给一个组件的attribute名和attribute值，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  required: <span class="literal">true</span>,</span><br><span class="line">  placeholder: <span class="string">'Enter your username'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了 <code>inheritAttrs: false</code> 和 <code>$attrs</code>，你就可以手动决定这些 attribute 会被赋予哪个元素。在撰写<a href="https://cn.vuejs.org/v2/style-guide/#基础组件名-强烈推荐" target="_blank" rel="noopener">基础组件</a>的时候是常会用到的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'base-input'</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  props: [<span class="string">'label'</span>, <span class="string">'value'</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;input</span></span><br><span class="line"><span class="string">        v-bind="$attrs"</span></span><br><span class="line"><span class="string">        v-bind:value="value"</span></span><br><span class="line"><span class="string">        v-on:input="$emit('input', $event.target.value)"</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注意：<code>inheritAttrs:false</code>选项不会影响<code>style</code>和<code>class</code>的绑定。</p>
<p>这个模式允许你在使用基础组件的时候更像是使用原始的 HTML 元素，而不会担心哪个元素是真正的根元素：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">"username"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">required</span></span></span><br><span class="line"><span class="tag">  <span class="attr">placeholder</span>=<span class="string">"Enter your username"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><h3 id="事件名"><a href="#事件名" class="headerlink" title="事件名"></a>事件名</h3><p>不同于组件和prop，事件名不存在任何自动化的大小写转换。而是触发的事件名需要完全匹配监听这个事件所用的名称。</p>
<p>如果采用camelCase名字的事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'myEvent'</span>)</span><br></pre></td></tr></table></figure>
<p>则监听这个名字的kebab-case版本是不会有任何效果的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-on:my-event</span>=<span class="string">"doSomething"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不同于组件和prop，事件名不会被用作一个JavaScrip变量名或属性名，所以就没有理由使用camelCase和PascalCase了。并且<code>v-on</code>事件监听器在DOM模板中会被自动转换成全小写（因为HTML是大小写不敏感的），所以<code>v-on:myEvent</code>会变成<code>v-on:myevent</code>而导致<code>myEvent</code>不可能被监听到。</p>
<p>因此，推荐<strong>始终使用kebab-case</strong>的事件名</p>
<h3 id="自定义组件的v-model"><a href="#自定义组件的v-model" class="headerlink" title="自定义组件的v-model"></a>自定义组件的<code>v-model</code></h3><p>一个组件上的<code>v-model</code>会默认利用名为<code>value</code>的prop和名为<code>input</code>的事件，但是单选框、复选框等类型的输入控件可能将<code>value</code>attribute用于<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value" target="_blank" rel="noopener">不同的目的</a>。<code>model</code>选项可以避免这种冲突：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'base-checkbox'</span>, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">'checked'</span>,</span><br><span class="line">    event: <span class="string">'change'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    checked: <span class="built_in">Boolean</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      type="checkbox"</span></span><br><span class="line"><span class="string">      v-bind:checked="checked"</span></span><br><span class="line"><span class="string">      v-on:change="$emit('change', $event.target.checked)"</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>现在在这个组件上使用<code>v-model</code>的时候：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-checkbox</span> <span class="attr">v-model</span>=<span class="string">"lovingVue"</span>&gt;</span><span class="tag">&lt;/<span class="name">base-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>lovingVue</code>的值将会传入名为<code>checked</code>的prop。同时当<code>&lt;base-checkbox&gt;</code>触发一个<code>change</code>事件并附带一个新的值的时候，这个<code>lovingVue</code>属性将会被更新。</p>
<p>注意：仍然需要在组件的<code>props</code>选项中声明<code>checked</code>这个prop。</p>
<h3 id="将原生事件绑定到组件"><a href="#将原生事件绑定到组件" class="headerlink" title="将原生事件绑定到组件"></a>将原生事件绑定到组件</h3><p>假设想要在一个组件的根元素上直接监听一个原生事件。</p>
<p>这是时候可以使用<code>v-on</code>的<code>.native</code>修饰符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span> <span class="attr">v-on:focus.native</span>=<span class="string">"onFocus"</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>有的时候这个是有用的。但是在监听一个类似<code>&lt;input&gt;</code>的特定元素时，这不是一个好方法。比如上面所述的<code>&lt;base-input&gt;</code>做了如下重构，所以根元素实际上是一个<code>&lt;lable&gt;</code>元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">  &#123;&#123; label &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind</span>=<span class="string">"$attrs"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:value</span>=<span class="string">"value"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-on:input</span>=<span class="string">"$emit('input', $event.target.value)"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个时候，父级的<code>.native</code>监听器就会静默失败。不会产生任何错误，但是<code>onFocus</code>处理函数不会如预期执行。</p>
<p>为了解决这种问题，Vue提供了<code>$listeners</code>属性，它是一个对象，包含了作用在这个组件上的所有监听器。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  focus: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  input: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>$listeners</code> 属性，配合 <code>v-on=&quot;$listeners&quot;</code> 将所有的事件监听器指向这个组件的某个特定的子元素。对于类似 <code>&lt;input&gt;</code> 的你希望它也可以配合 <code>v-model</code> 工作的组件来说，为这些监听器创建一个类似下述 <code>inputListeners</code> 的计算属性通常是非常有用的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'base-input'</span>, &#123;</span><br><span class="line">  inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">  props: [<span class="string">'label'</span>, <span class="string">'value'</span>],</span><br><span class="line">  computed: &#123;</span><br><span class="line">    inputListeners: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> vm = <span class="keyword">this</span></span><br><span class="line">      <span class="comment">// `Object.assign` 将所有的对象合并为一个新对象</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,</span><br><span class="line">        <span class="comment">// 我们从父级添加所有的监听器</span></span><br><span class="line">        <span class="keyword">this</span>.$listeners,</span><br><span class="line">        <span class="comment">// 然后我们添加自定义监听器，</span></span><br><span class="line">        <span class="comment">// 或覆写一些监听器的行为</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 这里确保组件配合 `v-model` 的工作</span></span><br><span class="line">          input: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">            vm.$emit(<span class="string">'input'</span>, event.target.value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">      &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">      &lt;input</span></span><br><span class="line"><span class="string">        v-bind="$attrs"</span></span><br><span class="line"><span class="string">        v-bind:value="value"</span></span><br><span class="line"><span class="string">        v-on="inputListeners"</span></span><br><span class="line"><span class="string">      &gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>注：<code>**Object.assign()**</code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(target, ...sources)</span><br></pre></td></tr></table></figure>
<p>现在 <code>&lt;base-input&gt;</code> 组件是一个<strong>完全透明的包裹器</strong>了，也就是说它可以完全像一个普通的 <code>&lt;input&gt;</code> 元素一样使用了：所有跟它相同的 attribute 和监听器都可以工作。</p>
<h3 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title=".sync修饰符"></a><code>.sync</code>修饰符</h3><blockquote>
<p>2..3.0+ 增加</p>
</blockquote>
<p>有些情况，需要对一个prop进行“双向绑定”。但是真正的双向绑定会带来维护上的问题。因为子组件可以修改父组件，且父组件和子组件没有明显的改变来源。</p>
<p>所以Vue推荐以<code>update:myPropName</code>的模式触发事件取而代之。例如，在一个包含<code>title</code>prop的组件用，可以使用以下方法表达对其赋新值的意图：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'update:title'</span>, newTitle)</span><br></pre></td></tr></table></figure>
<p>然后父组件可以监听那个事件并根据需要更新一个本地的数据属性。例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:title</span>=<span class="string">"doc.title"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-on:update:title</span>=<span class="string">"doc.title = $event"</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>为了方便，Vue为这种模式提供了一个缩写，即<code>.sync</code>修饰符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">v-bind:title.sync</span>=<span class="string">"doc.title"</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> <strong>不能</strong>和表达式一起使用 (例如 <code>v-bind:title.sync=”doc.title + ‘!’”</code> 是无效的)。取而代之的是，你只能提供你想要绑定的属性名，类似 <code>v-model</code>。</p>
</blockquote>
<p>当用一个对象同时设置多个prop的时候，也可以将这个<code>.sync</code>修饰符和<code>v-bind</code>配合使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text-document</span> <span class="attr">v-bind.sync</span>=<span class="string">"doc"</span>&gt;</span><span class="tag">&lt;/<span class="name">text-document</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样会把 <code>doc</code> 对象中的每一个属性 (如 <code>title</code>) 都作为一个独立的 prop 传进去，然后各自添加用于更新的 <code>v-on</code> 监听器。</p>
<blockquote>
<p>将 <code>v-bind.sync</code> 用在一个字面量的对象上，例如 <code>v-bind.sync=”{ title: doc.title }”</code>，是无法正常工作的，因为在解析一个像这样的复杂表达式的时候，有很多边缘情况需要考虑。</p>
</blockquote>
<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><blockquote>
<p>在 2.6.0 中，我们为具名插槽和作用域插槽引入了一个新的统一的语法 (即 <code>v-slot</code> 指令)。它取代了 <code>slot</code> 和 <code>slot-scope</code> 这两个目前已被废弃但未被移除且仍在<a href="https://cn.vuejs.org/v2/guide/components-slots.html#废弃了的语法" target="_blank" rel="noopener">文档中</a>的 attribute。新语法的由来可查阅这份 <a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0001-new-slot-syntax.md" target="_blank" rel="noopener">RFC</a>。</p>
</blockquote>
<h3 id="插槽内容"><a href="#插槽内容" class="headerlink" title="插槽内容"></a>插槽内容</h3><blockquote>
<p>Vue 实现了一套内容分发的 API，这套 API 的设计灵感源自 <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md" target="_blank" rel="noopener">Web Components 规范草案</a>，将 `` 元素作为承载分发内容的出口。</p>
</blockquote>
<p>通过插槽它允许这个合成组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">"/profile"</span>&gt;</span></span><br><span class="line">  Your Profile</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;navigation-link&gt;</code>的模板可能这样写：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:href</span>=<span class="string">"url"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"nav-link"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>渲染的时候，<code>&lt;slot&gt;&lt;/slot&gt;</code>将会被替换乘”Your Profile”。插槽内可以包含任何模板代码，包括HTML:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">"/profile"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 添加一个 Font Awesome 图标 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"fa fa-user"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  Your Profile</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>甚至其他组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">"/profile"</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 添加一个图标的组件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">font-awesome-icon</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span><span class="tag">&lt;/<span class="name">font-awesome-icon</span>&gt;</span></span><br><span class="line">  Your Profile</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果没有包含<code>&lt;slot&gt;</code>元素，则组件标签内的内容会被抛弃。</p>
<h3 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h3><p>当想要在一个插槽中使用数据的时候：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">"/profile"</span>&gt;</span></span><br><span class="line">  Logged in as &#123;&#123; user.name &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该插槽和模板的其他地方一样可以访问相同实例属性（也就是相同的“作用域”），但<strong>不能</strong>访问<code>&lt;navigation-link&gt;的作用域。</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">"/profile"</span>&gt;</span></span><br><span class="line">  Clicking here will send you to: &#123;&#123; url &#125;&#125;</span><br><span class="line">  <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  这里的 `url` 会是 undefined，因为 "/profile" 是</span></span><br><span class="line"><span class="comment">  _传递给_ &lt;navigation-link&gt; 的而不是</span></span><br><span class="line"><span class="comment">  在 &lt;navigation-link&gt; 组件*内部*定义的。</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注：父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p>
<h3 id="后备内容"><a href="#后备内容" class="headerlink" title="后备内容"></a>后备内容</h3><p>为一个插槽设置具体的默认（后备）内容是必要的，在没有提供内容的时候渲染。比如在在<code>&lt;submit-button&gt;</code>中</p>
<p>希望绝大多数情况下渲染“Submit”。为了将”Submit”作为后备内容，将它放在<code>&lt;slot&gt;</code>标签内：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><blockquote>
<p>2.6.0 更新。已废弃的使用 <code>slot</code> attribute 的语法在<a href="https://cn.vuejs.org/v2/guide/components-slots.html#废弃了的语法" target="_blank" rel="noopener">这里</a>。</p>
</blockquote>
<p>有时候需要多个插槽，比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把页头放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把主要内容放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 我们希望把页脚放这里 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于这种情况，<code>&lt;slot&gt;</code>元素有个特殊的attribute：<code>name</code>。这个attribute用来定义额外的插槽：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不带<code>name</code>的<code>&lt;slot&gt;</code>出口带有隐含的名字”defaukt”</p>
<p>向具名插槽提供内容的时候，我们可以在一个<code>&lt;template&gt;</code>元素上使用<code>v-slot</code>指令，并以<code>v-slot</code>的参数形式提供其名称：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here's some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样，<code>&lt;template&gt;</code>元素的内容都会被传入相应的插槽中。任何没有包裹在<code>v-slot</code>的<code>&lt;template&gt;</code>被视为默认插槽的内容。</p>
<p>如果想要更具体一点，可以：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here's some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><blockquote>
<p>自 2.6.0 起有所更新。已废弃的使用 <code>slot-scope</code> attribute 的语法在<a href="https://cn.vuejs.org/v2/guide/components-slots.html#废弃了的语法" target="_blank" rel="noopener">这里</a>。    </p>
</blockquote>
<p>有时需要让插槽内容访问到子组件的数据是很有用的。</p>
<p>为了让 <code>user</code> 在父级的插槽内容中可用，我们可以将 <code>user</code> 作为 `` 元素的一个 attribute 绑定上去：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span> <span class="attr">v-bind:user</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">    &#123;&#123; user.lastName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>绑定在 <code>` 元素上的 attribute 被称为**插槽 prop**。现在在父级作用域中，我们可以使用带值的</code>v-slot` 来定义我们提供的插槽 prop 的名字：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们选择将包含所有插槽 prop 的对象命名为 <code>slotProps</code>，但你也可以使用任意你喜欢的名字。</p>
<ol>
<li><p>独占默认插槽的缩写语法</p>
<p>，不带参数的 <code>v-slot</code> 被假定对应默认插槽：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">  &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意默认插槽的缩写语法<strong>不能</strong>和具名插槽混用，因为它会导致作用域不明确。</p>
<p>出现多个插槽，始终为所有的插槽使用完整的基于<code>&lt;template&gt;</code>的语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:default</span>=<span class="string">"slotProps"</span>&gt;</span></span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:other</span>=<span class="string">"otherSlotProps"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解构插槽prop</p>
<p>作用域插槽的内部原理是：将你的插槽内容包括在一个传入单个参数的函数里：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">slotProps</span>)</span>&#123;</span><br><span class="line"> <span class="comment">//插槽内容   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这意味着 <code>v-slot</code> 的值实际上可以是任何能够作为函数定义中的参数的 JavaScript 表达式。</p>
<p>所以在支持的环境下 (<a href="https://cn.vuejs.org/v2/guide/single-file-components.html" target="_blank" rel="noopener">单文件组件</a>或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#浏览器兼容" target="_blank" rel="noopener">现代浏览器</a>)，你也可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#解构对象" target="_blank" rel="noopener">ES2015 解构</a>来传入具体的插槽 prop，如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">"&#123; user &#125;"</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样使得模板更加简介，尤其在插槽提供了多个prop的时候，它们同样提供了将prop重命名的其他可能，比如将<code>user</code>重命名为<code>person</code>:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">"&#123; user: person &#125;"</span>&gt;</span></span><br><span class="line">  &#123;&#123; person.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你甚至可以定义后备内容，用于插槽 prop 是 undefined 的情形：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">current-user</span> <span class="attr">v-slot</span>=<span class="string">"&#123; user = &#123; firstName: 'Guest' &#125; &#125;"</span>&gt;</span></span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">current-user</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="动态插槽名"><a href="#动态插槽名" class="headerlink" title="动态插槽名"></a>动态插槽名</h3><p><a href="https://cn.vuejs.org/v2/guide/syntax.html#动态参数" target="_blank" rel="noopener">动态指令参数</a>也可以用在 <code>v-slot</code> 上，来定义动态的插槽名：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:</span>[<span class="attr">dynamicSlotName</span>]&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="具名插槽的缩写"><a href="#具名插槽的缩写" class="headerlink" title="具名插槽的缩写"></a>具名插槽的缩写</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-layout</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Here might be a page title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph for the main content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>And another one.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> #<span class="attr">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here's some contact info<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">base-layout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="其他示例"><a href="#其他示例" class="headerlink" title="其他示例"></a>其他示例</h3><p><strong>插槽 prop 允许我们将插槽转换为可复用的模板，这些模板可以基于输入的 prop 渲染出不同的内容。</strong>这在设计封装数据逻辑同时允许父级组件自定义部分布局的可复用组件时是最有用的。</p>
<p>例如，我们要实现一个 <code>&lt;todo-list&gt;</code> 组件，它是一个列表且包含布局和过滤逻辑：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"todo in filteredTodos"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:key</span>=<span class="string">"todo.id"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们可以将每个 todo 作为父级组件的插槽，以此通过父级组件对其进行控制，然后将 <code>todo</code> 作为一个插槽 prop 进行绑定：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"todo in filteredTodos"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-bind:key</span>=<span class="string">"todo.id"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    我们为每个 todo 准备了一个插槽，</span></span><br><span class="line"><span class="comment">    将 `todo` 对象作为一个插槽的 prop 传入。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">"todo"</span> <span class="attr">v-bind:todo</span>=<span class="string">"todo"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 后备内容 --&gt;</span></span><br><span class="line">      &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在当我们使用 <code>&lt;todo-list&gt;</code> 组件的时候，我们可以选择为 todo 定义一个不一样<code>&lt;template&gt;</code>的作为替代方案，并且可以从子组件获取数据：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">todo-list</span> <span class="attr">v-bind:todos</span>=<span class="string">"todos"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:todo</span>=<span class="string">"&#123; todo &#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">"todo.isComplete"</span>&gt;</span>✓<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">todo-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="动态组件-amp-异步组件"><a href="#动态组件-amp-异步组件" class="headerlink" title="动态组件&amp;异步组件"></a>动态组件&amp;异步组件</h2><h3 id="在动态组件上使用keep-alive"><a href="#在动态组件上使用keep-alive" class="headerlink" title="在动态组件上使用keep-alive"></a>在动态组件上使用<code>keep-alive</code></h3><p>前面在一个多标签的界面使用<code>is</code>attribute来切换不同的组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当在这些组件之间切换时，有时候需要保持这些组件的状态，避免重复渲染导致性能问题</p>
<p>通常重建动态组件是非常有用的，但是，有时候更希望那些标签的组件实例能够在第一次被创建的时候缓存起来，为了解决这个问题，可以用<code>&lt;keep-alive&gt;</code>元素将其动态组件包裹起来：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 失活的组件将会被缓存！--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">v-bind:is</span>=<span class="string">"currentTabComponent"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意这个 <code>` 要求被切换到的组件都有自己的名字，不论是通过组件的</code>name` 选项还是局部/全局注册。</p>
<h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>在大型的应用中，可能需要将应用分割成一定粒度的代码块，并且只有在需要的时候才从服务器加载一个模块，为了简化，Vue提供了以工厂函数的方式定义组件，这个工厂函数会异步解析组件定义。Vue只有在这个组件需要渲染的时候才会触发工厂函数，并且会把结果缓存起来供未来重渲染。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 向 `resolve` 回调传递组件定义</span></span><br><span class="line">    resolve(&#123;</span><br><span class="line">      template: <span class="string">'&lt;div&gt;I am async!&lt;/div&gt;'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如你所见，这个工厂函数会收到一个 <code>resolve</code> 回调，这个回调函数会在你从服务器得到组件定义的时候被调用。你也可以调用 <code>reject(reason)</code> 来表示加载失败。这里的 <code>setTimeout</code> 是为了演示用的，如何获取组件取决于你自己。一个推荐的做法是将异步组件和 <a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="noopener">webpack 的 code-splitting 功能</a>一起配合使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'async-webpack-example'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个特殊的 `require` 语法将会告诉 webpack</span></span><br><span class="line">  <span class="comment">// 自动将你的构建代码切割成多个包，这些包</span></span><br><span class="line">  <span class="comment">// 会通过 Ajax 请求加载</span></span><br><span class="line">  <span class="built_in">require</span>([<span class="string">'./my-async-component'</span>], resolve)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>你也可以在工厂函数中返回一个 <code>Promise</code>，所以把 webpack 2 和 ES2015 语法加在一起，我们可以写成这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(</span><br><span class="line">  <span class="string">'async-webpack-example'</span>,</span><br><span class="line">  <span class="comment">// 这个 `import` 函数会返回一个 `Promise` 对象。</span></span><br><span class="line">  () =&gt; <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>当使用<a href="https://cn.vuejs.org/v2/guide/components-registration.html#局部注册" target="_blank" rel="noopener">局部注册</a>的时候，你也可以直接提供一个返回 <code>Promise</code> 的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">'my-component'</span>: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./my-async-component'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ol>
<li><p>处理加载状态</p>
<blockquote>
<p>2.3.0+ 新增</p>
</blockquote>
<p>这里的异步组件工厂函数也可以返回一个如下格式的对象：</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AsyncComponent = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// 需要加载的组件 (应该是一个 `Promise` 对象)</span></span><br><span class="line">  component: <span class="keyword">import</span>(<span class="string">'./MyComponent.vue'</span>),</span><br><span class="line">  <span class="comment">// 异步组件加载时使用的组件</span></span><br><span class="line">  loading: LoadingComponent,</span><br><span class="line">  <span class="comment">// 加载失败时使用的组件</span></span><br><span class="line">  error: ErrorComponent,</span><br><span class="line">  <span class="comment">// 展示加载时组件的延时时间。默认值是 200 (毫秒)</span></span><br><span class="line">  delay: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// 如果提供了超时时间且组件加载也超时了，</span></span><br><span class="line">  <span class="comment">// 则使用加载失败时使用的组件。默认值是：`Infinity`</span></span><br><span class="line">  timeout: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意如果你希望在 <a href="https://github.com/vuejs/vue-router" target="_blank" rel="noopener">Vue Router</a> 的路由组件中使用上述语法的话，你必须使用 Vue Router 2.4.0+ 版本。</p>
</blockquote>
<h2 id="处理边界情况"><a href="#处理边界情况" class="headerlink" title="处理边界情况"></a>处理边界情况</h2><h3 id="访问元素-amp-组件"><a href="#访问元素-amp-组件" class="headerlink" title="访问元素&amp;组件"></a>访问元素&amp;组件</h3><ol>
<li><p>访问根实例</p>
<p>在每个 <code>new Vue</code> 实例的子组件中，其根实例可以通过 <code>$root</code> 属性进行访问。例如，在这个根实例中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue 根实例</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    foo: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    baz: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>所有的子组件都可以将这个实例作为一个全局 store 来访问或使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取根组件的数据</span></span><br><span class="line"><span class="keyword">this</span>.$root.foo</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入根组件的数据</span></span><br><span class="line"><span class="keyword">this</span>.$root.foo = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问根组件的计算属性</span></span><br><span class="line"><span class="keyword">this</span>.$root.bar</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用根组件的方法</span></span><br><span class="line"><span class="keyword">this</span>.$root.baz()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于 demo 或非常小型的有少量组件的应用来说这是很方便的。不过这个模式扩展到中大型应用来说就不然了。因此在绝大多数情况下，我们强烈推荐使用 <a href="https://github.com/vuejs/vuex" target="_blank" rel="noopener">Vuex</a> 来管理应用的状态。</p>
</blockquote>
</li>
<li><p>访问父级组件实例</p>
<p>和 <code>$root</code> 类似，<code>$parent</code> 属性可以用来从一个子组件访问父组件的实例。它提供了一种机会，可以在后期随时触达父级组件，以替代将数据以 prop 的方式传入子组件的方式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">google-map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">google-map-markers</span> <span class="attr">v-bind:places</span>=<span class="string">"iceCreamShops"</span>&gt;</span><span class="tag">&lt;/<span class="name">google-map-markers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">google-map</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个 <code>组件可以定义一个 `map` 属性，所有的子组件都需要访问它。在这种情况下</code> 可能想要通过类似 <code>this.$parent.getMap</code> 的方式访问那个地图，以便为其添加一组标记。你可以在<a href="https://jsfiddle.net/chrisvfritz/ttzutdxh/" target="_blank" rel="noopener">这里</a>查阅这种模式。</p>
<p>请留意，尽管如此，通过这种模式构建出来的那个组件的内部仍然是容易出现问题的。比如，设想一下我们添加一个新的 <code>组件，当</code> 在其内部出现的时候，只会渲染那个区域内的标记：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">google-map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">google-map-region</span> <span class="attr">v-bind:shape</span>=<span class="string">"cityBoundaries"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">google-map-markers</span> <span class="attr">v-bind:places</span>=<span class="string">"iceCreamShops"</span>&gt;</span><span class="tag">&lt;/<span class="name">google-map-markers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">google-map-region</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">google-map</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么在 <code>&lt;google-map-markers&gt;</code> 内部你可能发现自己需要一些类似这样的 hack：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">this</span>.$parent.map || <span class="keyword">this</span>.$parent.$parent.map</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问子组件实例或资源</p>
<p>尽管存在 prop 和事件，有的时候你仍可能需要在 JavaScript 里直接访问一个子组件。为了达到这个目的，你可以通过 <code>ref</code> 这个 attribute 为子组件赋予一个 ID 引用。例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span> <span class="attr">ref</span>=<span class="string">"usernameInput"</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>现在在你已经定义了这个 <code>ref</code> 的组件里，你可以使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$refs.usernameInput</span><br></pre></td></tr></table></figure>
<p>来访问这个 <code>&lt;base-input&gt;</code> 实例，以便不时之需。比如程序化地从一个父级组件聚焦这个输入框。在刚才那个例子中，该 <code>&lt;base-input&gt;</code> 组件也可以使用一个类似的 <code>ref</code> 提供对内部这个指定元素的访问，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">"input"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>甚至可以通过其父级组件定义方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  <span class="comment">// 用来从父级组件聚焦输入框</span></span><br><span class="line">  focus: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$refs.input.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就允许父级组件通过下面的代码聚焦 <code>&lt;base-input&gt;</code> 里的输入框：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$refs.usernameInput.focus()</span><br></pre></td></tr></table></figure>
<p>当 <code>ref</code> 和 <code>v-for</code> 一起使用的时候，你得到的引用将会是一个包含了对应数据源的这些子组件的数组。</p>
<p>注：<code>$refs</code> 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 <code>$refs</code>。</p>
</li>
<li><p>依赖注入</p>
<p>上面的，所有 <code>&lt;google-map&gt;</code> 的后代都需要访问一个 <code>getMap</code> 方法，以便知道要跟哪个地图进行交互。不幸的是，使用 <code>$parent</code> 属性无法很好的扩展到更深层级的嵌套组件上。这也是依赖注入的用武之地，它用到了两个新的实例选项：<code>provide</code> 和 <code>inject</code></p>
<p><code>provide</code> 选项允许我们指定我们想要<strong>提供</strong>给后代组件的数据/方法。在这个例子中，就是 <code>&lt;google-map&gt;</code> 内部的 <code>getMap</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">provide: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getMap: <span class="keyword">this</span>.getMap</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在任何后代组件里，我们都可以使用 <code>inject</code> 选项来接收指定的我们想要添加在这个实例上的属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">inject: [<span class="string">'getMap'</span>]</span><br></pre></td></tr></table></figure>
<p>你可以在<a href="https://jsfiddle.net/chrisvfritz/tdv8dt3s/" target="_blank" rel="noopener">这里</a>看到完整的示例。相比 <code>$parent</code> 来说，这个用法可以让我们在<em>任意</em>后代组件中访问 <code>getMap</code>，而不需要暴露整个 <code>&lt;google-map&gt;</code> 实例。这允许我们更好的持续研发该组件，而不需要担心我们可能会改变/移除一些子组件依赖的东西。同时这些组件之间的接口是始终明确定义的，就和 <code>props</code> 一样。</p>
<p>实际上，你可以把依赖注入看作一部分“大范围有效的 prop”，除了：</p>
<ul>
<li>祖先组件不需要知道哪些后代组件使用它提供的属性</li>
<li>后代组件不需要知道被注入的属性来自哪里</li>
</ul>
</li>
</ol>
<h3 id="程序化的事件侦听器"><a href="#程序化的事件侦听器" class="headerlink" title="程序化的事件侦听器"></a>程序化的事件侦听器</h3><p>现在，你已经知道了 <code>$emit</code> 的用法，它可以被 <code>v-on</code> 侦听，但是 Vue 实例同时在其事件接口中提供了其它的方法。我们可以：</p>
<ul>
<li>通过 <code>$on(eventName, eventHandler)</code> 侦听一个事件</li>
<li>通过 <code>$once(eventName, eventHandler)</code> 一次性侦听一个事件</li>
<li>通过 <code>$off(eventName, eventHandler)</code> 停止侦听一个事件</li>
</ul>
<p>当你需要在一个组件实例上手动侦听事件时，它们是派得上用场的。它们也可以用于代码组织工具。例如，你可能经常看到这种集成一个第三方库的模式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次性将这个日期选择器附加到一个输入框上</span></span><br><span class="line"><span class="comment">// 它会被挂载到 DOM 上。</span></span><br><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Pikaday 是一个第三方日期选择器的库</span></span><br><span class="line">  <span class="keyword">this</span>.picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">    field: <span class="keyword">this</span>.$refs.input,</span><br><span class="line">    format: <span class="string">'YYYY-MM-DD'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 在组件被销毁之前，</span></span><br><span class="line"><span class="comment">// 也销毁这个日期选择器。</span></span><br><span class="line">beforeDestroy: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.picker.destroy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两个潜在的问题：</p>
<ul>
<li>它需要在这个组件实例中保存这个 <code>picker</code>，如果可以的话最好只有生命周期钩子可以访问到它。这并不算严重的问题，但是它可以被视为杂物。</li>
<li>我们的建立代码独立于我们的清理代码，这使得我们比较难于程序化地清理我们建立的所有东西。</li>
</ul>
<p>你应该通过一个程序化的侦听器解决这两个问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">    field: <span class="keyword">this</span>.$refs.input,</span><br><span class="line">    format: <span class="string">'YYYY-MM-DD'</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.$once(<span class="string">'hook:beforeDestroy'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    picker.destroy()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了这个策略，我甚至可以让多个输入框元素同时使用不同的 Pikaday，每个新的实例都程序化地在后期清理它自己：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.attachDatepicker(<span class="string">'startDateInput'</span>)</span><br><span class="line">  <span class="keyword">this</span>.attachDatepicker(<span class="string">'endDateInput'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  attachDatepicker: <span class="function"><span class="keyword">function</span> (<span class="params">refName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> picker = <span class="keyword">new</span> Pikaday(&#123;</span><br><span class="line">      field: <span class="keyword">this</span>.$refs[refName],</span><br><span class="line">      format: <span class="string">'YYYY-MM-DD'</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.$once(<span class="string">'hook:beforeDestroy'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      picker.destroy()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><ol>
<li><p>递归组件</p>
<p>组件是可以在自己的模板中调用自身的，不过只能通过<code>name</code>选项来做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">name: <span class="string">'unique-name-of-my-component'</span></span><br></pre></td></tr></table></figure>
<p>当你使用 <code>Vue.component</code> 全局注册一个组件时，这个全局的 ID 会自动设置为该组件的 <code>name</code> 选项。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'unique-name-of-my-component'</span>, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>稍有不慎，递归组件就可能导致无限循环：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">name: <span class="string">'stack-overflow'</span>,</span><br><span class="line">template: <span class="string">'&lt;div&gt;&lt;stack-overflow&gt;&lt;/stack-overflow&gt;&lt;/div&gt;'</span></span><br></pre></td></tr></table></figure>
<p>类似上述的组件将会导致“max stack size exceeded”错误，所以请确保递归调用是条件性的 (例如使用一个最终会得到 <code>false</code> 的 <code>v-if</code>)。</p>
</li>
<li><p>组件之间的循环引用</p>
<p>假设需要构建一个文件目录树，可能需要一个<code>&lt;tree-folder&gt;</code>组件，模板如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; folder.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tree-folder-contents</span> <span class="attr">:children</span>=<span class="string">"folder.children"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>还有一个<code>&lt;tree-folder-contents&gt;</code>组件，模板是这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"child in children"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tree-folder</span> <span class="attr">v-if</span>=<span class="string">"child.children"</span> <span class="attr">:folder</span>=<span class="string">"child"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span>&#123;&#123; child.name &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当你仔细观察的时候，你会发现这些组件在渲染树中互为对方的后代<em>和</em>祖先——一个悖论！当通过 <code>Vue.component</code> 全局注册组件的时候，这个悖论会被自动解开。如果你是这样做的，那么你可以跳过这里。</p>
<p>为了解释这里发生了什么，我们先把两个组件称为 A 和 B。模块系统发现它需要 A，但是首先 A 依赖 B，但是 B 又依赖 A，但是 A 又依赖 B，如此往复。这变成了一个循环，不知道如何不经过其中一个组件而完全解析出另一个组件。为了解决这个问题，我们需要给模块系统一个点，在那里“A <em>反正</em>是需要 B 的，但是我们不需要先解析 B。”</p>
<p>在我们的例子中，把 <code>组件设为了那个点。我们知道那个产生悖论的子组件是</code> 组件，所以我们会等到生命周期钩子 <code>beforeCreate</code> 时去注册它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeCreate: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$options.components.TreeFolderContents = <span class="built_in">require</span>(<span class="string">'./tree-folder-contents.vue'</span>).default</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，在本地注册组件的时候，你可以使用 webpack 的异步 <code>import</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">components: &#123;</span><br><span class="line">  TreeFolderContents: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./tree-folder-contents.vue'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="模板定义的替代品"><a href="#模板定义的替代品" class="headerlink" title="模板定义的替代品"></a>模板定义的替代品</h3><ol>
<li><p>内联模板</p>
<p>当 <code>inline-template</code> 这个特殊的 attribute 出现在一个子组件上时，这个组件将会使用其里面的内容作为模板，而不是将其作为被分发的内容。这使得模板的撰写工作更加灵活。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">inline-template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>These are compiled as the component's own template.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Not parent's transclusion content.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>内联模板需要定义在 Vue 所属的 DOM 元素内。</p>
<p>不过，<code>inline-template</code> 会让模板的作用域变得更加难以理解。所以作为最佳实践，请在组件内优先选择 <code>template</code> 选项或 <code>.vue</code> 文件里的一个 ` 元素来定义模板。</p>
</li>
<li><p>X-Template</p>
<p>另一个定义模板的方式是在一个 <code>&lt;script&gt;</code> 元素中，并为其带上 <code>text/x-template</code> 的类型，然后通过一个 id 将模板引用过去。例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/x-template"</span> <span class="attr">id</span>=<span class="string">"hello-world-template"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello hello hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'hello-world'</span>, &#123;</span><br><span class="line">  template: <span class="string">'#hello-world-template'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>x-template 需要定义在 Vue 所属的 DOM 元素外。</p>
<p>这些可以用于模板特别大的 demo 或极小型的应用，但是其它情况下请避免使用，因为这会将模板和该组件的其它定义分离开。</p>
</li>
</ol>
<h3 id="控制更新"><a href="#控制更新" class="headerlink" title="控制更新"></a>控制更新</h3><p>Vue的响应式系统，它始终知道如何进行更新。</p>
<p>不过还是有一些边界情况，你想要强制更新，尽管表面上看响应式的数据没有发生改变。也有一些情况是你想阻止不必要的更新。</p>
<ol>
<li><p>强制更新</p>
<p>注：如果你发现你自己需要在 Vue 中做一次强制更新，99.9% 的情况，是你在某个地方做错了事。</p>
<p>你可能还没有留意到<a href="https://cn.vuejs.org/v2/guide/list.html#注意事项" target="_blank" rel="noopener">数组</a>或<a href="https://cn.vuejs.org/v2/guide/list.html#对象变更检测注意事项" target="_blank" rel="noopener">对象</a>的变更检测注意事项，或者你可能依赖了一个未被 Vue 的响应式系统追踪的状态。</p>
<p>然而，如果你已经做到了上述的事项仍然发现在极少数的情况下需要手动强制更新，那么你可以通过 <a href="https://cn.vuejs.org/v2/api/#vm-forceUpdate" target="_blank" rel="noopener"><code>$forceUpdate</code></a> 来做这件事。</p>
</li>
<li><p>通过<code>v-once</code>创建低开销的静态组件</p>
<p>当有这样一个组件，组件内包含了大量静态内容。在这种情况下，可以在根元素上添加<code>v-once</code> attribute确保这些内容只计算一次然后缓存起来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">'terms-of-service'</span>, &#123;</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div v-once&gt;</span></span><br><span class="line"><span class="string">      &lt;h1&gt;Terms of Service&lt;/h1&gt;</span></span><br><span class="line"><span class="string">      ... a lot of static content ...</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)j</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>再说一次，试着不要过度使用这个模式。当你需要渲染大量静态内容时，极少数的情况下它会给你带来便利，除非你非常留意渲染变慢了，不然它完全是没有必要的——再加上它在后期会带来很多困惑。例如，设想另一个开发者并不熟悉 <code>v-once</code> 或漏看了它在模板中，他们可能会花很多个小时去找出模板为什么无法正确更新。</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>专利申请书书写</title>
    <url>/2020/02/02/%E4%B8%93%E5%88%A9%E7%94%B3%E8%AF%B7%E4%B9%A6%E4%B9%A6%E5%86%99/</url>
    <content><![CDATA[<h1 id="专利申请书书"><a href="#专利申请书书" class="headerlink" title="专利申请书书"></a>专利申请书书</h1><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>主要分为三个版块</p>
<ol>
<li>说明书摘要（必要时附摘要附图）</li>
<li>权利要求书</li>
<li>说明书（技术领域、背景技术、发明内容、附图说明、具体实施方式、附图）。</li>
</ol>
<h2 id="说明书摘要-abstract"><a href="#说明书摘要-abstract" class="headerlink" title="说明书摘要 abstract"></a>说明书摘要 abstract</h2><p>对整个发明做系统描述，介绍发明的特点和创新点。必要时请附上图片，以便说明和理解</p>
<h2 id="权利要求书"><a href="#权利要求书" class="headerlink" title="权利要求书"></a>权利要求书</h2><blockquote>
<p>专利法第二十六条第四款、专利法实施细则第二十条和第二十一条对权利要求书的撰写要求作了明确的规定，审查指南又对此作了更具体的规定，现分为实质性要求和形式要求两部分来加以说明。</p>
</blockquote>
<ol>
<li>实质性要求</li>
</ol>
<p>　　按照专利法及其实施细则的规定，权利要求书撰写的实质性要求为：权利要求书以说明书为依据；清楚、简明地表述请求保护的范围。</p>
<ol>
<li>形式要求<ul>
<li>权利要求中包括几项权利要求的，应当用阿拉伯数字顺序编号；</li>
<li>若有几项独立权利要求，各自的从属权利要求应当尽量紧靠其所引用的权利要求；</li>
<li>每一项权利要求只允许在其结尾使用句号，以强调其含义是不可分割的整体；</li>
<li>权利要求中使用的科技术语应当与说明书中使用的一致；</li>
<li>权利要求中可以有化学式、化学反应式或者数学式，但不得有插图；</li>
<li>除非绝对必要时，权利要求中不得使用”如说明书……部分所述”或者”如图……所示”等类似用语；</li>
<li>权利要求中通常不允许使用表格，除非使用表格能够更清楚地说明发明或实用新型要求保护的客体；</li>
<li>权利要求中的技术特征可以引用说明书附图中相应的附图标记，但必须加括号，且附图标记不得解释为对权利要求保护范围的限制；</li>
<li>除附图标记或者其它必要情形必须使用括号外，权利要求中应当尽量避免使用括号；</li>
<li>权利要求中采用并列选择时，其含义应当是清楚的；</li>
<li>一般情形下，权利要求不得引用人名、地名、商品名或者商标名称</li>
</ul>
</li>
</ol>
<h2 id="说明书"><a href="#说明书" class="headerlink" title="说明书"></a>说明书</h2><p>技术领域、背景技术、发明内容、附图说明、具体实施方式、附图</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://blog.csdn.net/u010440456/article/details/87801236" target="_blank" rel="noopener">https://blog.csdn.net/u010440456/article/details/87801236</a></li>
</ol>
]]></content>
      <categories>
        <category>技能</category>
      </categories>
  </entry>
  <entry>
    <title>Python教程</title>
    <url>/2019/06/29/python-advanced-tutorial/</url>
    <content><![CDATA[<h1 id="Python-基础"><a href="#Python-基础" class="headerlink" title="Python 基础"></a>Python 基础</h1><h2 id="面向对象高级"><a href="#面向对象高级" class="headerlink" title="面向对象高级"></a>面向对象高级</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 约束当前类的属性</span></span><br><span class="line">    __slots__ = (<span class="string">'_name'</span>,<span class="string">'_age'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @name.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self._name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self,age)</span>:</span></span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._age &lt; <span class="number">16</span>:</span><br><span class="line">            print(<span class="string">f'<span class="subst">&#123;self._name&#125;</span>正在玩飞行棋.'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">f'<span class="subst">&#123;self._name&#125;</span>正在玩斗地主.'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 静态方法</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_vaild</span><span class="params">(self,age)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> age &gt;= <span class="number">18</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 类方法：生成当前类对象，类方法第一个参数约定为cls。</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls(<span class="string">'Demo'</span>,<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age,grade)</span>:</span></span><br><span class="line">        super().__init__(name,age)</span><br><span class="line">        self._grade = grade</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grade</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._grade</span><br><span class="line"></span><br><span class="line"><span class="meta">    @grade.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grade</span><span class="params">(self,grade)</span>:</span></span><br><span class="line">        self._grade = grade</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">study</span><span class="params">(self,course)</span>:</span></span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;self._grade&#125;</span>的<span class="subst">&#123;self._name&#125;</span>正在学习<span class="subst">&#123;course&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">p = Person.create()</span><br><span class="line">p.play()</span><br><span class="line">stu = Student(<span class="string">'WinterGu'</span>,<span class="number">24</span>,<span class="number">2015</span>)</span><br><span class="line">stu.study(<span class="string">'概率论'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta,abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,nickname)</span>:</span></span><br><span class="line">        self._nickname = nickname</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 抽象方法</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_voice</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""发出声音"""</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Pet)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_voice</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;self._nickname&#125;</span>: 汪汪汪...'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Pet)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_voice</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;self._nickname&#125;</span>: 喵喵喵...'</span>)</span><br><span class="line"></span><br><span class="line">pets = [Dog(<span class="string">'旺财'</span>),Dog(<span class="string">'小黑'</span>),Cat(<span class="string">'Kitty'</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> pet <span class="keyword">in</span> pets:</span><br><span class="line">    pet.make_voice()</span><br></pre></td></tr></table></figure>
<h2 id="GUI开发"><a href="#GUI开发" class="headerlink" title="GUI开发"></a>GUI开发</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter</span><br><span class="line"><span class="keyword">import</span> tkinter.messagebox</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change_label_text</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> flag</span><br><span class="line">        flag = <span class="keyword">not</span> flag</span><br><span class="line">        color,msg = (<span class="string">'red'</span>,<span class="string">'Hello,World!'</span>) <span class="keyword">if</span> flag <span class="keyword">else</span> (<span class="string">'blue'</span>,<span class="string">'Goodbye,World!'</span>)</span><br><span class="line">        label.config(text=msg,fg=color)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">confirm_to_quit</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">if</span> tkinter.messagebox.askokcancel(<span class="string">'温馨提示'</span>, <span class="string">'确定要退出吗?'</span>):</span><br><span class="line">            top.quit()</span><br><span class="line"></span><br><span class="line">    top = tkinter.Tk()</span><br><span class="line">    top.geometry(<span class="string">'240x160'</span>)</span><br><span class="line">    top.title(<span class="string">'小游戏'</span>)</span><br><span class="line">    label = tkinter.Label(top, text=<span class="string">'Hello, world!'</span>, font=<span class="string">'Arial -32'</span>, fg=<span class="string">'red'</span>)</span><br><span class="line">    label.pack(expand=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 创建一个装按钮的容器</span></span><br><span class="line">    panel = tkinter.Frame(top)</span><br><span class="line">    <span class="comment"># 创建按钮对象 指定添加到哪个容器中 通过command参数绑定事件回调函数</span></span><br><span class="line">    button1 = tkinter.Button(panel, text=<span class="string">'修改'</span>, command=change_label_text)</span><br><span class="line">    button1.pack(side=<span class="string">'left'</span>)</span><br><span class="line">    button2 = tkinter.Button(panel, text=<span class="string">'退出'</span>, command=confirm_to_quit)</span><br><span class="line">    button2.pack(side=<span class="string">'right'</span>)</span><br><span class="line">    panel.pack(side=<span class="string">'bottom'</span>)</span><br><span class="line">    <span class="comment"># 开启主事件循环</span></span><br><span class="line">    tkinter.mainloop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><ol>
<li>排序</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(origin_items,comp=lambda x,y: x&lt;y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    选择排序</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    items = origin_items[:]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(items)<span class="number">-1</span>):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,len(items)):</span><br><span class="line">            <span class="keyword">if</span> comp(items[j],items[min_index]):</span><br><span class="line">                min_index = j</span><br><span class="line">        items[i],items[min_index] = items[min_index],items[i]</span><br><span class="line">    <span class="keyword">return</span> items</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(origin_items,comp=lambda x,y: x&lt;y)</span>:</span></span><br><span class="line">    items = origin_items[:]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(items)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(items)-i<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> comp(items[j+<span class="number">1</span>],items[j]):</span><br><span class="line">                items[j],items[j+<span class="number">1</span>] = items[j+<span class="number">1</span>],items[j]</span><br><span class="line">    <span class="keyword">return</span> items</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(items,comp=lambda x,y:x&lt;y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    归并排序（分治法）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(items) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> items[:]</span><br><span class="line">    mid = len(items)//<span class="number">2</span></span><br><span class="line">    left = merge_sort(items[:mid],comp)</span><br><span class="line">    right = merge_sort(items[mid:],comp)</span><br><span class="line">    <span class="keyword">return</span> merge(left,right,comp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(item1,item2,comp)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    合并（将两个有序的列表合并成一个）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    items = []</span><br><span class="line">    index1,index2 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> index1 &lt; len(item1) <span class="keyword">and</span> index2 &lt; len(item2):</span><br><span class="line">        <span class="keyword">if</span> comp(item1[index1],item2[index2]):</span><br><span class="line">            items.append(item1[index1])</span><br><span class="line">            index1 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            items.append(item2[index2])</span><br><span class="line">            index2 += <span class="number">1</span></span><br><span class="line">    items.extend(item1[index1:])</span><br><span class="line">    items.extend(item2[index2:])</span><br><span class="line">    <span class="keyword">return</span> items</span><br><span class="line"></span><br><span class="line">o_items = list(range(<span class="number">10</span>,<span class="number">1</span>,<span class="number">-1</span>))</span><br><span class="line">print(<span class="string">f'Origin list:<span class="subst">&#123;o_items&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'list after select_sort:<span class="subst">&#123;select_sort(o_items)&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'list after bubble_sort:<span class="subst">&#123;bubble_sort(o_items)&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'list after merge_sort:<span class="subst">&#123;merge_sort(o_items)&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>查找</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">seq_search</span><span class="params">(items,key)</span>:</span></span><br><span class="line">    <span class="string">"""顺序查找"""</span></span><br><span class="line">    <span class="keyword">for</span> index,item <span class="keyword">in</span> enumerate(items):</span><br><span class="line">        <span class="keyword">if</span> item == key:</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bin_search</span><span class="params">(items,key)</span>:</span></span><br><span class="line">    start,end = <span class="number">0</span>,len(items)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end:</span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> key &gt; items[mid]:</span><br><span class="line">            start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> key &lt; items[mid]:</span><br><span class="line">            end = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<ol>
<li>生成式语法和嵌套列表</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prices = &#123;</span><br><span class="line">    <span class="string">'AAPL'</span>: <span class="number">191.88</span>,</span><br><span class="line">    <span class="string">'GOOG'</span>: <span class="number">1186.96</span>,</span><br><span class="line">    <span class="string">'IBM'</span>: <span class="number">149.24</span>,</span><br><span class="line">    <span class="string">'ORCL'</span>: <span class="number">48.44</span>,</span><br><span class="line">    <span class="string">'ACN'</span>: <span class="number">166.89</span>,</span><br><span class="line">    <span class="string">'FB'</span>: <span class="number">208.09</span>,</span><br><span class="line">    <span class="string">'SYMC'</span>: <span class="number">21.29</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 用股票价格大于100元的股票构造一个新的字典</span></span><br><span class="line">prices2 = &#123;key: value <span class="keyword">for</span> key, value <span class="keyword">in</span> prices.items() <span class="keyword">if</span> value &gt; <span class="number">100</span>&#125;</span><br><span class="line">print(prices2)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">'关羽'</span>, <span class="string">'张飞'</span>, <span class="string">'赵云'</span>, <span class="string">'马超'</span>, <span class="string">'黄忠'</span>]</span><br><span class="line">courses = [<span class="string">'语文'</span>, <span class="string">'数学'</span>, <span class="string">'英语'</span>]</span><br><span class="line"><span class="comment"># 录入五个学生三门课程的成绩</span></span><br><span class="line"><span class="comment"># scores = [[None] * len(courses)] * len(names)</span></span><br><span class="line">scores = [[<span class="literal">None</span>] * len(courses) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(names))]</span><br><span class="line"><span class="keyword">for</span> row, name <span class="keyword">in</span> enumerate(names):</span><br><span class="line">    <span class="keyword">for</span> col, course <span class="keyword">in</span> enumerate(courses):</span><br><span class="line">        scores[row][col] = float(input(<span class="string">f'请输入<span class="subst">&#123;name&#125;</span>的<span class="subst">&#123;course&#125;</span>成绩: '</span>))</span><br><span class="line">        print(scores)</span><br></pre></td></tr></table></figure>
<ol>
<li>heapq,itertools的用法</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">从列表中找出最大的或最小的N个元素</span></span><br><span class="line"><span class="string">堆结构(大根堆/小根堆)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">34</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">99</span>, <span class="number">87</span>, <span class="number">63</span>, <span class="number">58</span>, <span class="number">78</span>, <span class="number">88</span>, <span class="number">92</span>]</span><br><span class="line">list2 = [</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'IBM'</span>, <span class="string">'shares'</span>: <span class="number">100</span>, <span class="string">'price'</span>: <span class="number">91.1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'AAPL'</span>, <span class="string">'shares'</span>: <span class="number">50</span>, <span class="string">'price'</span>: <span class="number">543.22</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'FB'</span>, <span class="string">'shares'</span>: <span class="number">200</span>, <span class="string">'price'</span>: <span class="number">21.09</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'HPQ'</span>, <span class="string">'shares'</span>: <span class="number">35</span>, <span class="string">'price'</span>: <span class="number">31.75</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'YHOO'</span>, <span class="string">'shares'</span>: <span class="number">45</span>, <span class="string">'price'</span>: <span class="number">16.35</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'ACME'</span>, <span class="string">'shares'</span>: <span class="number">75</span>, <span class="string">'price'</span>: <span class="number">115.65</span>&#125;</span><br><span class="line">]</span><br><span class="line">print(heapq.nlargest(<span class="number">3</span>, list1))</span><br><span class="line">print(heapq.nsmallest(<span class="number">3</span>, list1))</span><br><span class="line">print(heapq.nlargest(<span class="number">2</span>, list2, key=<span class="keyword">lambda</span> x: x[<span class="string">'price'</span>]))</span><br><span class="line">print(heapq.nlargest(<span class="number">2</span>, list2, key=<span class="keyword">lambda</span> x: x[<span class="string">'shares'</span>]))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">迭代工具 - 排列 / 组合 / 笛卡尔积</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.permutations(<span class="string">'ABCD'</span>):</span><br><span class="line">    print(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.combinations(<span class="string">'ABCDE'</span>, <span class="number">3</span>):</span><br><span class="line">    print(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.product(<span class="string">'ABCD'</span>, <span class="string">'123'</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<ol>
<li>collections 模块 下的工具</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">words = [</span><br><span class="line">    <span class="string">'look'</span>, <span class="string">'into'</span>, <span class="string">'my'</span>, <span class="string">'eyes'</span>, <span class="string">'look'</span>, <span class="string">'into'</span>, <span class="string">'my'</span>, <span class="string">'eyes'</span>,</span><br><span class="line">    <span class="string">'the'</span>, <span class="string">'eyes'</span>, <span class="string">'the'</span>, <span class="string">'eyes'</span>, <span class="string">'the'</span>, <span class="string">'eyes'</span>, <span class="string">'not'</span>, <span class="string">'around'</span>,</span><br><span class="line">    <span class="string">'the'</span>, <span class="string">'eyes'</span>, <span class="string">"don't"</span>, <span class="string">'look'</span>, <span class="string">'around'</span>, <span class="string">'the'</span>, <span class="string">'eyes'</span>,</span><br><span class="line">    <span class="string">'look'</span>, <span class="string">'into'</span>, <span class="string">'my'</span>, <span class="string">'eyes'</span>, <span class="string">"you're"</span>, <span class="string">'under'</span></span><br><span class="line">]</span><br><span class="line">counter = Counter(words)</span><br><span class="line">print(counter.most_common(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<ol>
<li>常用算法<ul>
<li>穷举法 - 又称为暴力破解法，对所有的可能性进行验证，直到找到正确答案。</li>
<li>贪婪法 - 在对问题求解时，总是做出在当前看来是最好的选择，不追求最优解，快速找到满意解。</li>
<li>分治法 - 把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题，直到可以直接求解的程度，最后将子问题的解进行合并得到原问题的解。</li>
<li>回溯法 - 回溯法又称为试探法，按选优条件向前搜索，当搜索到某一步发现原先选择并不优或达不到目标时，就退回一步重新选择。</li>
<li>动态规划 - 基本思想也是将待求解问题分解成若干个子问题，先求解并保存这些子问题的解，避免产生大量的重复运算。</li>
</ul>
</li>
</ol>
<ul>
<li>穷举法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 公鸡5元一只 母鸡3元一只 小鸡1元三只</span></span><br><span class="line"><span class="comment"># 用100元买100只鸡 问公鸡/母鸡/小鸡各多少只</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">33</span>):</span><br><span class="line">        z = <span class="number">100</span> - x - y</span><br><span class="line">        <span class="keyword">if</span> <span class="number">5</span>*x + <span class="number">3</span>*y + z // <span class="number">3</span> == <span class="number">100</span> <span class="keyword">and</span> z % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">            print(x,y,z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># A、B、C、D、E五人在某天夜里合伙捕鱼 最后疲惫不堪各自睡觉</span></span><br><span class="line"><span class="comment"># 第二天A第一个醒来 他将鱼分为5份 扔掉多余的1条 拿走自己的一份</span></span><br><span class="line"><span class="comment"># B第二个醒来 也将鱼分为5份 扔掉多余的1条 拿走自己的一份</span></span><br><span class="line"><span class="comment"># 然后C、D、E依次醒来也按同样的方式分鱼 问他们至少捕了多少条鱼</span></span><br><span class="line"></span><br><span class="line">fish = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    total = fish</span><br><span class="line">    enough = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">if</span> (total - <span class="number">1</span>) % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">            total = (total - <span class="number">1</span>) // <span class="number">5</span> * <span class="number">4</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            enough = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> enough :</span><br><span class="line">        print(fish)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    fish += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>贪婪法例子：假设小偷有一个背包，最多能装20公斤赃物，他闯入一户人家，发现如下表所示的物品。很显然，他不能把所有物品都装进背包，所以必须确定拿走哪些物品，留下哪些物品。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">价格（美元）</th>
<th style="text-align:center">重量（kg）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">电脑</td>
<td style="text-align:center">200</td>
<td style="text-align:center">20</td>
</tr>
<tr>
<td style="text-align:center">收音机</td>
<td style="text-align:center">20</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">钟</td>
<td style="text-align:center">175</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">花瓶</td>
<td style="text-align:center">50</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">书</td>
<td style="text-align:center">10</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">油画</td>
<td style="text-align:center">90</td>
<td style="text-align:center">9</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">贪婪法：在对问题求解时，总是做出在当前看来是最好的选择，不追求最优解，快速找到满意解。</span></span><br><span class="line"><span class="string">输入：</span></span><br><span class="line"><span class="string">20 6</span></span><br><span class="line"><span class="string">电脑 200 20</span></span><br><span class="line"><span class="string">收音机 20 4</span></span><br><span class="line"><span class="string">钟 175 10</span></span><br><span class="line"><span class="string">花瓶 50 2</span></span><br><span class="line"><span class="string">书 10 1</span></span><br><span class="line"><span class="string">油画 90 9</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thing</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,price,weight)</span></span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.price = price</span><br><span class="line">        self.weight= weight</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">value</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""价格重量比"""</span></span><br><span class="line">        <span class="keyword">return</span> self.weight / self.price</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_thing</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""输入物品信息"""</span></span><br><span class="line">    name_str, price_str, weight_str = input().split()</span><br><span class="line">    <span class="keyword">return</span> name_str, int(price_str), int(weight_str)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    max_weight,num_of_thing = map(int,input().split())</span><br><span class="line">    all_things = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(num_of_thing)</span><br><span class="line">        all_things.append(Thing(*input_thing()))</span><br><span class="line"></span><br><span class="line">    all_things.sort(key=<span class="keyword">lambda</span> x: x.value,reverse=<span class="literal">True</span>)</span><br><span class="line">    total_weight = <span class="number">0</span></span><br><span class="line">    total_price = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> all_things:</span><br><span class="line">        <span class="keyword">if</span> item.weight + total_weight &lt;= max_weight:</span><br><span class="line">            print(<span class="string">f'小偷偷走了<span class="subst">&#123;item.name&#125;</span>'</span>)</span><br><span class="line">            total_weight += item.weight</span><br><span class="line">            total_price += item.price</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    print(<span class="string">f'总价值：<span class="subst">&#123;total_price&#125;</span>美元'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<ul>
<li>分治法例子：快速排序。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">快速排序 - 选择枢轴对元素进行划分，左边都比枢轴小右边都比枢轴大</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(origin_items,comp=lambda x,y : x&lt;=y)</span>:</span></span><br><span class="line">    items = origin_items[:]</span><br><span class="line">    _quick_sort(items,<span class="number">0</span>,len(items)<span class="number">-1</span>,comp)</span><br><span class="line">    <span class="keyword">return</span> items</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_quick_sort</span><span class="params">(items,start,end,comp)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> start &lt; end:</span><br><span class="line">        pos = _partition(items, start, end, comp)</span><br><span class="line">        _quick_sort(items, start, pos - <span class="number">1</span>, comp)</span><br><span class="line">        _quick_sort(items, pos + <span class="number">1</span>, end, comp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_partition</span><span class="params">(items, start, end, comp)</span>:</span></span><br><span class="line">    <span class="string">"""划分"""</span></span><br><span class="line">    pivot = items[end]</span><br><span class="line">    i = start <span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(start,end):</span><br><span class="line">        <span class="keyword">if</span> comp(items[j],pivot):</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            items[i], items[j] = items[j], items[i]</span><br><span class="line">    items[i + <span class="number">1</span>], items[end] = items[end], items[i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>回溯法例子：骑士巡逻。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">递归回溯法：叫称为试探法，按选优条件向前搜索，当搜索到某一步，发现原先选择并不优或达不到目标时，就退回一步重新选择，比较经典的问题包括骑士巡逻、八皇后和迷宫寻路等。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">SIZE = <span class="number">5</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_board</span><span class="params">(board)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> board:</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> row:</span><br><span class="line">            print(str(col).center(<span class="number">4</span>), end=<span class="string">''</span>)</span><br><span class="line">        print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">patrol</span><span class="params">(board, row, col, step=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> row &gt;= <span class="number">0</span> <span class="keyword">and</span> row &lt; SIZE <span class="keyword">and</span> \</span><br><span class="line">        col &gt;= <span class="number">0</span> <span class="keyword">and</span> col &lt; SIZE <span class="keyword">and</span> \</span><br><span class="line">        board[row][col] == <span class="number">0</span>:</span><br><span class="line">        board[row][col] = step</span><br><span class="line">        <span class="keyword">if</span> step == SIZE * SIZE:</span><br><span class="line">            <span class="keyword">global</span> total</span><br><span class="line">            total += <span class="number">1</span></span><br><span class="line">            print(<span class="string">f'第<span class="subst">&#123;total&#125;</span>种走法: '</span>)</span><br><span class="line">            print_board(board)</span><br><span class="line">        patrol(board, row - <span class="number">2</span>, col - <span class="number">1</span>, step + <span class="number">1</span>)</span><br><span class="line">        patrol(board, row - <span class="number">1</span>, col - <span class="number">2</span>, step + <span class="number">1</span>)</span><br><span class="line">        patrol(board, row + <span class="number">1</span>, col - <span class="number">2</span>, step + <span class="number">1</span>)</span><br><span class="line">        patrol(board, row + <span class="number">2</span>, col - <span class="number">1</span>, step + <span class="number">1</span>)</span><br><span class="line">        patrol(board, row + <span class="number">2</span>, col + <span class="number">1</span>, step + <span class="number">1</span>)</span><br><span class="line">        patrol(board, row + <span class="number">1</span>, col + <span class="number">2</span>, step + <span class="number">1</span>)</span><br><span class="line">        patrol(board, row - <span class="number">1</span>, col + <span class="number">2</span>, step + <span class="number">1</span>)</span><br><span class="line">        patrol(board, row - <span class="number">2</span>, col + <span class="number">1</span>, step + <span class="number">1</span>)</span><br><span class="line">        board[row][col] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    board = [[<span class="number">0</span>] * SIZE <span class="keyword">for</span> _ <span class="keyword">in</span> range(SIZE)]</span><br><span class="line">    patrol(board, SIZE - <span class="number">1</span>, SIZE - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<ul>
<li>动态规划例子1：斐波拉切数列。（不使用动态规划将会是几何级数复杂度）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">动态规划 - 适用于有重叠子问题和最优子结构性质的问题</span></span><br><span class="line"><span class="string">使用动态规划方法所耗时间往往远少于朴素解法(用空间换取时间)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(num, temp=&#123;&#125;)</span>:</span></span><br><span class="line">    <span class="string">"""用递归计算Fibonacci数"""</span></span><br><span class="line">    <span class="keyword">if</span> num <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> temp[num]</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        temp[num] = fib(num - <span class="number">1</span>) + fib(num - <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> temp[num]</span><br></pre></td></tr></table></figure>
<p>动态规划例子2：子列表元素之和的最大值。（使用动态规划可以避免二重循环）</p>
<blockquote>
<p>说明：子列表指的是列表中索引（下标）连续的元素构成的列表；列表中的元素是int类型，可能包含正整数、0、负整数；程序输入列表中的元素，输出子列表元素求和的最大值，例如：</p>
<p>输入：1 -2 3 5 -3 2</p>
<p>输出：8</p>
<p>输入：0 -2 3 5 -1 2</p>
<p>输出：9</p>
<p>输入：-9 -2 -3 -5 -3</p>
<p>输出：-2</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    items = list(map(int, input().split()))</span><br><span class="line">    size = len(items)</span><br><span class="line">    overall, partial = &#123;&#125;, &#123;&#125;</span><br><span class="line">    overall[size - <span class="number">1</span>] = partial[size - <span class="number">1</span>] = items[size - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(size - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        partial[i] = max(items[i], partial[i + <span class="number">1</span>] + items[i])</span><br><span class="line">        overall[i] = max(partial[i], overall[i + <span class="number">1</span>])</span><br><span class="line">    print(overall[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="函数的使用"><a href="#函数的使用" class="headerlink" title="函数的使用"></a>函数的使用</h2><pre><code>- 函数
    - 函数可以赋值给变量
    - 函数可以作为函数的参数
    - 函数可以作为函数的返回值

- 高阶函数的用法（filter、map以及它们的替代品）
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">item = map(<span class="keyword">lambda</span> x:x**<span class="number">2</span>,filter(<span class="keyword">lambda</span> x : x%<span class="number">2</span>,range(<span class="number">10</span>)))</span><br><span class="line">item2 = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>位置参数、可变参数、关键字参数、命名关键字参数</p>
</li>
<li><p>参数的元信息（代码可读性问题）</p>
</li>
<li><p>匿名函数和内联函数的用法（lambda函数）</p>
</li>
<li><p>闭包和作用域问题</p>
<ul>
<li><p>Python搜索变量的LEGB顺序（Local —&gt; Embedded —&gt; Global —&gt; Built-in）</p>
</li>
<li><p>global和nonlocal关键字的作用</p>
<p>  global：声明或定义全局变量（要么直接使用现有的全局作用域的变量，要么定义一个变量放到全局作用域）。</p>
<p>  nonlocal：声明使用嵌套作用域的变量（嵌套作用域必须存在该变量，否则报错）。</p>
</li>
</ul>
</li>
<li><p>装饰器函数（使用装饰器和取消装饰器）</p>
<p>  例子：输出函数执行时间的装饰器。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time,sleep</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record_time</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""自定义装饰函数的装饰器"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start = time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">f'<span class="subst">&#123;func.__name__&#125;</span>: <span class="subst">&#123;time() - start&#125;</span>秒'</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@record_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">()</span>:</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">download()</span><br></pre></td></tr></table></figure>
<p>如果装饰器不希望跟<code>print</code>函数耦合，可以编写带参数的装饰器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">record</span><span class="params">(output)</span>:</span></span><br><span class="line">    <span class="string">"""自定义带参数的装饰器"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            start = time()</span><br><span class="line">            result = func(*args, **kwargs)</span><br><span class="line">            output(func.__name__, time() - start)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"><span class="meta">@record(print)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">()</span>:</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">download()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Record</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""自定义装饰器类(通过__call__魔术方法使得对象可以当成函数调用)"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, output)</span>:</span></span><br><span class="line">        self.output = output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            start = time()</span><br><span class="line">            result = func(*args, **kwargs)</span><br><span class="line">            self.output(func.__name__, time() - start)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@Record(print)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">()</span>:</span></span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">download()</span><br></pre></td></tr></table></figure>
<p>例子：用装饰器来实现单例模式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="string">"""装饰类的修饰器"""</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    <span class="comment"># 确保线程安全</span></span><br><span class="line">    lock = Lock()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @wraps(cls)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            <span class="keyword">with</span> lock:</span><br><span class="line">                <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">                    instances[cls] = cls(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">President</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""总统(单例类)"""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = President()</span><br><span class="line">b = President()</span><br><span class="line"></span><br><span class="line">print(id(a))</span><br><span class="line">print(id(b))</span><br></pre></td></tr></table></figure>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ol>
<li><p>三大特性：封装、继承、多态</p>
<p> 例子：工资结算系统</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">月薪结算系统 - 部门经理每月15000 程序员每小时200 销售员1800底薪加销售额5%提成</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta,abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emplyee</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line">    <span class="string">"""员工实体类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_salary</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""工资结算方法(抽象方法)"""</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Emplyee)</span>:</span></span><br><span class="line">    <span class="string">"""部门经理"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_salary</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">15000.00</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span><span class="params">(Emplyee)</span>:</span></span><br><span class="line">    <span class="string">"""程序员"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,working_hours)</span>:</span></span><br><span class="line">        self.working_hours = working_hours</span><br><span class="line">        super().__init__(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_salary</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">200.00</span> * self.working_hours</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salesman</span><span class="params">(Emplyee)</span>:</span></span><br><span class="line">    <span class="string">"""销售员"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,sales = <span class="number">0.0</span>)</span>:</span></span><br><span class="line">        self.sales = sales</span><br><span class="line">        super().__init__(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_salary</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1800</span> + self.sales * <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmployeeFactory</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""创建员工的工厂（工厂模式 - 通过工厂实现对象使用者和对象之间的解耦合）"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(emp_type, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""创建员工"""</span></span><br><span class="line">        emp_type = emp_type.upper()</span><br><span class="line">        emp = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> emp_type == <span class="string">'M'</span>:</span><br><span class="line">            emp = Manager(*args, **kwargs)</span><br><span class="line">        <span class="keyword">elif</span> emp_type == <span class="string">'P'</span>:</span><br><span class="line">            emp = Programmer(*args, **kwargs)</span><br><span class="line">        <span class="keyword">elif</span> emp_type == <span class="string">'S'</span>:</span><br><span class="line">            emp = Salesman(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> emp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""主函数"""</span></span><br><span class="line">    emps = [</span><br><span class="line">        EmployeeFactory.create(<span class="string">'M'</span>, <span class="string">'曹操'</span>),</span><br><span class="line">        EmployeeFactory.create(<span class="string">'P'</span>, <span class="string">'荀彧'</span>, <span class="number">120</span>),</span><br><span class="line">        EmployeeFactory.create(<span class="string">'P'</span>, <span class="string">'郭嘉'</span>, <span class="number">85</span>),</span><br><span class="line">        EmployeeFactory.create(<span class="string">'S'</span>, <span class="string">'典韦'</span>, <span class="number">123000</span>),</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> emp <span class="keyword">in</span> emps:</span><br><span class="line">        print(<span class="string">'%s: %.2f元'</span> % (emp.name, emp.get_salary()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<ol>
<li>类与类之间的关系</li>
</ol>
<ul>
<li>is-a关系：继承</li>
<li>has-a关系：关联 / 聚合 / 合成</li>
<li>use-a关系：依赖</li>
</ul>
<p>例子：扑克游戏。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">经验：符号常量总是优于字面常量，枚举类型是定义符号常量的最佳选择</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="meta">@unique</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Suite</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    <span class="string">"""花色"""</span></span><br><span class="line"></span><br><span class="line">    SPADE, HEART, CLUB, DIAMOND = range(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.value &lt; other.value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Card</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""牌"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, suite, face)</span>:</span></span><br><span class="line">        <span class="string">"""初始化方法"""</span></span><br><span class="line">        self.suite = suite</span><br><span class="line">        self.face = face</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""显示牌面"""</span></span><br><span class="line">        suites = [<span class="string">'♠️'</span>, <span class="string">'♥️'</span>, <span class="string">'♣️'</span>, <span class="string">'♦️'</span>]</span><br><span class="line">        faces = [<span class="string">''</span>, <span class="string">'A'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'10'</span>, <span class="string">'J'</span>, <span class="string">'Q'</span>, <span class="string">'K'</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'<span class="subst">&#123;suites[self.suite.value]&#125;</span> <span class="subst">&#123;faces[self.face]&#125;</span>'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.show()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poker</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""扑克"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line">        self.cards = [Card(suite, face) <span class="keyword">for</span> suite <span class="keyword">in</span> Suite <span class="keyword">for</span> face <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">14</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shuffle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""洗牌（随机乱序）"""</span></span><br><span class="line">        random.shuffle(self.cards)</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""发牌"""</span></span><br><span class="line">        card = self.cards[self.index]</span><br><span class="line">        self.index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> card</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_more</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.index &lt; len(self.cards)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""玩家"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.cards = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_one</span><span class="params">(self, card)</span>:</span></span><br><span class="line">        <span class="string">"""摸一张牌"""</span></span><br><span class="line">        self.cards.append(card)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sort</span><span class="params">(self, comp=lambda card: <span class="params">(card.suite, card.face)</span>)</span>:</span></span><br><span class="line">        <span class="string">"""整理手上的牌"""</span></span><br><span class="line">        self.cards.sort(key=comp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""主函数"""</span></span><br><span class="line">    poker = Poker()</span><br><span class="line">    poker.shuffle()</span><br><span class="line">    players = [Player(<span class="string">'东邪'</span>), Player(<span class="string">'西毒'</span>), Player(<span class="string">'南帝'</span>), Player(<span class="string">'北丐'</span>)]</span><br><span class="line">    <span class="keyword">while</span> poker.has_more:</span><br><span class="line">        <span class="keyword">for</span> player <span class="keyword">in</span> players:</span><br><span class="line">            player.get_one(poker.deal())</span><br><span class="line">        <span class="keyword">for</span> player <span class="keyword">in</span> players:</span><br><span class="line">            player.sort()</span><br><span class="line">            print(player.name, end=<span class="string">': '</span>)</span><br><span class="line">            print(player.cards)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>extra</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trangles</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用生成式生成杨辉三角形</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    p = [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> p</span><br><span class="line">        p = [<span class="number">1</span>] + [p[x] + p[x+<span class="number">1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> range(len(p)<span class="number">-1</span>)] + [<span class="number">1</span>]</span><br><span class="line">f = trangles()</span><br><span class="line">print(next(f))</span><br><span class="line">print(next(f))</span><br><span class="line">print(next(f))</span><br><span class="line">print(next(f))</span><br></pre></td></tr></table></figure>
<ol>
<li><p>对象的复制（深复制/深拷贝/深度克隆和浅复制/浅拷贝/影子克隆）</p>
</li>
<li><p>垃圾回收、循环引用和弱引用</p>
</li>
</ol>
<p>Python使用了自动化内存管理，这种管理机制以引用计数为基础，同时也引入了标记-清除和分代收集两种机制为辅的策略。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struct_object &#123;</span><br><span class="line">    <span class="comment">/* 引用计数 */</span></span><br><span class="line">    <span class="keyword">int</span> ob_refcnt;</span><br><span class="line">    <span class="comment">/* 对象指针 */</span></span><br><span class="line">    struct_typeobject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br><span class="line">``                                         `</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 增加引用计数的宏定义 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_INCREF(op)   ((op)-&gt;ob_refcnt++)</span></span><br><span class="line"><span class="comment">/* 减少引用计数的宏定义 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_DECREF(op) \ <span class="comment">//减少计数</span></span></span><br><span class="line">    <span class="keyword">if</span> (--(op)-&gt;ob_refcnt != <span class="number">0</span>) \</span><br><span class="line">        ; \</span><br><span class="line">    <span class="keyword">else</span> \</span><br><span class="line">        __Py_Dealloc((PyObject *)(op))</span><br></pre></td></tr></table></figure></p>
<p>导致引用计数+1的情况：</p>
<pre><code>- 对象被创建，例如a = 23
- 对象被引用，例如b = a
- 对象被作为参数，传入到一个函数中，例如f(a)
- 对象作为一个元素，存储在容器中，例如list1 = [a, a]
</code></pre><p>导致引用计数-1的情况：</p>
<pre><code>- 对象的别名被显式销毁，例如del a
- 对象的别名被赋予新的对象，例如a = 24
- 一个对象离开它的作用域，例如f函数执行完毕时，f函数中的局部变量（全局变量不会）
- 对象所在的容器被销毁，或从容器中删除对象
</code></pre><p>引用计数可能会导致循环引用问题，而循环引用会导致内存泄露，如下面的代码所示。为了解决这个问题，Python中引入了“标记-清除”和“分代收集”。在创建一个对象的时候，对象被放在第一代中，如果在第一代的垃圾检查中对象存活了下来，该对象就会被放到第二代中，同理在第二代的垃圾检查中对象存活下来，该对象就会被放到第三代中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 循环引用会导致内存泄露 - Python除了引用技术还引入了标记清理和分代回收</span></span><br><span class="line"><span class="comment"># 在Python 3.6以前如果重写__del__魔术方法会导致循环引用处理失效</span></span><br><span class="line"><span class="comment"># 如果不想造成循环引用可以使用弱引用</span></span><br><span class="line">list1 = []</span><br><span class="line">list2 = []</span><br><span class="line">list1.append(list2)</span><br><span class="line">list2.append(list1)</span><br></pre></td></tr></table></figure>
<p>以下情况会导致垃圾回收：</p>
<ul>
<li>调用gc.collect()</li>
<li>gc模块的计数器达到阀值</li>
<li>程序退出</li>
</ul>
<p>如果循环引用中两个对象都定义了<code>__del__</code>方法，gc模块不会销毁这些不可达对象，因为gc模块不知道应该先调用哪个对象的<code>__del__</code>方法，这个问题在Python 3.6中得到了解决。</p>
<p>也可以通过<code>weakref</code>模块构造弱引用的方式来解决循环引用的问题。</p>
<p>魔法属性和方法（请参考《Python魔法方法指南》）</p>
<p>有几个小问题请大家思考：</p>
<ul>
<li>自定义的对象能不能使用运算符做运算？</li>
<li>自定义的对象能不能放到set中？能去重吗？</li>
<li>自定义的对象能不能作为dict的键？</li>
<li>自定义的对象能不能使用上下文语法？</li>
</ul>
<ol>
<li>混入（Mixin）</li>
</ol>
<p>例子：自定义字典限制只有在指定的key不存在时才能在字典中设置键值对。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetOnceMappingMinxin</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""自定义混入类"""</span></span><br><span class="line">    __slots__ = ()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self,key,value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">raise</span> KeyError(str(key)+<span class="string">' already set'</span>)</span><br><span class="line">        <span class="keyword">return</span> super().__setitem__(key,value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetOnceDict</span><span class="params">(SetOnceMappingMinxin,dict)</span>:</span></span><br><span class="line">    <span class="string">"""自定义词典"""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_dict = SetOnceDict()</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    my_dict[<span class="string">'username'</span>] = <span class="string">'jackfrued'</span></span><br><span class="line">    my_dict[<span class="string">'username'</span>] = <span class="string">'hellokitty'</span></span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(my_dict)</span><br></pre></td></tr></table></figure>
<h2 id="元编程和元类"><a href="#元编程和元类" class="headerlink" title="元编程和元类"></a>元编程和元类</h2><p>例子：用元类实现单例模式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="string">"""自定义元类"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls,*args,**kwargs)</span>:</span></span><br><span class="line">        cls.__instance = <span class="literal">None</span></span><br><span class="line">        cls.__lock = threading.Lock()</span><br><span class="line">        super().__init__(*args,**kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(cls,*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">with</span> cls.__lock:</span><br><span class="line">                <span class="keyword">if</span> cls.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    cls.__instance = super().__call__(*args,**kwargs)</span><br><span class="line">        <span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Persident</span><span class="params">(metaclass=SingletonMeta)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = Persident()</span><br><span class="line">b = Persident()</span><br><span class="line">print(id(a))</span><br><span class="line">print(id(b))</span><br></pre></td></tr></table></figure>
<h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><p>单一职责原则 （<strong>S</strong>RP）- 一个类只做该做的事情（类的设计要高内聚）<br>开闭原则 （<strong>O</strong>CP）- 软件实体应该对扩展开发对修改关闭<br>依赖倒转原则（DIP）- 面向抽象编程（在弱类型语言中已经被弱化）<br>里氏替换原则（<strong>L</strong>SP） - 任何时候可以用子类对象替换掉父类对象<br>接口隔离原则（<strong>I</strong>SP）- 接口要小而专不要大而全（Python中没有接口的概念）<br>合成聚合复用原则（CARP） - 优先使用强关联关系而不是继承关系复用代码<br>最少知识原则（迪米特法则，Lo<strong>D</strong>）- 不要给没有必然联系的对象发消息</p>
<blockquote>
<p>说明：上面加粗的字母放在一起称为面向对象的<strong>SOLID</strong>原则。</p>
</blockquote>
<h2 id="GoF设计模式"><a href="#GoF设计模式" class="headerlink" title="GoF设计模式"></a>GoF设计模式</h2><p>创建型模式：单例、工厂、建造者、原型<br>结构型模式：适配器、门面（外观）、代理<br>行为型模式：迭代器、观察者、状态、策略</p>
<p>例子：可插拔的哈希算法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamHasher</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""哈希摘要生成器(策略模式)"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,alg=<span class="string">'md5'</span>,size=<span class="number">4096</span>)</span>:</span></span><br><span class="line">        self.size = size</span><br><span class="line">        self.alg = alg.lower()</span><br><span class="line">        self.hasher = getattr(__import__(<span class="string">'hashlib'</span>),alg.lower())()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self,stream)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.to_digest(stream)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_digest</span><span class="params">(self,stream)</span>:</span></span><br><span class="line">        <span class="string">"""生成十六进制摘要"""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> buf <span class="keyword">in</span> iter(<span class="keyword">lambda</span>: stream.read(self.size),<span class="string">b''</span>):</span><br><span class="line">            self.hasher.update(buf)</span><br><span class="line">        <span class="keyword">return</span> self.hasher.hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""主函数"""</span></span><br><span class="line">    hasher1 = StreamHasher()</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'oo.py'</span>,<span class="string">'rb'</span>) <span class="keyword">as</span> stream:</span><br><span class="line">        print(hasher1.to_digest(stream))</span><br><span class="line"></span><br><span class="line">    hasher2 = StreamHasher(<span class="string">'sha1'</span>)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'oo.py'</span>,<span class="string">'rb'</span>) <span class="keyword">as</span> stream:</span><br><span class="line">        print(hasher2(stream))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h2><ul>
<li>和迭代器相关的魔术方法（<code>__iter__</code>和<code>__next__</code>）</li>
<li>两种创建生成器的方式（生成器表达式和<code>yield</code>关键字）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="string">"""生成器"""</span></span><br><span class="line">    a,b = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(num):</span><br><span class="line">        a,b = b, a+b</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fib</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""迭代器"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,num)</span>:</span></span><br><span class="line">        self.num = num</span><br><span class="line">        self.a,self,b = <span class="number">0</span>,<span class="number">1</span></span><br><span class="line">        self.idx = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.idx &lt; self.num:</span><br><span class="line">            self.a,self.b = self.b,self.a + self.b</span><br><span class="line">            self.idx += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> self.a</span><br><span class="line">        <span class="keyword">raise</span> StopIteration</span><br></pre></td></tr></table></figure>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><pre><code>Python中实现并发编程的三种方案：多线程、多进程和异步I/O。并发编程的好处在于可以提升程序的执行效率以及改善用户体验；坏处在于并发的程序不容易开发和调试，同时对其他程序来说它并不友好。

- 多线程：Python中提供了Thread类并辅以Lock、Condition、Event、Semaphore和Barrier。Python中有GIL来防止多个线程同时执行本地字节码，这个锁对于CPython是必须的，因为CPython的内存管理并不是线程安全的，因为GIL的存在多线程并不能发挥CPU的多核特性。
</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">面试题：进程和线程的区别和联系？</span></span><br><span class="line"><span class="string">进程 - 操作系统分配内存的基本单位 - 一个进程可以包含一个或多个线程</span></span><br><span class="line"><span class="string">线程 - 操作系统分配CPU的基本单位</span></span><br><span class="line"><span class="string">并发编程（concurrent programming）</span></span><br><span class="line"><span class="string">1. 提升执行性能 - 让程序中没有因果关系的部分可以并发的执行</span></span><br><span class="line"><span class="string">2. 改善用户体验 - 让耗时间的操作不会造成程序的假死</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">PREFIX = <span class="string">'thumbnails'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_thumbnail</span><span class="params">(infile, size, format=<span class="string">'PNG'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""生成指定图片文件的缩略图"""</span></span><br><span class="line">    file, ext = os.path.splitext(infile)</span><br><span class="line">    file = file[file.rfind(<span class="string">'/'</span>) + <span class="number">1</span>:]</span><br><span class="line">    outfile = <span class="string">f'<span class="subst">&#123;PREFIX&#125;</span>/<span class="subst">&#123;file&#125;</span>_<span class="subst">&#123;size[<span class="number">0</span>]&#125;</span>_<span class="subst">&#123;size[<span class="number">1</span>]&#125;</span>.<span class="subst">&#123;ext&#125;</span>'</span></span><br><span class="line">    img = Image.open(infile)</span><br><span class="line">    img.thumbnail(size, Image.ANTIALIAS)</span><br><span class="line">    img.save(outfile, format)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""主函数"""</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(PREFIX):</span><br><span class="line">        os.mkdir(PREFIX)</span><br><span class="line">        <span class="keyword">for</span> infile <span class="keyword">in</span> glob.glob(<span class="string">'images/*.png'</span>):</span><br><span class="line">            <span class="keyword">for</span> size <span class="keyword">in</span> (<span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>):</span><br><span class="line">                <span class="comment"># 创建并启动线程</span></span><br><span class="line">                threading.Thread(</span><br><span class="line">                    target=generate_thumbnail,</span><br><span class="line">                    args=(infile, (size, size))</span><br><span class="line">                ).start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>多个线程竞争资源</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">多线程程序如果没有竞争资源处理起来通常也比较简单</span></span><br><span class="line"><span class="string">当多个线程竞争临界资源的时候如果缺乏必要的保护措施就会导致数据错乱</span></span><br><span class="line"><span class="string">说明：临界资源就是被多个线程竞争的资源</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""银行账户"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.balance = <span class="number">0.0</span></span><br><span class="line">        self.lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(self,money)</span>:</span></span><br><span class="line">        <span class="comment"># 使用锁保护临界资源</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            new_balance = self.balance + money</span><br><span class="line">            time.sleep(<span class="number">0.01</span>)</span><br><span class="line">            self.balance = new_balance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddMoneyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="string">"""自定义线程"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,account,money)</span>:</span></span><br><span class="line">        self.account = account</span><br><span class="line">        self.money = money</span><br><span class="line">        super().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.account.deposit(self.money)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    account = Account()</span><br><span class="line"></span><br><span class="line">    <span class="string">"""创建线程池"""</span></span><br><span class="line">    futures = []</span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=<span class="number">10</span>)</span><br><span class="line">    futures = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        <span class="comment"># 创建线程的第1种方式</span></span><br><span class="line">        <span class="comment"># threading.Thread(</span></span><br><span class="line">        <span class="comment">#     target=account.deposit, args=(1, )</span></span><br><span class="line">        <span class="comment"># ).start()</span></span><br><span class="line">        <span class="comment"># 创建线程的第2种方式</span></span><br><span class="line">        <span class="comment"># AddMoneyThread(account, 1).start()</span></span><br><span class="line">        <span class="comment"># 创建线程的第3种方式</span></span><br><span class="line">        <span class="comment"># 调用线程池中的线程来执行特定的任务</span></span><br><span class="line">        future = pool.submit(account.deposit, <span class="number">1</span>)</span><br><span class="line">        futures.append(future)</span><br><span class="line">    <span class="comment"># 关闭线程池</span></span><br><span class="line">    pool.shutdown()</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">        future.result()</span><br><span class="line">    print(account.balance)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>修改上面的程序，启动5个线程向账户中存钱，5个线程从账户中取钱，取钱时如果余额不足就暂停线程进行等待。为了达到上述目标，需要对存钱和取钱的线程进行调度，在余额不足时取钱的线程暂停并释放锁，而存钱的线程将钱存入后要通知取钱的线程，使其从暂停状态被唤醒。可以使用<code>threading</code>模块的Condition来实现线程调度，该对象也是基于锁来创建的，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">多个线程竞争一个资源 - 保护临界资源 - 锁（Lock/RLock）</span></span><br><span class="line"><span class="string">多个线程竞争多个资源（线程数&gt;资源数） - 信号量（Semaphore）</span></span><br><span class="line"><span class="string">多个线程的调度 - 暂停线程执行/唤醒等待中的线程 - Condition</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""银行账户"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,balance=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.balance = balance</span><br><span class="line">        self.lock = threading.Lock()</span><br><span class="line">        self.condition = threading.Condition(self.lock)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">withdraw</span><span class="params">(self,money)</span>:</span></span><br><span class="line">        <span class="string">"""取钱"""</span></span><br><span class="line">        <span class="keyword">with</span> self.condition:</span><br><span class="line">            <span class="keyword">while</span> self.balance &lt; money:</span><br><span class="line">                self.condition.wait()</span><br><span class="line">            new_balance = self.balance - money</span><br><span class="line">            sleep(<span class="number">0.01</span>)</span><br><span class="line">            self.balance = new_balance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(self,money)</span>:</span></span><br><span class="line">        <span class="string">"""存钱"""</span></span><br><span class="line">        <span class="keyword">with</span> self.condition:</span><br><span class="line">            new_balance = self.balance + money</span><br><span class="line">            time.sleep(<span class="number">0.01</span>)</span><br><span class="line">            self.balance = new_balance</span><br><span class="line">            self.condition.notify_all()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_money</span><span class="params">(account)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        money = randint(<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">        account.deposit(money)</span><br><span class="line">        print(threading.current_thread().name,<span class="string">':'</span>,money,<span class="string">'===&gt;'</span>,account.balance)</span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub_money</span><span class="params">(account)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        money = randint(<span class="number">10</span>,<span class="number">30</span>)</span><br><span class="line">        account.withdraw(money)</span><br><span class="line">        print(threading.current_thread().name,<span class="string">':'</span>,money,<span class="string">'&lt;==='</span>,account.balance)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    account = Account()</span><br><span class="line">    <span class="keyword">with</span> ThreadPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">            pool.submit(add_money,account)</span><br><span class="line">            pool.submit(sub_money,account)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<ul>
<li>多进程：多进程可以有效的解决GIL的问题，实现多进程主要的类是Process，其他辅助的类跟threading模块中的类似，进程间共享数据可以使用管道、套接字等，在multiprocessing模块中有一个Queue类，它基于管道和锁机制提供了多个进程共享的队列。下面是官方文档上关于多进程和进程池的一个示例。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">多进程和进程池的使用</span></span><br><span class="line"><span class="string">多线程因为GIL的存在不能够发挥CPU的多核特性</span></span><br><span class="line"><span class="string">对于计算密集型任务应该考虑使用多进程</span></span><br><span class="line"><span class="string">time python3 example22.py</span></span><br><span class="line"><span class="string">real    0m11.512s</span></span><br><span class="line"><span class="string">user    0m39.319s</span></span><br><span class="line"><span class="string">sys     0m0.169s</span></span><br><span class="line"><span class="string">使用多进程后实际执行时间为11.512秒，而用户时间39.319秒约为实际执行时间的4倍</span></span><br><span class="line"><span class="string">这就证明我们的程序通过多进程使用了CPU的多核特性，而且这台计算机配置了4核的CPU</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">PRIMES = [</span><br><span class="line">    <span class="number">1116281</span>,</span><br><span class="line">    <span class="number">1297337</span>,</span><br><span class="line">    <span class="number">104395303</span>,</span><br><span class="line">    <span class="number">472882027</span>,</span><br><span class="line">    <span class="number">533000389</span>,</span><br><span class="line">    <span class="number">817504243</span>,</span><br><span class="line">    <span class="number">982451653</span>,</span><br><span class="line">    <span class="number">112272535095293</span>,</span><br><span class="line">    <span class="number">112582705942171</span>,</span><br><span class="line">    <span class="number">112272535095293</span>,</span><br><span class="line">    <span class="number">115280095190773</span>,</span><br><span class="line">    <span class="number">115797848077099</span>,</span><br><span class="line">    <span class="number">1099726899285419</span></span><br><span class="line">] * <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""判断素数"""</span></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    sqrt_n = int(math.floor(math.sqrt(n)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, sqrt_n + <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""主函数"""</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="keyword">for</span> number, prime <span class="keyword">in</span> zip(PRIMES, executor.map(is_prime, PRIMES)):</span><br><span class="line">            print(<span class="string">'%d is prime: %s'</span> % (number, prime))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：<strong>多线程和多进程的比较</strong>。</p>
<p>以下情况需要使用多线程：</p>
<ol>
<li>程序需要维护许多共享的状态（尤其是可变状态），Python中的列表、字典、集合都是线程安全的，所以使用线程而不是进程维护共享状态的代价相对较小。</li>
<li>程序会花费大量时间在I/O操作上，没有太多并行计算的需求且不需占用太多的内存。</li>
</ol>
<p>以下情况需要使用多进程：</p>
<ol>
<li>程序执行计算密集型任务（如：字节码操作、数据处理、科学计算）。</li>
<li>程序的输入可以并行的分成块，并且可以将运算结果合并。</li>
<li>程序在内存使用方面没有任何限制且不强依赖于I/O操作（如：读写文件、套接字等）。</li>
</ol>
</blockquote>
<ul>
<li>异步处理：从调度程序的任务队列中挑选任务，该调度程序以交叉的形式执行这些任务，我们并不能保证任务将以某种顺序去执行，因为执行顺序取决于队列中的一项任务是否愿意将CPU处理时间让位给另一项任务。异步任务通常通过多任务协作处理的方式来实现，由于执行时间和顺序的不确定，因此需要通过回调式编程或者<code>future</code>对象来获取任务执行的结果。Python 3通过<code>asyncio</code>模块和<code>await</code>和<code>async</code>关键字（在Python 3.7中正式被列为关键字）来支持异步处理。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">异步I/O - async / await</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">num_generator</span><span class="params">(m,n)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> range(m,n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">prime_filter</span><span class="params">(m,n)</span>:</span></span><br><span class="line">    <span class="string">"""素数过滤器"""</span></span><br><span class="line">    primes = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> num_generator(m,n):</span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">2</span>,int(i**<span class="number">0.5</span> + <span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">if</span> i % j == <span class="number">0</span>:</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            print(<span class="string">"Prime =&gt;"</span>,i)</span><br><span class="line">            primes.append(i)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.001</span>)</span><br><span class="line">    <span class="keyword">return</span> tuple(primes)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">square_mapper</span><span class="params">(m,n)</span>:</span></span><br><span class="line">    <span class="string">"""平方映射器"""</span></span><br><span class="line">    squares = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> num_generator(m,n):</span><br><span class="line">        print(<span class="string">'Square =&gt;'</span>,i ** <span class="number">2</span>)</span><br><span class="line">        squares.append(i ** <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">0.001</span>)</span><br><span class="line">    <span class="keyword">return</span> tuple(squares)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""主函数"""</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    future = asyncio.gather(prime_filter(<span class="number">2</span>,<span class="number">100</span>),square_mapper(<span class="number">1</span>,<span class="number">100</span>))</span><br><span class="line">    future.add_done_callback(<span class="keyword">lambda</span> x: print(x.result()))</span><br><span class="line">    loop.run_until_complete(future)</span><br><span class="line">    loop.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：上面的代码使用<code>get_event_loop</code>函数获得系统默认的事件循环，通过<code>gather</code>函数可以获得一个<code>future</code>对象，<code>future</code>对象的<code>add_done_callback</code>可以添加执行完成时的回调函数，<code>loop</code>对象的<code>run_until_complete</code>方法可以等待通过<code>future</code>对象获得协程执行结果。</p>
</blockquote>
<p>Python中有一个名为<code>aiohttp</code>的三方库，它提供了异步的HTTP客户端和服务器，这个三方库可以跟<code>asyncio</code>模块一起工作，并提供了对<code>Future</code>对象的支持。Python 3.6中引入了async和await来定义异步执行的函数以及创建异步上下文，在Python 3.7中它们正式成为了关键字。下面的代码异步的从5个URL中获取页面并通过正则表达式的命名捕获组提取了网站的标题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line">PATTERN = re.compile(<span class="string">r'\&lt;title\&gt;(?P&lt;title&gt;.*)\&lt;\/title\&gt;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch_page</span><span class="params">(session,url)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url,ssl=<span class="literal">False</span>) <span class="keyword">as</span> resp:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> resp.text()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">show_title</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        html = <span class="keyword">await</span> fetch_page(session,url)</span><br><span class="line">        print(PATTERN.search(html).group(<span class="string">'title'</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    urls = (<span class="string">'https://www.python.org/'</span>,</span><br><span class="line">                 <span class="string">'https://git-scm.com/'</span>,</span><br><span class="line">                 <span class="string">'https://www.jd.com/'</span>,</span><br><span class="line">                 <span class="string">'https://www.taobao.com/'</span>,</span><br><span class="line">                 <span class="string">'https://www.douban.com/'</span>)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    tasks = [show_title(url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">    loop.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：<strong>异步I/O与多进程的比较</strong>。</p>
<p>当程序不需要真正的并发性或并行性，而是更多的依赖于异步处理和回调时，asyncio就是一种很好的选择。如果程序中有大量的等待与休眠时，也应该考虑asyncio，它很适合编写没有实时数据处理需求的Web应用服务器。</p>
</blockquote>
<p>Python还有很多用于处理并行任务的三方库，例如：joblib、PyMP等。实际开发中，要提升系统的可扩展性和并发性通常有垂直扩展（增加单个节点的处理能力）和水平扩展（将单个节点变成多个节点）两种做法。可以通过消息队列来实现应用程序的解耦合，消息队列相当于是多线程同步队列的扩展版本，不同机器上的应用程序相当于就是线程，而共享的分布式消息队列就是原来程序中的Queue。消息队列（面向消息的中间件）的最流行和最标准化的实现是AMQP（高级消息队列协议），AMQP源于金融行业，提供了排队、路由、可靠传输、安全等功能，最著名的实现包括：Apache的ActiveMQ、RabbitMQ等。</p>
<p>要实现任务的异步化，可以使用名为Celery的三方库。Celery是Python编写的分布式任务队列，它使用分布式消息进行工作，可以基于RabbitMQ或Redis来作为后端的消息代理。</p>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
  </entry>
  <entry>
    <title>词编码（表示）</title>
    <url>/2020/03/01/Word-Encoding/</url>
    <content><![CDATA[<h1 id="词编码（表示）"><a href="#词编码（表示）" class="headerlink" title="词编码（表示）"></a>词编码（表示）</h1><h2 id="One-hot-Representation"><a href="#One-hot-Representation" class="headerlink" title="One-hot Representation"></a>One-hot Representation</h2><p>假设词汇表中共计$N$个word，则展开一个<code>N</code>维的Vector，对应word的位置赋值为1,其他位置为0。</p>
<p>For example:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Time flies like an arrow.</span><br><span class="line">Fruit flies like a banana.</span><br></pre></td></tr></table></figure>
<p>词汇表的长度为8：<code>{time, fruit, flies, like, an, arrow, banana }</code>。应次每个word都可以表示为 8-D Vector。</p>
<p>因此，对于短语和句子，文档可以简单的表示为连续词的 与或 运算。</p>
<p><code>like a banana</code>能够表示为<code>{0,0,0,1,1,0,0,1}</code></p>
<p>问题：无法衡量词之间的相似度，维度太高。</p>
<h2 id="TF-Representation"><a href="#TF-Representation" class="headerlink" title="TF Representation"></a>TF Representation</h2><p>短语，句子或文档的TF表示能够简单表示为连续词的one-hot vector的和。</p>
<p><code>Fruit flies like time flies a fruit:[1,2,2,1,1,0,0,0]</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">corpus = [<span class="string">'Time flies like an arrow.'</span>,</span><br><span class="line">          <span class="string">'Fruit flies like a banana.'</span>]</span><br><span class="line">one_hot_vectorizer = CountVectorizer(binary=<span class="literal">True</span>)</span><br><span class="line">one_hot = one_hot_vectorizer.fit_transform(corpus).toarray()</span><br><span class="line">vocab = one_hot_vectorizer.get_feature_names()</span><br><span class="line"></span><br><span class="line">sns.heatmap(one_hot, annot=<span class="literal">True</span>,</span><br><span class="line">           cbar=<span class="literal">False</span>, xticklabels=vocab,</span><br><span class="line">           yticklabels=[<span class="string">'Sentence 1'</span>,<span class="string">'Sentence 2'</span>])</span><br></pre></td></tr></table></figure>
<h2 id="TF-IDF-Representation"><a href="#TF-IDF-Representation" class="headerlink" title="TF-IDF Representation"></a>TF-IDF Representation</h2><script type="math/tex; mode=display">
IDF(w)=\log\frac{N}{n_w}</script><p><code>TF: Term Frequency</code></p>
<p><code>IDF: Inverse-Document-Frequency</code></p>
<ul>
<li>$n_w$s：是文档中包括 <code>w</code>的数量</li>
<li>$N$：是文档的数量</li>
</ul>
<script type="math/tex; mode=display">
TF-IDF = TF(w)*IDF(w)</script><p>如果一个文档的词出现的比较稀少，则IDF越高，说明词的重要性越大。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line">corpus = [<span class="string">'Time flies like an arrow.'</span>,</span><br><span class="line">          <span class="string">'Fruit flies like a banana.'</span>]</span><br><span class="line">tfidf = TfidfVectorizer()</span><br><span class="line">vectors = tfidf.fit_transform(corpus).toarray()</span><br><span class="line">vocab = tfidf.get_feature_names()</span><br><span class="line"></span><br><span class="line">sns.heatmap(vectors, annot=<span class="literal">True</span>,</span><br><span class="line">           cbar=<span class="literal">False</span>, xticklabels=vocab,</span><br><span class="line">           yticklabels=[<span class="string">'Sentence 1'</span>,<span class="string">'Sentence 2'</span>])</span><br></pre></td></tr></table></figure>
<h2 id="基于奇异值分解（SVD）的方法"><a href="#基于奇异值分解（SVD）的方法" class="headerlink" title="基于奇异值分解（SVD）的方法"></a>基于奇异值分解（SVD）的方法</h2><p>这是一种构造词向量的方法。</p>
<ol>
<li>第一步，遍历全部的文本数据集，统计词出现的次数；</li>
<li>然后使用矩阵$X$来表示所有次数的情况；</li>
<li>接着对$X$进行SVD得到$USV^T$的分解</li>
<li>最后使用U的行作为所有词表中词的词向量。</li>
</ol>
<p>对于矩阵$X$，可以采用两种方法：全文 or 窗口长度。</p>
<ul>
<li><p>词-文档矩阵</p>
<p>建立词组文档矩阵$X$，遍历海量文件，每次词组$i$出现在文件$j$中时，将对应的$X_{ij}$的值加1。矩阵的形状为$\mathbb{R}^{|V|\times M}$，矩阵，矩阵将会非常大，并且和文档个数$M$有关。所以需要采取办法进行处理和优化。</p>
<p>最终词-文档的共现矩阵最终将会得到泛化的主题（比如某类词汇将会产生相似的表示），这就是所谓的浅层语义分析（LSA,Latent Semantic Analysis）</p>
</li>
<li><p>基于窗口的共现矩阵</p>
<p>将矩阵$X$记录的词频情况变成一个相关性矩阵。</p>
<p>对$X$进行SVD，观察奇异值（矩阵的对角元素），根据我们期望保留的多少进行截断（保留前多少个维度），将子矩阵$U_{1:|V|,1:k}$作为词向量矩阵，这样，对于词表中的每个词，都使用一个$k$维的向量表示。窗口长度容易捕获到语法和语义信息。</p>
</li>
</ul>
<p>问题</p>
<ul>
<li>矩阵的维度会经常变化（新的词语经常会增加，语料库的大小也会随时变化）。</li>
<li>矩阵是非常稀疏的，因为大多数词并不同时出现。</li>
<li>矩阵的维度通常非常高（≈106×106），需要大量的存储</li>
<li>训练需要$O(n^2)$的复杂度</li>
<li>对于新词或者新的文档很难及时更新</li>
<li>需要专门对矩阵$X$进行特殊处理，以应对词组频率的极度不平衡的状况</li>
</ul>
<p>解决方案：直接学习低维度的词向量</p>
<p>将最重要的信息存储在固定的，低维度的向量里：密集向量（dense vector)，维数通常是25-1000<br>然而，如何降维？</p>
<h2 id="基于迭代的方法"><a href="#基于迭代的方法" class="headerlink" title="基于迭代的方法"></a>基于迭代的方法</h2><blockquote>
<p>通过一步步的迭代的学习，最终得出每个单词基于其上下文的条件概率。</p>
</blockquote>
<h3 id="n-gram"><a href="#n-gram" class="headerlink" title="n-gram"></a>n-gram</h3><blockquote>
<p>单个词出现的概率只和它前面固定数目的词有关。</p>
</blockquote>
<p>主要方法，在语料中统计各种词串出现的次数来计算概率以及平滑处理，将计算得到的概率值进行存储，下一次计算直接找出相关的概率参数，进行连乘。</p>
<p>建立概率模型，其中包含了已知和未知的参数，每增加一个训练样本，就能学习到一点点未知参数的信息。</p>
<p>每次迭代过程中，模型需要能够评估误差，根据误差进行更新参数。</p>
<h2 id="CBOW"><a href="#CBOW" class="headerlink" title="CBOW"></a>CBOW</h2><p>根据上下文内容预测中心词的表示。</p>
<p><img src="/images/WordEmbedding/CBOW.jpg" alt="CBOW"></p>
<p>连续词袋（Continuous  Bag of Word）模型中的符号：</p>
<ul>
<li>$W_i$：单词表 $V$ 中的第 $i$个单词, one-hot 向量</li>
<li>$v \in \mathbb{R}^{n \times |V|}$：输入词矩阵</li>
<li>$v_i$：$V$的第$i$列，$n$ 维 $W_i$的输入向量</li>
<li>$U \in \mathbb{R}^{|V| \times n}$：输出词矩阵</li>
<li>$U_i$：$U$ 的第 $i$ 行，$n$ 维 $W_i$ 的输出向量</li>
</ul>
<p>整个过程如下：</p>
<ol>
<li>对于输入上下文长度为$m$个词，生成的独热向量$(x^{c-m},\cdots,x^{c-1},x^{c+1},\cdots,x^{c+m})$，作为模型的输入。</li>
<li>得到上下文的嵌入词向量$(v<em>{c-m}=Vx^{c-m},\cdots,v</em>{c+m}=Vx^{c+m})$</li>
<li>将这些向量取平均值$\hat{v}=\frac{v<em>{c-m}+\cdots+v</em>{c+m}}{2m}$</li>
<li>产生一个得分向量$z=U\hat{v}$</li>
<li>将得分向量概率归一化$\hat{y}=softmax(z)$</li>
<li>希望产生的概率分布和真实的概率分布$y$相匹配，其中真实的概率分布就是我们期望的词的独热向量。</li>
</ol>
<p>如何得到矩阵$U,V$</p>
<p>Loss function: Cross-Entroy，使用Gradient Descend去更新矩阵中的参数。</p>
<p>从Information Theroy的角度来评估两个概率分布的差异。最为广泛的的方法就是使用交叉熵：</p>
<script type="math/tex; mode=display">
H(\hat{y},y)=-\sum_{j=1}^{|V|} y_j\log {\hat{y}_j}</script><h2 id="Skip-Gram"><a href="#Skip-Gram" class="headerlink" title="Skip-Gram"></a>Skip-Gram</h2><p><strong>CBOW</strong>的思路将中心词作为目标向量，周围的词作为输入。而<strong>Skip-Gram</strong>和它正好想法，将中心词作为输入，来预测周围词。</p>
<p><img src="/images/WordEmbedding/Skip-Gram-Net.jpg" alt="Skip-Gram-Net"></p>
<p>和<strong>CBOW</strong>模型十分相似，只是交换了输入和输出的位置。输入向量为中心词的独热向量，输出向量为中心词的周围向量。</p>
<p>假设一段话</p>
<p><code>the quick brown fox jumped over the lazy dog</code></p>
<p>取左右窗口为1，则数据集中的（上下文信息，中心词）的数据为：</p>
<p><code>([the, brown], quick), ([quick, fox], brown), ([brown, jumped], fox), ...</code></p>
<p>而<strong>Skip-Gram</strong>通过中心词来预测上下文信息，因此转换成如下形式:</p>
<p><code>(quick, the), (quick, brown), (brown, quick), (brown, fox), ...</code></p>
<p>整个计算过程可以分为以下几步：</p>
<ol>
<li>生成独热变量$x$</li>
<li>上下文的词向量$v_c= Vx$</li>
<li>不需要取平均值，因此，$\hat{v}=v_c$</li>
<li>$U=Uv<em>c$得到2m个得分向量$U</em>{c−m},⋯,U<em>{c−1},U</em>{c+1},⋯,U<em>{c+m}$，如果上下文取一个词，就是$U</em>{c-1},U_{c+1}$</li>
<li>将得分向量转换成概率分布，$y=softmax(u)$</li>
<li>希望产生的概率分布和真实的分布相匹配$y^{c−m},⋯,y^{c−1},,y^{c+1}⋯,y^{c+m}$</li>
</ol>
<p>为模型设定一个目标/损失函数。不过不同的地方是我们这里需要引入朴素贝叶斯假设来将联合概率拆分成独立概率相乘。只要给出了中心词，所有的输出词是完全独立的。使用随机梯度下降算法(SGD)来进行最优化求解，并且使用mini-batch方法 (通常batch_size在16到512之间)。可以用随机梯度下降法去更新未知参数的梯度。</p>
<h2 id="Word2Vec"><a href="#Word2Vec" class="headerlink" title="Word2Vec"></a>Word2Vec</h2><p><strong>Word2Vec</strong>是一个预测模型，用于学习Word Embedding，实现的模型就是上面的两种：CBOW和Skip-Gram。</p>
<ul>
<li>CBOW 从输入的上下文信息来预测目标词</li>
<li>Skip-gram 模型则是相反的，从目标词来预测上下文信息</li>
</ul>
<p>区别上，CBOW适合在小规模的数据集上，能够对分布式的信息进行平滑处理；而Skip-Gram适合在大规模的数据集熵。</p>
<p>其中Embedding也可以来捕捉关系：</p>
<p><img src="/images/WordEmbedding/Embedding_Relation.jpg" alt="Embedding_Relation"></p>
<h2 id="VSM-Vector-Space-Models"><a href="#VSM-Vector-Space-Models" class="headerlink" title="VSM,Vector Space Models"></a>VSM,Vector Space Models</h2><blockquote>
<p>将词表示成一个连续的词向量，并且语义上接近的词对应的向量在空间上也是接近的。</p>
</blockquote>
<p><strong>分布式假说理论</strong>：如果两个词的上下文相同，那么两个词所表示的语义也是一样的；换言之，两个词的语义是否相同或相似，取决于两个词的上下文内容，上下文相同表示两个词是可以等价替换的。</p>
<p>生成Word Embedding 的两类方法：</p>
<ul>
<li><p>计数法：e.g Latent Semantic Analysis</p>
<p>在大规模的语料中统计词语和邻近词语的共现频率，然后将每个词映射为稠密的向量表示。</p>
</li>
<li><p>预测法 ：e.g neural probabilistic language model</p>
<p>直接使用词语的邻近信息来得到预测词的词向量（词向量通常作为模型的训练参数）</p>
</li>
</ul>
<h2 id="词向量任务评估"><a href="#词向量任务评估" class="headerlink" title="词向量任务评估"></a>词向量任务评估</h2><h3 id="内部任务评价"><a href="#内部任务评价" class="headerlink" title="　内部任务评价"></a>　内部任务评价</h3><p>内部任务评价的特点如下：</p>
<ul>
<li>一般是在一个特定的子任务中进行评测</li>
<li>计算很快</li>
<li>有助于理解相关的系统</li>
<li>在实际的NLP任务中表现好坏，可能需要外部关联实际应用</li>
</ul>
<h3 id="方法：词向量类比"><a href="#方法：词向量类比" class="headerlink" title="方法：词向量类比"></a>方法：词向量类比</h3><p>我们先输入一组不完整的类比 a:b::c:? 内部任务评价系统找出最大化余弦相似度的词向量<br>理想情况下，我们想得到$x_b−x_a=x_d−x_c$(例如，王后–国王 = 女演员 – 男演员)。于是$x_b−x_a+x_c=x_d$, 所以我们只需要找出一个与$x_b−x_a+x_c$的标准化内积（比如余弦相似度）取最大值的词向量就可以了。</p>
<h3 id="方法：相关性评价"><a href="#方法：相关性评价" class="headerlink" title="方法：相关性评价"></a>方法：相关性评价</h3><p>另外一个评测词向量质量的简单方法是人为对两个词的相似度在一个固定区间内打分(比如说 0-10)，再跟对应向量的余弦相适度进行对比。</p>
<p>相关参数</p>
<ul>
<li>词向量的维度</li>
<li>资料库的大小</li>
<li>资料源/类型</li>
<li>上下文窗口的大小</li>
<li>上下文的对称性</li>
</ul>
<p>一般而言，</p>
<ul>
<li>精度和使用的模型高度相关，因为这些生成词向量的方法所依据的特性是完全不同的(如同时出现的次数，奇异向量等。)</li>
<li>文集量越大，精度越高，因为例子越多，生成的系统学习到的经验就更丰富。比如在完成词汇类比的例子中，系统如果之前没有接触测试词，就可能会生成错误的结果。</li>
<li>如果维度特别低或特别高，精度就会比较低。低维度词向量无法捕捉文集中不同词语的不同意义。这可以视为我们模型复杂度过低而导致的高偏差。比如 “king”, “queen”, “man”, “woman” 这几个词，我们需要至少2个维度像”gender” 如 “leadership” 来把它们编译成 2-字节 词向量。 过低的维度将无法捕捉四个词之间的语义差别，而过高的维度将捕捉到一些对泛化能力没有用的噪音– 即高方差的问题。</li>
</ul>
<h3 id="外部任务评价"><a href="#外部任务评价" class="headerlink" title="　外部任务评价"></a>　外部任务评价</h3><p>外部任务评价的特点如下：</p>
<ul>
<li>在一个实际任务中进行评测</li>
<li>需要花很长的时间来计算精度</li>
<li>不太清楚是否是某个子系统或者其他子系统，又或是几个子系统互相作用引起的问题</li>
<li>如果替换原有的子系统后获得精度提升，则说明替换很可能是有效的</li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title>关系抽取之PCNN</title>
    <url>/2020/05/11/%E5%85%B3%E7%B3%BB%E6%8A%BD%E5%8F%96%E4%B9%8BPCNN/</url>
    <content><![CDATA[<h1 id="关系抽取之PCNN"><a href="#关系抽取之PCNN" class="headerlink" title="关系抽取之PCNN"></a>关系抽取之PCNN</h1><h2 id="知识图谱构建间接"><a href="#知识图谱构建间接" class="headerlink" title="知识图谱构建间接"></a>知识图谱构建间接</h2><ul>
<li>实体抽取、实体链接（两个实体同一个含义需要调整），主流算法 CNN+LSTM+CRF</li>
<li>实体间关系抽取，得到知识图谱最小单元三元组，经典算法 Piece-Wise-CNN和LSTM-Attention</li>
<li>知识存储 neo4j、apache Jena等</li>
</ul>
<p>知识图谱的关键，先定义好构建它用来干啥，目标业务导向，定义好符合业务逻辑schema层是最重要的。在有了schema后才是实体抽取和关系抽取。关系抽取将知识点整合成知识网络的重要过程。</p>
<a id="more"></a>
<p><img src="/images/PCNN/9168245-668e61926106cb94.webp" alt="9168245-668e61926106cb94"></p>
<ul>
<li>input：句子：<code>Steve Jobs was the co-founder of Apple Inc</code>和两个实体 <code>Steve Jobs</code>和<code>Apple Inc</code></li>
<li>output：实体之间的关系：<code>/business/company/founder</code></li>
</ul>
<p>因此，可以将其转换为一个分类问题，输入句子和实体信息，让模型分出两个实体之间的关系属于的类别。</p>
<h2 id="PCNN"><a href="#PCNN" class="headerlink" title="PCNN"></a>PCNN</h2><p><a href="http://www.emnlp2015.org/proceedings/EMNLP/pdf/EMNLP203.pdf" target="_blank" rel="noopener">http://www.emnlp2015.org/proceedings/EMNLP/pdf/EMNLP203.pdf</a></p>
<p>PCNN的实现过程：</p>
<ul>
<li><p>数据预处理：对数据先进行位置编码，按句子中各个词距离实体的距离进行编码。</p>
<p>例如：“As we known，<strong>Steve Jobs</strong> was the co-founder of <strong>Apple Inc</strong> which is a great company in America.”</p>
<p>句子中由两个entity，句子产生两个和句子长度相同的编码。</p>
<p>pos_1:[-4,-3,-2,-1,0,1,2,3……] ,其中0就是<strong>Steve Jobs</strong>的位置。</p>
<p>pos_2:[-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3……] 其中0就是<strong>Apple Inc</strong>的位置。</p>
</li>
<li><p>切分句子：其中最重要的是将一条文本数据在两个实体处各切一刀将文本分成了三段</p>
<p>比如 As we known，<strong>Steve Jobs</strong> was the co-founder of <strong>Apple Inc</strong> which is a great company in America，将被切成：</p>
<ol>
<li><p>As we known，<strong>Steve Jobs</strong></p>
</li>
<li><p><strong>Steve Jobs</strong> was the co-founder of <strong>Apple Inc</strong></p>
</li>
<li><p><strong>Apple Inc</strong> which is a great company in America</p>
<p>注：位置编码也同样进行了切分操作</p>
</li>
</ol>
</li>
<li><p>特征提取：将位置特征和文本特征拼接后，然后将上面三个数据分别通过CNN提取特征</p>
</li>
<li><p>关系分类：提取出来的特征通过池化层之后进行拼接后传入softmax层，最终得到relation的分类。</p>
</li>
</ul>
<p><img src="/images/PCNN/pcnn.webp" alt="pcnn"></p>
<p>从上面流程中可以发现，这个网络结构注意实体之间的距离信息，位置信息，以及实体之间或左右的信息。</p>
<ul>
<li><p>一般而言，两个实体之间距离越近，则他们有关系的可能性越大</p>
</li>
<li><p>而反映实体之间有关系的词一般会出线在两个实体之间，左侧或者右侧</p>
<p>例如：<strong>Steve Jobs</strong> was the co-founder of <strong>Apple Inc</strong> ， 关系词 co-founder就在两个entity之间</p>
</li>
</ul>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
  </entry>
  <entry>
    <title>基础机器学习公式</title>
    <url>/2019/11/25/%E5%9F%BA%E7%A1%80%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="机器学习-Formula"><a href="#机器学习-Formula" class="headerlink" title="机器学习 Formula"></a>机器学习 Formula</h1><h2 id="Linear-Regression"><a href="#Linear-Regression" class="headerlink" title="Linear Regression"></a>Linear Regression</h2><ol>
<li><p>The Least Mean Square (<strong>LMS</strong>) Algorithm</p>
<script type="math/tex; mode=display">
h_\theta(x) = \sum_{i=1}^{n}\theta_i x_i = \theta^T xParameters</script><ul>
<li>Parameters <script type="math/tex; mode=display">
\theta</script></li>
</ul>
</li>
</ol>
<ul>
<li>Cost function</li>
</ul>
<script type="math/tex; mode=display">
   \begin{split}
   J_l(\theta) & = \frac{1}{2} \sum_{i=1}^{m} (h_\theta(x^{(i)})-y^{(i)})^2 \\
   & = \frac{1}{2} \sum_{i=1}^{m} (\theta^T x^{(i)}-y^{(i)})^2
   \end{split}</script><ul>
<li>Goal</li>
</ul>
<script type="math/tex; mode=display">
   \theta^*=arg_\theta \; minJ_l(\theta)</script><ol>
<li><p>Close-form Solution of LMS</p>
<script type="math/tex; mode=display">
J_l(\theta) = \frac{1}{2} \sum_{i=1}^{m} (h_\theta(x^{(i)})-y^{(i)})^2 = \frac{1}{2}(X\theta - y)^T(X\theta - y)</script><script type="math/tex; mode=display">
\begin{split}
\nabla_\theta J(\theta) &= \nabla_\theta \frac{1}{2} (X\theta - y)^T(X\theta - y)\\
& = \frac{1}{2} \nabla_\theta (\theta^TX^TX\theta - \theta^TX^Ty - y^TX\theta + y^Ty) \\
& = \frac{1}{2} \nabla_\theta tr(\theta^TX^TX\theta - \theta^TX^Ty - y^TX\theta + y^Ty) \\
& = \frac{1}{2} \nabla_\theta (tr\theta^TX^TX\theta - 2tr\theta^TX\theta) \\
& = X^TX\theta - X^Ty
\end{split}</script><script type="math/tex; mode=display">
\theta^* = (X^TX)^{-1}X^Ty</script></li>
<li><p>Gradient Descent for Linear Regression</p>
<ul>
<li>Gradient<script type="math/tex; mode=display">
\begin{split}
\frac{\partial J_l(\theta)}{\partial \theta} & = \frac{1}{2}\frac{\partial}{\partial \theta}\sum_{i=1}^{n} (h_\theta (x^{(i)}) - y^{(i)})^2 \\
& = \frac{1}{2} 2 \sum_{i=1}^n (h_\theta (x^{(i)}) - y^{(i)}) \frac{\partial}{\partial \theta}(h_\theta (x^{(i)}) - y^{(i)}) \\
& = \sum_{i=1}^n (h_\theta (x^{(i)}) - y^{(i)}) \frac{\partial}{\partial \theta}(\theta^T x^{(i)}) \\
& = \sum_{i=1}^n (h_\theta (x^{(i)}) - y^{(i)})x^{(i)}
\end{split}</script></li>
</ul>
</li>
</ol>
<ul>
<li>Gradient Descent (GD) Optimization<script type="math/tex; mode=display">
   \theta: = \theta - \alpha\frac{\partial}{\partial \theta} J_l(\theta) = \theta - \alpha \sum_{i=1}^n (h_\theta (x^{(i)}) - y^{(i)})x^{(i)}</script></li>
</ul>
<h2 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h2><ul>
<li><p>Sigmoid Function:</p>
<script type="math/tex; mode=display">
\begin{split}
& \delta(z) = \frac{1}{1+e^{-z}} \\
& \frac{d\delta}{dz} = \delta(z)(1-\delta(z))
\end{split}</script></li>
<li><p>Hypothesis</p>
<script type="math/tex; mode=display">
\begin{split}
& p(y=1 | x;\theta) = h_\theta(x) = \delta(\theta^Tx) = \frac{1}{1+e^{-\theta^Tx}} \\
& p(y=0 | x;\theta) = 1 - h_\theta(x)
\end{split}</script><p>or</p>
<script type="math/tex; mode=display">
p(y|x;\theta) = (h_\theta(x))^y(1-h_\theta(x))^{1-y} = (\frac{1}{1+e^{-\theta^Tx}})^y(1-\frac{1}{1+e^{-\theta^Tx}})^{1-y}</script></li>
<li><p>Conditional Likelihood Function</p>
<script type="math/tex; mode=display">
\begin{split}
L(\theta) & = \prod_{i=1}^N p(y^{(i)}|x^{(i)};\theta)\\
& = \prod_{i=1}^N (h_\theta(x^{(i)}))^{y^{(i)}}(1-h_\theta(x^{(i)}))^{(1-y)^{(i)}} \\
& = \prod_{i=1}^N (\frac{1}{1+e^{-\theta^Tx^{(i)}}})^{y^{(i)}}(1-\frac{1}{1+e^{-\theta^Tx^{(i)}}})^{(1-y)^{(i)}}
\end{split}</script></li>
<li><p>Maximum Likelihood Estimation</p>
<script type="math/tex; mode=display">
\max_{\theta} L(\theta) \Leftrightarrow = \max_{\theta} \sum_{i=1}^{n}y^{(i)}\log{}{h_\theta(x^{(i)}) + (1-y^{(i)})\log{}{}}1-h_\theta(x^{(i)})</script><blockquote>
<p> The neg log-likelihood function is also known as the <strong>Cross-Entropy</strong> cost function</p>
</blockquote>
</li>
<li><p>Unconstraint Optimization Methods</p>
<ul>
<li>Gradient Descent</li>
</ul>
</li>
<li><p>Stochastic Gradient Descent</p>
<ul>
<li>Newtom Method</li>
</ul>
</li>
<li><p>Quasi-Newtom Method</p>
<ul>
<li>Conjugate Gradient</li>
</ul>
</li>
<li>waiting….</li>
</ul>
<h2 id="Softmax-Regression"><a href="#Softmax-Regression" class="headerlink" title="Softmax Regression"></a>Softmax Regression</h2><ul>
<li>Softmax Regression is a multi-class classification model, also called Multi-class Logistic Regression;</li>
<li>It is also known as the Maximum Entropy Model (in NLP);</li>
<li>It is one of the most used classification algorithms</li>
</ul>
<h3 id="Model-Description"><a href="#Model-Description" class="headerlink" title="Model Description"></a>Model Description</h3><ul>
<li><p>Model Hypothesis</p>
<script type="math/tex; mode=display">
\begin{split}
& p(y=j|x;\theta) = h_j(x) = \frac{e^{\theta_j^Tx}}{1+\sum_{j^{'}=1}^{c-1}e^{\theta_{j^{'}}^Tx}}, j=1,\dots,C-1 \\
& p(y=C|x;\theta) = h_C(x) = \frac{1}{1+\sum_{j^{'}=1}^{c-1}e^{\theta_{j^{'}}^Tx}}
\end{split}</script></li>
<li><p>Model Hypothesis (Compact Form)</p>
<script type="math/tex; mode=display">
p(y=j|x;\theta) = h_j(x) = \frac{e^{\theta_j^Tx}}{\sum_{j^{'}=1}^{c-1}e^{\theta_{j^{'}}^Tx}}, j=1,\dots,C \quad where \; \theta_C =  \vec{0}</script></li>
<li><p>Parameters</p>
<script type="math/tex; mode=display">
\theta_{C \times M}</script></li>
</ul>
<h3 id="Maximun-Likelihood-Estimation"><a href="#Maximun-Likelihood-Estimation" class="headerlink" title="Maximun Likelihood Estimation"></a>Maximun Likelihood Estimation</h3><p>(Conditional) Log-likelihood</p>
<script type="math/tex; mode=display">
\begin{split}
l(\theta) & = \sum_{i=1}^N \log{p(y^{(i)}|x^{(i)};\theta)} \\
& = \sum_{i=1}^N \log \prod_{j=1}^C \big(\frac{e^{\theta_j^Tx}}{\sum_{j^{'}=1}^{C}e^{\theta_{j^{'}}^Tx}}\big)^{1\{y^{(i)}=j\}} \\
& = \sum_{i=1}^{N}\sum_{j=1}^{C}\bold{1}\{y^{(i)}=j\}\log \big(\frac{e^{\theta_j^Tx}}{\sum_{j^{'}=1}^{C}e^{\theta_{j^{'}}^Tx}}\big)\\
& = \sum_{i=1}^{N}\sum_{j=1}^{C}\bold{1}\{y^{(i)}=j\}\log h_j(x^{(i)})
\end{split}</script>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>优化方法</title>
    <url>/2019/11/14/%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="最优化方法"><a href="#最优化方法" class="headerlink" title="最优化方法"></a>最优化方法</h1><h2 id="最速下降法"><a href="#最速下降法" class="headerlink" title="最速下降法"></a>最速下降法</h2><p>原理：</p>
<p>设目标函数$f(x)$在$x^{(k)}$附近连续可微，令$\nabla f(x^{(k)}) \ne 0$。将$f(x)$在$x^{(k)}$处$Taylor$展开</p>
<script type="math/tex; mode=display">
f(x) = f(x^{(k)})+(\nabla f(x^{(k)})^T(x-x^{(k)})) + o(||x-x^{(k)}||)</script><p>令$x-x^{(k)}=\alpha d^{(k)}$，有</p>
<script type="math/tex; mode=display">
f(x) = f(x^{(k)})+\alpha(\nabla f(x^{(k)})^T d^{(k)} + o(\alpha d^{(k)})</script><p>若$(\nabla f(x^{(k)})^T d^{(k)}\lt 0$，则$d^{(k)}$为下降方向。且由$Cauchy-Schwartz$不等式</p>
<script type="math/tex; mode=display">
|(\nabla f(x^{(k)})^T d^{(k)}| \le \Vert \nabla f(x^{(k)}) \Vert \Vert d^{(k)} \Vert</script><p>有且当且仅当$d^{(k)}=- \nabla f(x^{(k)})$时，$-(\nabla f(x^{(k)})^T d^{(k)}$最大。因而以$-\nabla f(x^{(k)})^T $为下降方向的方法称为最速下降法。其中$\alpha _k$由精确线搜索策略选取。</p>
<p>算法流程：</p>
<ol>
<li><p>给定初始点$x^{(1)} \in R^n$，允许误差$\varepsilon \gt 0$，置$k=1$</p>
</li>
<li><p>计算搜索方向$d^{(k)} = - \nabla f(x^{(k)})$，如果$||\nabla f(x^{(k)})|| \le \epsilon$，停止计算</p>
</li>
<li><p>由精确线搜索计算步长$\alpha _k$，使得</p>
<script type="math/tex; mode=display">
f(x^{(k)}+\alpha_kd^{(k)}) = \min_{\alpha \ge 0}f(x^{(k)}+\alpha d^{(k)})</script></li>
<li><p>令$x^{(k+1)} = x^{(k)} + \alpha_k d^{(k)}$，令$k = k +1$，转步骤2</p>
</li>
</ol>
<p>特点：</p>
<ul>
<li><p>计算工作量小，存储量小等优点。</p>
</li>
<li><p>最速下降方向仅是函数的局部性质，对于整体求解，最速下降法下降非常缓慢。</p>
<p>原因是：</p>
<ul>
<li><p>精确线搜索使得$\nabla f(x^{(k+1)})^Td^{(k)} =0$，即最速下降法中前后两次迭代的搜索方向是正交的。</p>
</li>
<li><p>所以在靠近极小点附近的路径呈现锯齿形，下降十分缓慢。</p>
</li>
</ul>
</li>
</ul>
<h2 id="牛顿法"><a href="#牛顿法" class="headerlink" title="牛顿法"></a>牛顿法</h2><p>原理：</p>
<p>设目标函数$f(x)$二次连续可微，$f(x)$在当前迭代点$x^{(k)}$处作$Taylor$展开，并取二阶近似得</p>
<script type="math/tex; mode=display">
f(x) \approx f(x^{(k)}) + \nabla f(x^{(k)})^T(x-x^{(k)}) + \frac{1}{2}^T(x-x^{(k)})^T \nabla^2 f(x^{(k)}) (x-x^{(k)})</script><p>极小化上式右端有</p>
<script type="math/tex; mode=display">
\nabla f(x^{(k)}) + \nabla^2f(x^{(k)})(x-x^{(k)}) = 0</script><p>若$Hessian$矩阵$\nabla^2 f(x^{(k)})$正定，则得到右端二次函数的极小点，并将它作为无约束问题最优值的第$k+1$次近似，即</p>
<script type="math/tex; mode=display">
x^{(k+1)} = x^{(k)} - (\nabla^2f(x^{(k)}))^{-1}\nabla f(x^{(k)})</script><p>这就是牛顿法迭代公式，其中</p>
<script type="math/tex; mode=display">
d^{(k)} = - (\nabla^2f(x^{(k)}))^{-1}\nabla f(x^{(k)}),\; \alpha_k=1</script><p>算法流程：</p>
<ol>
<li>给定初始点$x^{(1)} \in R^n$，允许误差$\varepsilon \gt 0$，置$k=1$</li>
<li>计算$\nabla f(x^{(k)})$，如果$||\nabla f(x^{(k)})|| \le \epsilon$，停止计算。否则，转步骤3</li>
<li>构造牛顿方向$d^{(k)} = - (\nabla^2f(x^{(k)}))^{-1}\nabla f(x^{(k)})$</li>
<li>令$x^{(k+1)} = x^{(k)} + d^{(k)}$，令$k = k +1$，转步骤2</li>
</ol>
<p>特点：</p>
<ul>
<li>牛顿法下降速度快，尤其对于二次凸函数，一次迭代就可以得到全局极小点。</li>
<li>对于一般非二次函数，牛顿法无法保证有限次迭代获得最优解，但初始点十分靠近极小点，牛顿法一定条件下可以达到二阶收敛速度。</li>
</ul>
<h2 id="阻尼牛顿法"><a href="#阻尼牛顿法" class="headerlink" title="阻尼牛顿法"></a>阻尼牛顿法</h2><p>算法流程：</p>
<ol>
<li><p>给定初始点$x^{(1)} \in R^n$，允许误差$\varepsilon \gt 0$，置$k=1$</p>
</li>
<li><p>计算$\nabla f(x^{(k)})$，如果$||\nabla f(x^{(k)})|| \le \epsilon$，停止计算。否则，转步骤3</p>
</li>
<li><p>构造牛顿方向$d^{(k)} = - (\nabla^2f(x^{(k)}))^{-1}\nabla f(x^{(k)})$。由精确线搜索计算步长$a_k$，使得</p>
<script type="math/tex; mode=display">
f(x^{(k)}+\alpha_kd^{(k)}) = \min_{\alpha \ge 0}f(x^{(k)}+\alpha d^{(k)})</script></li>
<li><p>令$x^{(k+1)} = x^{(k)} + d^{(k)}$，令$k = k +1$，转步骤2</p>
</li>
</ol>
<h2 id="共轭梯度法"><a href="#共轭梯度法" class="headerlink" title="共轭梯度法"></a>共轭梯度法</h2><p>算法流程：</p>
<ol>
<li><p>给定初始点$x^{(1)} \in R^n$，允许误差$\varepsilon \gt 0$，令$d^{(1)}=-\nabla f(x^{(1)})$。置$k=1$</p>
</li>
<li><p>如果$||\nabla f(x^{(k)})|| \le \epsilon$，停止计算。否则，转步骤3</p>
</li>
<li><p>由精确线搜索计算步长$a_k$，使得</p>
<script type="math/tex; mode=display">
f(x^{(k)}+\alpha_kd^{(k)}) = \min_{\alpha \ge 0}f(x^{(k)}+\alpha d^{(k)})</script><p>令$x^{(k+1)} = x^{(k)}+\alpha _k d^{(k)}$</p>
</li>
<li><p>计算$\beta _k= \frac{||\nabla f(x^{(k+1)})||^2}{||\nabla f(x^{(k)})||^2}$，$d^{(k+1)}=-\nabla f(x^{(k+1)})+\beta _k d^{(k)}$</p>
</li>
<li><p>令$k = k +1$，转步骤2</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title>时间复杂度计算</title>
    <url>/2020/03/24/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="时间复杂度计算"><a href="#时间复杂度计算" class="headerlink" title="时间复杂度计算"></a>时间复杂度计算</h1><p>复杂度分析是用于评估算法执行效率的方法。</p>
<p>事后统计法：通过将代码进行运行、监控等得到算法执行事件和占用的内存大小。存在非常大的局限性</p>
<ul>
<li>测试结果依赖测试环境</li>
<li>测试结果受数据规模的影响很大</li>
</ul>
<p><strong>不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法</strong>。这就是<strong>时间、空间复杂度</strong>分析方法。</p>
<p>大 O 复杂度表示法</p>
<p>所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。</p>
<script type="math/tex; mode=display">
T(n)=O(f(n))</script><p>T(n) 我们已经讲过了，它表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。这就是<strong>大 O 时间复杂度表示法</strong>。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是<strong>表示代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。</p>
<p>时间复杂度分析的方法：</p>
<ol>
<li>只关注循环次数最多的一段代码</li>
<li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li>
<li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li>
</ol>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title>机器学习基础</title>
    <url>/2019/12/07/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="机器学习基础-待完成"><a href="#机器学习基础-待完成" class="headerlink" title="机器学习基础(待完成)"></a>机器学习基础(待完成)</h1><blockquote>
<p>参考 花书 《深度学习》第五章 和 周志华《机器学习》</p>
</blockquote>
<h2 id="学习算法"><a href="#学习算法" class="headerlink" title="学习算法"></a>学习算法</h2><p>机器学习算法是一种能够从数据中学习的算法。</p>
<p>“学习”：对于某类任务T和性能度量P，一个计算机程序被认为可以从经验E中学习，通过经验E改进后，它在任务T上由性能度量P衡量的性能有所提升。</p>
<a id="more"></a>
<h3 id="任务T"><a href="#任务T" class="headerlink" title="任务T"></a>任务T</h3><p>机器学习任务定义为机器学习系统应该如何处理<strong>样本</strong>(example)。</p>
<p>样本：我们从某些希望机器学习系统处理的对象或事件中收集到的已经量化的<strong>特征</strong>（feature）的集合。通常样本表示成一个Vector $x\in \mathbb{R}^n$,其中的每个分量$x_i$是一个特征。</p>
<p>常见机器学习任务：</p>
<ul>
<li>分类：计算机程序需要指定某些输入属于k类中的哪一类。</li>
<li>输入缺失分类：当一些输入可能丢失时，学习算法必须学习一组函数，而不是单个分类函数。每个函数对应着分类具有不同缺失输入子集的$X$。这种情况在医疗诊断中经常出现。</li>
<li>回归：计算机程序需要对给定输入预测数值。输出函数$f:\mathbb{R}^n \rightarrow \mathbb{R}$</li>
<li>转录：机器学习系统观测一些相对非结构化表示的数据，并转录信息为离散的文本形式。如光学字符识别。</li>
<li>机器翻译：输入是一种语言的符号序列，计算机程序必须将其转化成另一种语言的符号序列。通常适用于自然语言。</li>
<li>结构化输出：结构化输出任务的输出是向量或者其他包含多个值的数据结构，并且构成输出的这些不同元素间具有重要关系。包括上述转录任务和翻译任务在内的很多其他任务。例如语法分析——映射自然语言句子到语法结构树，标记树的节点的词性。</li>
<li>异常检测：计算机程序在一组事件或对象中筛选，并标记不正常或非典型的个体。例如信用卡欺诈检测。</li>
<li>合成和采样：机器学习程序生成一些和训练数据近似的新样本常用与生成媒体，游戏的自然纹理。某些情况下希望采样或合成过程中可以根据输入生成一些特定类型的输出。如根据书写的句子，输出句子语音的音频波形。这是一类结构化输出任务，没有唯一正确的结构，希望结构更加自然和真实。</li>
<li>缺失值填补：给定一个新样本$x\in \mathbb{R}^n$，$X$中某些元素$x_i$缺失。算法填补这些缺失值。</li>
<li>去噪：干净样本$x\in \mathbb{R}^n$经过未知损坏过程得到的损失样本$\tilde{x} \in \mathbb{R}^n$。算法根据损失后的样本$\tilde{x}$预测干净的样本$x$，或者一般的预测条件概率分布$p(x|\tilde{x})$。</li>
<li>密度估计或概率质量函数估计：在密度估计问题中，学习算法学习函数$p<em>{model}:\mathbb{R}^n \rightarrow \mathbb{R}$，其中$p</em>{model}(x)$可以解释成样本采样空间的概率密度函数（$x$是连续的）或者概率质量函数（$x$是离散的）。</li>
</ul>
<h3 id="性能度量P"><a href="#性能度量P" class="headerlink" title="性能度量P"></a>性能度量P</h3><p>性能度量（performance measure）：衡量模型泛化能力的评估标准</p>
<p>回归任务最常用的性能度量是均方误差(mean squared error)</p>
<script type="math/tex; mode=display">
E(f;D)=\frac{1}{m}\sum_{i=1}^m(f(x_i)-y_i)^2</script><p>更一般的，对于数据分布$D$和概率密度函数$p（\cdot）$，均方误差可以描述为</p>
<script type="math/tex; mode=display">
E(f;D) = \int_{x\sim D}(f(x)-y)^2p(x)dx</script><h4 id="错误率和精度"><a href="#错误率和精度" class="headerlink" title="错误率和精度"></a>错误率和精度</h4><p>分类任务中最常用的两种性能度量。</p>
<ul>
<li><p>错误率：分类错误的样本数占样本总数的比例。</p>
<script type="math/tex; mode=display">
E(f;D)=\frac{1}{m}\sum_{i=1}^m\mathbb{I}(f(x_i)\neq y_i) \\
E(f;D)=\frac{1}{m}\int_{x\sim D}\mathbb{I}(f(x)\neq y)p(x)dx</script></li>
<li><p>精度：分类正确的样本数占样本总数的比例。</p>
<script type="math/tex; mode=display">
acc(f;D)=\frac{1}{m}\sum_{i=1}^m\mathbb{I}(f(x_i) = y_i)=1-E(f;D) \\
acc(f;D)=\frac{1}{m}\int_{x\sim D}\mathbb{I}(f(x) = y)p(x)dx=1-E(f;D)</script></li>
</ul>
<h4 id="查准率、查全率和-F1"><a href="#查准率、查全率和-F1" class="headerlink" title="查准率、查全率和$F1$"></a>查准率、查全率和$F1$</h4><p>对于二分类问题，可将样例根据其真实类别与机器学习预测类别的组合化为真正例(true positive)、假正例(false positive)、真反例(true negative)、假反例(false negative)四种情况，令$TP,FP,TN,FN$分别表示其对应的样例数，则有$TP+FP+TN+FN=$样例总数。分类结果可用”混淆矩阵“(confusion matrix)表示。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">预测结果</th>
<th style="text-align:center">预测结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">真实情况</td>
<td style="text-align:center">正例</td>
<td style="text-align:center">反例</td>
</tr>
<tr>
<td style="text-align:center">正例</td>
<td style="text-align:center">$TP$(真正例)</td>
<td style="text-align:center">$FN$ (假反例)</td>
</tr>
<tr>
<td style="text-align:center">反例</td>
<td style="text-align:center">$FP$(假正例)</td>
<td style="text-align:center">$TN$(真反例)</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>查准率$P$</p>
<script type="math/tex; mode=display">
P = \frac{TP}{TP+FP}</script></li>
<li><p>查全率$R$</p>
<script type="math/tex; mode=display">
R = \frac{TP}{TP+FN}</script></li>
<li><p>$P-R$曲线：以查准率为纵轴、查全率为横轴作图。$P-R$图直观地显示出学习器在样本总体上的查全率、查准率。若一个学习器的$P-R$曲线被另一学习器的曲线完全”包住”，则后者的性能优于前者。</p>
</li>
<li><p>”平衡点“(Break-Event Point,BEP)：查准率=查全率 时的取值。BEP高的性能高。</p>
</li>
<li><p>$F1$度量</p>
<script type="math/tex; mode=display">
F1=\frac{2\times P \times R}{P+R}=\frac{2\times TP}{样例总数+TP-TN}</script><blockquote>
<p>$F1$是基于查准率和查全率的调和平均定义的$\frac{1}{F1}=\frac{1}{2}(\frac{1}{P}+\frac{1}{R})$</p>
</blockquote>
</li>
<li><p>更一般的$F_\beta$</p>
<script type="math/tex; mode=display">
F_\beta=\frac{(1+\beta^2 \times P \times R)}{(\beta^2\times P)+R}</script><blockquote>
<p> $F<em>\beta$是基于查准率和查全率的加权调和平均定义的$\frac{1}{F</em>\beta}=\frac{1}{1+\beta^2}(\frac{1}{P}+\frac{\beta^2}{R})$。与算术平均$\frac{P+R}{2}$和几何平均$\sqrt{P\times R}$相比，调和平均更重视较小值。</p>
</blockquote>
<p>​    $\beta \gt 1$查全率影响更大，$\beta \lt 1$查准率影响更大</p>
</li>
</ul>
<h4 id="ROC-和-AUC"><a href="#ROC-和-AUC" class="headerlink" title="$ROC$和$AUC$"></a>$ROC$和$AUC$</h4><ul>
<li>真正例率$(True\;Positive\;Rate,\; TPR)$ == 查全率<script type="math/tex; mode=display">
TPR = \frac{TP}{TP+FN}</script></li>
</ul>
<ul>
<li><p>假正例率$(False\;Positive\;Rate,\; TPR)$ == 反例的查全率</p>
<script type="math/tex; mode=display">
FPR = \frac{FP}{TN+FP}</script></li>
<li><p>$ROC$曲线，$TPR$为$y$轴，$FPR$为$x$轴。$TPR$ 越高，$FPR$ 越小，我们的模型和算法就越高效。几何角度就是$ROC$曲线下的面积越大，模型越优秀，即$AUC(Area\;Under\;Cruve)$</p>
</li>
</ul>
<h3 id="经验E"><a href="#经验E" class="headerlink" title="经验E"></a>经验E</h3><p>数据即经验</p>
<p>根据学习过程中的不同经验，机器学习算法分为无监督和监督算法。</p>
<h2 id="容量、过拟合和欠拟合"><a href="#容量、过拟合和欠拟合" class="headerlink" title="容量、过拟合和欠拟合"></a>容量、过拟合和欠拟合</h2><ul>
<li>泛化：在未观测到的输入上表现良好的能力。</li>
<li>训练误差：训练集上的计算error</li>
<li>决定机器学习算法是否良好的因素<ol>
<li>降低训练误差</li>
<li>缩小训练误差和测试误差的差距</li>
</ol>
</li>
<li>欠拟合$(underfitting)$：模型不能在训练集上获得足够低的误差。</li>
<li>过拟合$(overfitting)$：训练误差和测试误差之间的差距太大。</li>
<li>模型的<strong>容量</strong>$(capacity)$：拟合各种函数的能力。调整容量可以调整模型偏向于过拟合和欠拟合。</li>
<li>容量低的模型可能很难拟合训练集。容量高的模型可能会出现过拟合。</li>
<li>假设空间$(hypothesis\;space)$：即学习算法可以选择为解决方案的函数集。</li>
</ul>
<h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><ul>
<li>正则化：修改学习算法，使其降低泛化误差而非训练误差。<ul>
<li>使用<strong>权重衰减</strong>修改线性回归的训练标准，使其偏好于平方$T^2$范数较小的权重。</li>
</ul>
</li>
</ul>
<h2 id="超参集和验证集"><a href="#超参集和验证集" class="headerlink" title="超参集和验证集"></a>超参集和验证集</h2><ul>
<li>超参数：设置控制算法行为，超参数的值不是通过学习算法本身学习出来的。</li>
<li>验证集：用于挑选超参数的数据子集。Normally, eight percent of trained set is used to train, others are used to validate.</li>
</ul>
<h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h3><ul>
<li>k-折交叉验证：将数据集分成k个不重合的子集。测试误差可以估计为k次计算后的平均测试误差。第i次测试时，数据的第i个子集用于测试集，其他的数据用于训练集。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>激活函数</title>
    <url>/2019/11/01/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h1><h2 id="Sigmoid"><a href="#Sigmoid" class="headerlink" title="Sigmoid"></a>Sigmoid</h2><script type="math/tex; mode=display">
\begin{split}
& f(x) = \frac{1}{1+e^{-x}} \quad x\in R ,\quad f(x)\in (0,1)\\
& f^,(x) = \frac{e^x}{(1+e^{-x})^2} = f(x)(1-f(x)) \quad x\in R \quad f^,(x)\in (0,0.25\rbrack
\end{split}</script><a id="more"></a>
<h2 id="Tanh"><a href="#Tanh" class="headerlink" title="Tanh"></a>Tanh</h2><script type="math/tex; mode=display">
\begin{split}
& tanh(x) = \frac{sinhx}{coshx} = \frac{e^x-e^{-x}}{e^x+e^{-x}} \quad x\in R \quad tanh(x) \in (-1,1) \\
& (tanhx)^, = sech^2x = 1-tanh^2x \quad x\in R \quad (tanhx)^, \in (0,1\rbrack
\end{split}</script><h2 id="ReLu"><a href="#ReLu" class="headerlink" title="ReLu"></a>ReLu</h2><script type="math/tex; mode=display">
f(x) = max(0,x)</script><h2 id="Leaky-ReLu"><a href="#Leaky-ReLu" class="headerlink" title="Leaky ReLu"></a>Leaky ReLu</h2><script type="math/tex; mode=display">
f(x) = max(\alpha x,x) \quad  \alpha << 1, For\;most\;,\alpha = 0.01</script><h2 id="Softplus"><a href="#Softplus" class="headerlink" title="Softplus"></a>Softplus</h2><script type="math/tex; mode=display">
\zeta(x)= \ln(1+e^x)</script><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p>常见的激活函数有：<strong>sigmoid；tanh；ReLU；LReLU, PReLU, RReLU；ELU（Exponential Linear Units）；softplus；softsign,softmax等</strong></p>
<h2 id="Notion"><a href="#Notion" class="headerlink" title="Notion"></a>Notion</h2><ul>
<li>饱和：当激活函数趋于无穷，gradient 趋于 0。导致梯度消失</li>
</ul>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><ul>
<li>sigmoid 激活函数:除了输出层是一个二分类问题基本不会用它。</li>
<li>tanh 激活函数:tanh 是非常优秀的,几乎适合所有场合。</li>
<li>ReLu 激活函数:最常用的默认函数,,如果不确定用哪个激活函数,就使用 ReLu 或者Leaky ReLu。</li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
  </entry>
  <entry>
    <title>知识图谱</title>
    <url>/2020/05/08/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/</url>
    <content><![CDATA[<h1 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h1><h2 id="知识表示学习"><a href="#知识表示学习" class="headerlink" title="知识表示学习"></a>知识表示学习</h2><p>表示学习：将<strong>研究对象</strong>的语义信息表示为稠密低维的实值向量。</p>
<p>研究对象：文字（词汇、短语、句子、文章）、图片、语音等</p>
<p>知识表示学习：将知识库中的实体和关系表示为稠密低维的实值向量。</p>
<p>知识图谱中包含实体和关系，其中节点表示实体，连边代表关系。</p>
<p>知识通常用三元组表示：（head,relation,tail）</p>
<a id="more"></a>
<p>知识表示学习的意义</p>
<ul>
<li>低维向量提高计算效率</li>
<li>稠密向量缓解数据稀疏</li>
<li>多源的异质信息表示形式统一，便于迁移和融合。</li>
</ul>
<h3 id="知识表示学习的代表模型"><a href="#知识表示学习的代表模型" class="headerlink" title="知识表示学习的代表模型"></a>知识表示学习的代表模型</h3><h3 id="基于距离的模型"><a href="#基于距离的模型" class="headerlink" title="基于距离的模型"></a>基于距离的模型</h3><ol>
<li><p>基于距离的模型——UM</p>
<p>利用头实体和尾实体的共现信息，忽略它们之间的关系。</p>
<p>得分函数为：</p>
<script type="math/tex; mode=display">
f(h,r,t) = -||h-t||_{l1/l2}</script><p>Bordes A, Glorot X, Weston J, et al. Joint learning of words and meaning representations for open-text semantic parsing. Artificial Intelligence and Statistics. 2012: 127-135.</p>
</li>
<li><p>基于距离的模型——SE</p>
<p>和UM比较，SE添加了关系信息：将关系建模为分别针对头实体和尾实体的矩阵，得分函数为：</p>
<script type="math/tex; mode=display">
f(h,r,t) = - ||M_r^hh-M_r^tt||_{l1/l2}</script><p>Bordes A, Weston J, Collobert R, et al. Learning structured embeddings of knowledge bases. AAAI. 2011.</p>
</li>
</ol>
<h3 id="基于翻译的模型"><a href="#基于翻译的模型" class="headerlink" title="基于翻译的模型"></a>基于翻译的模型</h3><ol>
<li><p>基于翻译的模型——TransE</p>
<p>将每条知识(head,relation,tail)中的relation看成从head到tail的翻译操作。</p>
<script type="math/tex; mode=display">
f(h,r,t) = ||h+r-t||_{l1/l2}</script><p>例如：</p>
<p>（北京，是…的首都，中国）</p>
<p>（华盛顿，是…的首都，美国）</p>
</li>
</ol>
<script type="math/tex; mode=display">
   L=\sum_{\xi \in T}\sum_{\xi' \in T'} [\gamma + f(\xi) - f(\xi')]_{+}</script><blockquote>
<p>我的理解，这个损失函数应该采用了负采样，$\xi$表示正例，$\xi’$表示负例，求损失函数的最小值。</p>
</blockquote>
<p>   TransE的缺点：无法处理复杂关系，比如1-N，N-1,N-N关系。</p>
<p>   例如：（奥巴马，是…总统，美国）、（布什，是…总统，美国）,在TransE中，奥巴马和布什的向量会变的相同。</p>
<p>   Bordes A, Usunier N, Garcia-Duran A, et al. Translating embeddings for modeling multi-relational data. NIPS2013: 2787-2795</p>
<ol>
<li><p>基于翻译的模型——TransH</p>
<p>为了解决TransE的问题，TransH将每种关系建模为一个超平面，将三元组中的头实体和尾实体分别映射到超平面上。</p>
<p>得分函数为：</p>
<script type="math/tex; mode=display">
\begin{align}
& h_{\perp} = h-w_r^Thw_r,\quad t_{\perp} = t - w_r^Ttw_r \\
& f(h,r,t) = - ||h_{\perp}+r-t_{\perp}||_{l1/l2}
\end{align}</script><p>Wang Z, Zhang J, Feng J, et al. Knowledge graph embedding by translating on hyperplanes. AAAI2014</p>
</li>
<li><p>基于翻译的模型——TransR/CTransR</p>
<p>TransE和TransH将实体和关系嵌入到同一个向量空间。</p>
<p>TransR表示不同的关系应该嵌入不同的语义空间，将关系嵌入为矩阵，将实体映射到关系子空间中</p>
<p>CTransR将属于同一种关系的头尾实体对分成聚成多个类，针对每个类学习不同的关系矩阵。</p>
<script type="math/tex; mode=display">h_{\perp} = hM_r,\quad t_{\perp} = tM_r</script><p>Lin Y, Liu Z, Sun M, et al. Learning entity and relation embeddings for knowledge graph completion. AAAI2015.</p>
</li>
<li><p>基于翻译的模型——TransD</p>
<p>TransH和TransR/CTransR中，不同种类的实体共享相同的映射向量或矩阵，但一个关系的头尾实体的种类和属性往往具有较大差别。</p>
<p>TransR引入了空间映射，但是也产生了大量的模型参数。</p>
<p>TransD则将每个对象（实体、关系）嵌入为两个向量：语义向量、映射向量。</p>
<script type="math/tex; mode=display">
\begin{align}
& M_r^h=r_ph_p^T+I^{k*d},\quad M_r^t = r_pt_p^T+I^{k*d} \\
& h_{\perp} = M_r^hh,\quad t_{\perp} = M_r^tt
\end{align}</script><p>Ji G, He S, Xu L, et al. Knowledge graph embedding via dynamic mapping matrix. ACL2015: 687-696</p>
</li>
<li><p>基于翻译的模型——TranSparse</p>
<p>为了克服关系的<strong>异质性</strong>（有的关系连接的头尾实体对较多，有的较少）和<strong>不平衡性</strong>（同一关系的头实体和尾实体的数量不对称），TranSparse（share/separate）用自适应的稀疏矩阵代替一般的映射矩阵，稀疏度由关系连接的头尾实体对的数量决定。</p>
<script type="math/tex; mode=display">
\begin{align}
& h_{\perp} = M_r(\theta_r)h,\quad t_{\perp} = M_r(\theta_r)t \\
& h_{\perp} = M_r^h(\theta_r^h)h,\quad t_{\perp} = M_r^t(\theta_r^t)t
\end{align}</script><p>Ji G, Liu K, He S, et al. Knowledge graph completion with adaptive sparse transfer matrix. AAAI. 2016</p>
</li>
<li><p>基于翻译的模型——TransM</p>
<p>TransM对前面几种模型的基础条件进行了放宽，即$h+r \approx t$。方法是在前面得分函数的基础上增加了权重：</p>
<script type="math/tex; mode=display">
w_r = \frac{1}{\log (h_rpt_r + t_rph_r)}</script><p>Fan M, Zhou Q, Chang E, et al. Transition-based knowledge graph embedding with relational mapping properties. Proceedings of the 28th Pacific Asia Conference on Language, Information and Computing. 2014</p>
</li>
<li><p>基于翻译的模型——ManiFoldE</p>
<p>ManiFoldE将约束$h+r \approx t$放宽为一种基本流形的约束，得分函数为：</p>
<script type="math/tex; mode=display">
\begin{align}
& f(h,r,t) = ||M(h,r,t) - D_r^2||_{l1/l2} \\
& M(h,r,t) = |||h+r-t|_{l2}
\end{align}</script><p>$M()$是一个流形，以(h,r,<em>)为例，所有合适的尾实体都分布在高维流形上，例如$M()$是一个高维球体，那么所有的\</em>都在以$h+r$为球心，以$D_r$为半径的球面上。</p>
<p>Xiao H, Huang M, Zhu X. From one point to a manifold: Knowledge graph embedding for precise link prediction. arXiv preprint arXiv:1512.04792, 2015</p>
</li>
<li><p>基于翻译的模型——TransF</p>
<p>TransF将约束$h+r \approx t$放宽为：只要求$h+r \;or\;t-r$的方向与$t\;or\;h$一致。得分函数同时衡量了$h+r$和$t$,$t-r$和$h$的方向：</p>
<script type="math/tex; mode=display">
f(h,r,t) = (h+r)^Tt+(t-r)^Th</script><p>Feng J, Huang M, Wang M, et al. Knowledge graph embedding by flexible translation. Fifteenth International Conference on the Principles of Knowledge Representation and Reasoning. 2016.</p>
</li>
<li><p>基于翻译的模型——TransA</p>
<p>TransE及其扩展模型的两个问题：</p>
<ul>
<li>得分函数采用L1或L2距离，灵活度不够</li>
<li>损失函数过于简单，实体和关系向量的每一维等同考虑。</li>
</ul>
<p>TransA将损失函数中的距离度量改成马式距离，并为每一维学习不同的权重，$W_r$是非负对矩阵。</p>
<script type="math/tex; mode=display">
f(h,r,t) = (h+r-t)^TW_r(h+r-t)</script><blockquote>
<p>看起来像二次型那块的公式</p>
</blockquote>
<p>Xiao H, Huang M, Hao Y, et al. TransA: An adaptive approach for knowledge graph embedding. arXiv preprint arXiv:1509.05490, 2015</p>
</li>
<li><p>基于翻译的模型——KG2E</p>
<p>KG2E使用高斯分布来表示实体和关系。高斯分布的均值表示实体或关系在语义空间的中心位置，而高斯分布的协方差则表示实体或关系的不确定度。</p>
<ul>
<li>头尾实体间的关系的概率分布：<script type="math/tex; mode=display">
P_e \sim N(h-t,\sum_h+\sum_t)</script></li>
</ul>
</li>
</ol>
<ul>
<li><p>实际关系的概率分布</p>
<script type="math/tex; mode=display">
    P_r \sim N(r,\sum_r)</script><ul>
<li><p>损失函数：KL散度/期望概率(计算上述两个概率的相似度)</p>
<p><a href="https://www.jianshu.com/p/43318a3dc715?isappinstalled=0" target="_blank" rel="noopener">https://www.jianshu.com/p/43318a3dc715?isappinstalled=0</a></p>
<script type="math/tex; mode=display">
    D_{KL}(P_e||P_r) = \sum_{i=1}^N P_e(x_i)\cdot(\log P_e(x_i)-\log P_r(x_i))</script><p>  He S, Liu K, Ji G, et al. Learning to represent knowledge graphs with gaussian embedding. Proceedings of the 24th ACM International on Conference on Information and Knowledge Management. ACM, 2015: 623-632.</p>
</li>
</ul>
</li>
</ul>
<ol>
<li><p>基于翻译的模型——TransG</p>
<p>也使用高斯分布来表示实体和关系，但认为一个关系连接不同的头尾实体时拥有不同的语义。所以关系的分布是高斯分布的混合。</p>
<script type="math/tex; mode=display">
\begin{align}
& h \sim N(\mu_h,\sigma_h^2I),\quad t \sim N(\mu_t,\sigma_t^2I) \\
& r = \sum_i \pi_r^i\mu_r^i,\quad \mu_r^i \sim N(\mu_h-\mu_t,(\sigma_h^2+\sigma_t^2)I)
\end{align}</script><p>得分函数：</p>
<script type="math/tex; mode=display">
f(h,r,t) = \sum_i\pi_r^i \exp(\frac{-||\mu_h+\mu_r^i-\mu_t||_{l2}}{\sigma_h^2+\sigma_t^2})</script><p>Xiao H, Huang M, Zhu X. TransG: A generative model for knowledge graph embedding. Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers). 2016, 1: 2316-2325.</p>
</li>
</ol>
<h2 id="语义匹配模型"><a href="#语义匹配模型" class="headerlink" title="语义匹配模型"></a>语义匹配模型</h2><ol>
<li><p>LFM （Latent Factor Model）</p>
<p>LFM利用基于关系的双线性变换，刻画实体和关系之间的二阶联系。协同性较好，计算复杂度低，得分函数：</p>
<script type="math/tex; mode=display">
f(h,r,t) = h^TM_rt</script><p>Jenatton R, Roux N L, Bordes A, et al. A latent factor model for highly multirelational data. NIPS. 2012: 3167-3175.</p>
</li>
<li><p>DistMult</p>
<p>DistMult将LFM中关系的表示矩阵限制为对角阵，极大降低了模型复杂度，模型效果反而得到显著提升。</p>
<script type="math/tex; mode=display">
f(h,r,t) = h^Tdiag(M_r)t</script><p>Yang B, Yih W, He X, et al. Embedding entities and relations for learning and inference in knowledge bases. arXiv preprint arXiv:1412.6575, 2014</p>
</li>
<li><p>ComplEx</p>
<p>为了更好的对非对称关系建模，ComplEx将DistMult中实体和关系的表示扩展到复数向量空间中，即向量的每一维都是复数，而不在是实数。    得分函数如下，$Re(x)$是取x的实部。</p>
<script type="math/tex; mode=display">
f(h,r,t) = Re(h^Tdiag(M_r)t)</script><p>Trouillon T, Welbl J, Riedel S, et al. Complex embeddings for simple link prediction. International Conference on Machine Learning. 2016: 2071-208</p>
</li>
<li><p>ANALOGY</p>
<p>ANALOGY对知识图谱中的类比关系进行建模。例如：太阳系中的太阳之于行星，原子系统中的原子核之于核外电子。</p>
<p>得分函数同LFM:</p>
<script type="math/tex; mode=display">
f(h,r,t) = h^TM_rt</script><p>约束条件：</p>
<ul>
<li>正规性：$M_rM_r^T=M_r^TM_r$，如：对称矩阵可以对对称关系建模（好友关系），负对称矩阵对非对称关系建模（父子关系）</li>
<li>交换性：$M<em>rM</em>{r’}=M<em>{r’}M</em>{r}$</li>
</ul>
<p>Liu H, Wu Y, Yang Y. Analogical inference for multi-relational embeddings. Proceedings of the 34th International Conference on Machine Learning-Volume JMLR. org, 2017: 2168-2178.</p>
</li>
<li><p>RESCAL</p>
<p>RESCAL是矩阵分解模型的典型代表。在该模型中，知识图谱中的所有实体对和所有关系构成一个张量$\mathbf{X}$，如果三元组（h,r,t）存在，则$X_{hrt}=1$，否则为0。</p>
<p>张量分解旨在将每个三元组（h,r,t）分解为实体和关系表示$X<em>{hrt}=h^tM_rt$，使得$X</em>{hrt}$尽量接近1。</p>
<p>RESCAL的基本思想和LFM类似，不同的是，RESCAL会优化张量中的所有位置，包括值为0的位置，而LFM只优化知识图谱中存在的三元组。</p>
<p>Nickel M, Tresp V, Kriegel H P. A Three-Way Model for Collective Learning on Multi-Relational Data. ICML. 2011, 11: 809-816.</p>
</li>
<li><p>HolE</p>
<p>HolE定义了一种循环相关的操作，更好的捕捉实体间的语义关联。</p>
<ul>
<li>循环相关操作定义：<script type="math/tex; mode=display">
[h\otimes t]_k = \sum_{i=0}^{d-1} [h]_i*[t]_{(i+k)\mod d}</script></li>
</ul>
</li>
</ol>
<ul>
<li>得分函数：<script type="math/tex; mode=display">
   f(h,r,t) = r^T((h\otimes t) = \sum_{k=0}^{d-1}([r]_k\sum_{i=0}^{d-1} [h]_i*[t]_{(i+k)\mod d}))</script></li>
</ul>
<p>Nickel M, Rosasco L, Poggio T. Holographic embeddings of knowledge graphs. AAAI. 2016.</p>
<ol>
<li><p>SLM</p>
<p>SLM利用标准非线性单层神经网络来连接尸体</p>
<p>得分函数：</p>
<script type="math/tex; mode=display">
f(h,r,t) = u_r^T \tanh(M_r^hh+M_r^tt)</script><p>Socher R, Chen D, Manning C D, et al. Reasoning with neural tensor networks for knowledge base completion. NIPS. 2013: 926-93</p>
</li>
<li><p>SME</p>
<p>SME利用神经网络结构，为三元组设计了两种得分函数：</p>
<ul>
<li>线性形式：<script type="math/tex; mode=display">
f(h,r,t) = (M_1h+M_2r+b_1)^T(M_3t+M_4r+b_2)</script></li>
</ul>
</li>
</ol>
<ul>
<li>双线性形式：<script type="math/tex; mode=display">
   f(h,r,t) = (M_1h\otimes M_2r+b_1)^T(M_3t\otimes M_4r+b_2)</script></li>
</ul>
<p>Bordes A, Glorot X, Weston J, et al. A semantic matching energy function for learning with multi-relational data. Machine Learning, 2014, 94(2): 233-259.</p>
<ol>
<li><p>NTN</p>
<p>NTN用张量网络捕获头尾实体间的语义关联，得分函数：</p>
<script type="math/tex; mode=display">
f(h,r,t) = u_r^T \tanh \bigg(h^TM_rt+V_r \tbinom{h}{t}+b_r\bigg)</script><p>$u_r$是与关系相关的线性层，$M_r$是所有关系共享的三阶张量，$V_r$是与关系相关的投影举证。</p>
<p>Socher R, Chen D, Manning C D, et al. Reasoning with neural tensor networks for knowledge base completion. NIPS. 2013: 926-934.</p>
</li>
<li><p>MLP</p>
<p>MLP使用标准的多层神经网络捕获头尾实体间的语义关联，得分函数：</p>
<script type="math/tex; mode=display">
f(h,r,t) = w_r^T \tanh(M_r\cdot(h,r,t))</script><p>$M_r$是与关系相关的第一层神经网络的权重，$w_r$是与关系相关的第二层神经网络的权重，二者为所有关系共享。</p>
<p>Dong X, Gabrilovich E, Heitz G, et al. Knowledge vault: A web-scale approach to probabilistic knowledge fusion. Proceedings of the 20th ACM SIGKDD international conference on Knowledge discovery and data mining. ACM, 2014: 601-610.</p>
</li>
<li><p>NAM</p>
<p>NAM使用1+L层DNN捕获头尾实体间的语义关联：</p>
<script type="math/tex; mode=display">
\begin{align}
& a^{(l)} =W^{(l)}z^{(l-1)} + b^{(l)},\quad l=1,\dots,L \\
& z^{(l)} = ReLU(a^{(l)}),\quad l=1,\dots,L
\end{align}</script><p>$(h;r)$作为输入，即$z^0$</p>
<p>得分函数：</p>
<script type="math/tex; mode=display">
f(h,r,t) = \sigma(z^{(L)}\cdot t)</script><p>NAM为复杂关系设计了神经网络</p>
<p>RMNN（relation-modulated neural networks）:</p>
<script type="math/tex; mode=display">
\begin{align}
& a^{(l)} = W^{(l)}z^{(l-1)}+B^{(l)}r,\quad l=1,\dots,L \\
& z^{(l)} = ReLU(a^{(l)}),l=1,\dots,L
\end{align}</script><p>$h$作为输入，即$z^0$</p>
<p>得分函数：</p>
<script type="math/tex; mode=display">
f(h,r,t) = \sigma(z^{(L)} \cdot t + B^{(L+1)}r)</script></li>
</ol>
<pre><code>Liu Q, Jiang H, Evdokimov A, et al. Probabilistic reasoning via deep learning: Neural association models. arXiv preprint arXiv:1603.07704, 2016.
</code></pre><ol>
<li><p>ConvE</p>
<p>ConvE利用卷积神经网络捕获实体间的语义关联：</p>
<script type="math/tex; mode=display">
f(h,r,t) = \sigma((vec([\bar{h};\bar r]\cdot w) W)t)</script><p>$w$是卷积核(多个)，$W$是映射矩阵</p>
<p>Dettmers T, Minervini P, Stenetorp P, et al. Convolutional 2d knowledge graph embeddings. AAAI. 2018.</p>
</li>
</ol>
<h3 id="融合多源信息的模型"><a href="#融合多源信息的模型" class="headerlink" title="融合多源信息的模型"></a>融合多源信息的模型</h3><p>实体类别信息：SSE、TKRL</p>
<ul>
<li>Guo S, Wang Q, Wang B, et al. Semantically smooth knowledge graph embedding. Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing (Volume 1: Long Papers). 2015, 1: 84-94.</li>
<li>Xie R, Liu Z, Sun M. Representation Learning of Knowledge Graphs with Hierarchical Types. IJCAI. 2016: 2965-2971.</li>
</ul>
<p>关系路径</p>
<p>PTransE 在 TransE的基础上加入了实体对间的路径信息，得分函数为：</p>
<script type="math/tex; mode=display">
\begin{align}
& f(h,r,t) = E(h,r,t) + E(h,P,t) \\
& E(h,r,t) = ||h+r-t|| \\
& E(h,P,t) = \frac{1}{Z} \sum_{p \in P(h,t)} R(p|h,t)E(h,p,t)\\
& E(h,p,t) = ||h+p-t|| = ||p-(t-h)|| = ||p-r|| = E(p,r)
\end{align}</script><p>由于实体对间的所以路径都是可靠的，因此，PtransE提出了Path-Contraint Resource Allocation图算法度量关系路径的可靠性。$R(p|h,t)$表示从h经过路径p，t所获得的资源数量。</p>
<p>Lin Y, Liu Z, Luan H, et al. Modeling relation paths for representation learning of knowledge bases. arXiv preprint arXiv:1506.00379, 2015</p>
<p>文本描述信息</p>
<p>NTN</p>
<p>Socher R, Chen D, Manning C D, et al. Reasoning with neural tensor networks for knowledge base completion. NIPS. 2013: 926-934.</p>
<p>DKRL</p>
<p>Xie R, Liu Z, Jia J, et al. Representation learning of knowledge graphs with<br>entity descriptions. AAAI. 2016</p>
<p>TEKE</p>
<p>Wang Z, Li J Z. Text-Enhanced Representation Learning for Knowledge Graph. IJCAI. 2016: 1293-1299</p>
<p>逻辑规则</p>
<p>ILP Integer Linear Programming</p>
<p>Wang Q, Wang B, Guo L. Knowledge base completion using embeddings and<br>rules. IJCAI. 2015</p>
<p>KALE</p>
<p>Guo S, Wang Q, Wang L, et al. Jointly embedding knowledge graphs and<br>logical rules. EMNLP. 2016: 192-202.</p>
<p>PUGE</p>
<p>Guo S, Wang Q, Wang L, et al. Knowledge graph embedding with iterative<br>guidance from soft rules. AAAI. 2018</p>
<p>实体属性信息</p>
<p>Nickel M, Tresp V, Kriegel H P. Factorizing yago: scalable machine learning for linked data. WWW. 2012: 271-280.</p>
<p>时序信息</p>
<p>Jiang T, Liu T, Ge T, et al. Encoding temporal information for time-aware link<br>prediction. EMNLP. 2016: 2350-2354.</p>
<p>图结构</p>
<p>GAKE</p>
<p>Feng J, Huang M, Yang Y. GAKE: graph aware knowledge embedding. COLING. 2016: 641-651</p>
<h3 id="较新成果"><a href="#较新成果" class="headerlink" title="较新成果"></a>较新成果</h3><ol>
<li><p>TransC</p>
<p>TransC将知识图谱中的实例和概念区别对待：实例嵌入为向量，概念嵌入为球体。用点和球、球和球之间的相对位置关系对instanceOf和subClassOf两种关系建模，普通关系采用TransE模型。</p>
</li>
</ol>
<script type="math/tex; mode=display">
\begin{align}
& f_e(i,c) = ||i-p||_2-m \\
& d = ||p_i-p_j||_2
\end{align}</script><p>​                    Lv X, Hou L, Li J, et al. Differentiating Concepts and Instances for Knowledge Graph Embedding.EMNLP. 2018: 1971-1979.</p>
<ol>
<li><p>TransN</p>
<p>利用实体在知识图谱中的邻居节点，将实体和关系分别嵌入为两种向量：</p>
<ul>
<li>语义向量：用于表示实体或关系的语义</li>
<li>上下文向量：用于表示其他实体或关系的上下文</li>
</ul>
<p>TransN选择邻居节点（实体关系对）</p>
<ul>
<li>利用实体的邻居总数动态计算所选邻居的数量</li>
<li>利用关系间的相似度动态计算邻居节点的权重</li>
</ul>
<p>Wang C C, Cheng P J. Translating Representations of Knowledge Graphs with Neighbors. SIGIR. 2018: 917-920</p>
</li>
<li><p>GAN-based Framework</p>
<p>利用生成对抗网络中的生成器进行高质量的负采样，用鉴别器计算reward和进行表示学习。</p>
<p>Wang P, Li S, Pan R. Incorporating GAN for negative sampling in knowledge representation learning. AAAI. 2018.</p>
</li>
</ol>
<h3 id="模型评测"><a href="#模型评测" class="headerlink" title="模型评测"></a>模型评测</h3><ol>
<li><p>常用数据集</p>
<ul>
<li>WordNet是著名的词典知识库，主要用于词义消歧。主要定义了名词、动词、形容词和副词之间的语义关系。例如名词之间的上下位关系（如 猫科动物是猫的上位词）、动词之间额蕴含关系（如 打鼾蕴含睡眠）等。</li>
<li>Freebase将WordNet和Wikipedia进行了结合，用WordNet的本体知识补充Wikipedia中实体的上下位知识。其数据基于RDF三元组模型，底层采用图数据库进行存储。</li>
<li>YAGO是一个综合型知识库，整合了Wikipedia、WordNet和GeoNames等数据源</li>
<li>其他常用数据集，WN11,WN18,FB13,FB15K,FB1M,FB5M</li>
</ul>
</li>
<li><p>链接预测</p>
<p>指预测含有普通关系的三元组中丢失的头实体或尾实体。预测结果是候选实例根据损失值排名的清单，而不直接给出最匹配实例。</p>
<p>评测标准一般两种：</p>
<ul>
<li>MRR：所有正确实例排名的倒数的平均值;</li>
<li>Hists@N：正确实例的排名中不大于N的比例</li>
</ul>
</li>
<li><p>三元组分类</p>
<p>知识图谱中的三元组分类表示一个二分类问题，其是判断给定的三元组是否是知识图谱中真实存在的。</p>
<p>评测标准：Accuracy、Precision、Recall和F1</p>
</li>
</ol>
<h3 id="知识表示学习应用"><a href="#知识表示学习应用" class="headerlink" title="知识表示学习应用"></a>知识表示学习应用</h3><ol>
<li><p>知识融合</p>
<p>Sun Z., Hu W., Li C. Cross-lingual Entity Alignment via Joint Attribute-Preserving EmbeddingISWC2017</p>
</li>
<li><p>人机交互</p>
<p>Commonsense Knowledge Aware Conversation Generation with Graph<br>Attention. IJCAI 2018</p>
</li>
</ol>
<h2 id="知识抽取"><a href="#知识抽取" class="headerlink" title="知识抽取"></a>知识抽取</h2><h3 id="问题和方法"><a href="#问题和方法" class="headerlink" title="问题和方法"></a>问题和方法</h3><p>场景（数据源）</p>
<ul>
<li>（半）结构化文本数据：百科知识中的Inforbox、规范的表格、数据库、社交网络等</li>
<li>非结构化文本数据：网页、新闻、社交媒体、论文等</li>
<li>多媒体数据：图片、视频</li>
</ul>
<p>信息抽取和知识抽取</p>
<ul>
<li>区别：信息抽取获得结构化数据，知识抽取获得机器可理解和处理的知识（知识表示）</li>
<li>关系：知识抽取建立在信息抽取的基础上，都普遍用到自然语言处理技术、基于规则的包装器和机器学习等技术。</li>
</ul>
<p>知识抽取挑战</p>
<ul>
<li>知识的不明确性 ambiguous</li>
<li>知识的不完备性 incomplete 关系、标签/属性、实体等缺失</li>
<li>知识的不一致性 inconsistent</li>
</ul>
<h3 id="知识抽取场景和方法"><a href="#知识抽取场景和方法" class="headerlink" title="知识抽取场景和方法"></a>知识抽取场景和方法</h3><ol>
<li><p>从关系数据库中抽取知识</p>
<p>抽取原理</p>
<ul>
<li>表 Table ——类 Class</li>
<li>列 Column ——属性 Property</li>
<li>行 Row —— 资源/实例 Resource/Instance</li>
<li>单元 Cell ——属性值 Property Value</li>
<li>外键 Foreign Key ——指代 Reference</li>
</ul>
<p>根据上面的规则将关系性数据库转化为一个知识库</p>
<p>抽取标准</p>
<ul>
<li>Direct Mapping</li>
<li>R2RML</li>
</ul>
<p>抽取工具</p>
<ul>
<li>D2R,Virtuoso,Orcle SW, Morph ….</li>
</ul>
<p>R2RML映射语言</p>
<ul>
<li>输入：数据库表、视图、SQL查询</li>
<li>输出：三元组</li>
</ul>
<p>一共四个步骤：抽取类-&gt;抽取属性-&gt;抽取实例-&gt;建立类之间的关系</p>
<p>优点：转换规则简单，易于实现</p>
<p>缺点：</p>
<ul>
<li>直接转换得到的知识库语义信息不足</li>
<li>需要熟悉原数据库设计的专家辅助进行知识库的优化</li>
</ul>
</li>
<li><p>百科知识的抽取</p>
<ul>
<li>大规模多语言百科知识图谱，维基百科的结构化版本，linked data核心数据集</li>
<li>覆盖127中语言，两千八百万个实体，数亿三元组，支持数据集的完全下载</li>
<li>固定模式对实体信息进行抽取，包括abstract、infobox、category、page link等</li>
</ul>
</li>
<li><p>无结构化数据的知识抽取</p>
<p>问题：当前知识图谱构建的技术瓶颈</p>
<p>关键技术：实体识别、关系抽取、事件抽取</p>
<ul>
<li><p>实体识别：抽取文本中的原子信息，例如人名、组织/机构、地理位置、时间/日期、字符、金额等等</p>
</li>
<li><p>关系抽取：抽取实体间的语义关系</p>
</li>
<li>事件抽取<ul>
<li>事件定义：具有时间、地点、参与者等基本元素，可由某个动作触发或状态改变而发生的一个图结构知识片段</li>
<li>从数据中抽取事件信息，并以结构化和语义化形式展现，例如事件发生的时间、地点、原因、参与者等。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><p>爬虫的原理：</p>
<ol>
<li>获取目标数据的URL；</li>
<li>向对应URL提交HTTP请求；</li>
<li>解析HTTP响应；</li>
<li>存储解析结果。</li>
</ol>
<p>请求和响应：使用Python requests</p>
<ol>
<li>向目标URL发出不同种类的HTTP请求（GET、POST、DELETE的等）；</li>
<li>定制HTTP请求的头部，设置User-Agent和Cookie；</li>
<li>使用代理（proxy）进行请求；</li>
<li>对HTTP响应进行解析，获取状态码和文本字段。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">'http://www.baidu.com'</span></span><br><span class="line">r = requests.get(url)</span><br><span class="line">print(r.status_code)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure>
<p>数据解析</p>
<ul>
<li>Beautiful Soup 提供对HTML文本进行解析，出了自带的解析库，还支持使用lxml和html.parser</li>
<li>lxml是使用C语言编写的HTML和XML解析库，因此速度非常快</li>
<li>html.parser是Python自带的HTML解析器</li>
<li>正则表达式，对标签内容进行抽取</li>
</ul>
<p>多进程并发爬取</p>
<ul>
<li><p>Python内置的multiprocessing库提供了进程池类Pool，可以实现多进程并发爬取</p>
</li>
<li><p>Pool类的构造函数接收一个整型参数，代表进程池的大小，即并发工作进程的最大个数，默认值为计算机的CPU个数</p>
</li>
<li><p>Pool常用方法</p>
<ol>
<li><p><code>apply_async(func, args,callback, error_back)</code></p>
<p>将爬取进程添加到进程池中，并发知行。func维并发执行的函数名，args为func函数的参数列表，callback和error_callback是进程正常退出和异常退出时调用的回调函数。用于处理程序执行结构。</p>
</li>
<li><p><code>close()</code></p>
<p>关闭进程池，不能加入新的进程，用于所有进程都提交进入进程池里的时候。</p>
</li>
<li><p><code>join()</code></p>
<p>将主进程挂起，等待所有子进程执行完毕，close()必须在join()方法之前调用。</p>
</li>
</ol>
</li>
<li><p>使用回调函数或者try/except语句捕获子进程异常，否则子进程异常退出时不显示任何信息</p>
</li>
</ul>
<p>反爬虫机制</p>
<ul>
<li><p>大多数网站都由反爬虫机制，常见的有：</p>
<ul>
<li>验证HTTP请求头</li>
<li>基于用户行为的反爬虫机制</li>
</ul>
</li>
<li><p>反爬机制1原理</p>
<p>在每个HTTP请求的头部包含一些关于请求的附加信息，比如User-Agent、referer、cookie。绝大多数网站都会查看User-Agent字段。</p>
</li>
<li><p>反爬机制1应对</p>
<p>在发起HTTP请求，在请求头加入定制的信息。</p>
</li>
<li><p>反爬机制2原理</p>
<ol>
<li>拒绝同IP地址短期内发起大量请求，响应码维HTTP429</li>
<li>对一段时间内网站后台日志进行分析，对访问次数异常多的IP加入“黑名单”</li>
</ol>
</li>
<li><p>反爬机制2应对</p>
<ol>
<li>应对短时间内拒绝情况，可以间隔一段时间再请求</li>
<li>使用Selenium模拟人的行为，使用浏览器请求。</li>
<li>最方便的方式使用proxy server对目标网站进行请求。</li>
</ol>
</li>
</ul>
<p>百科页面爬取</p>
<p>微软学术数据爬取</p>
<ul>
<li>通过API获取</li>
</ul>
<p>微博数据爬取</p>
<ul>
<li><p>爬取入口</p>
<p>网页端、wap端</p>
<p>对于数据全面性不高的时候，或构建语料库时，建议爬取wap端。</p>
</li>
<li><p>处理用户登陆</p>
<ul>
<li>微博需要用户登陆才能访问，网页中的cookie会自动保留登陆信息</li>
<li>方案一：用网页端微博获取cookies数据，传入爬虫数据。</li>
<li>方案二：编写自动登陆脚本，自动获取cookies（由大量账号时）</li>
<li>小规模爬取，手动传入cookies比较方便</li>
</ul>
</li>
</ul>
<p>GitHun数据获取</p>
<ul>
<li>方案一：直接对网站页面进行请求，但是容易倍网站拒绝 429</li>
<li>方案二：使用GitHub提供的REST API和GRAPH API请求数据</li>
<li>方案三：GHTorrent项目</li>
</ul>
<h2 id="命名实体识别-Named-Entity-Recognition"><a href="#命名实体识别-Named-Entity-Recognition" class="headerlink" title="命名实体识别 Named Entity Recognition"></a>命名实体识别 Named Entity Recognition</h2><p>实体识别的任务是识别出文本中三大类命名实体：实体类、实践类、数字类。</p>
<p>序列标注体系</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Token</th>
<th style="text-align:center">IO</th>
<th style="text-align:center">BIO</th>
<th>BIOES</th>
<th style="text-align:center">BMEWO</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">特</td>
<td style="text-align:center">I-PER</td>
<td style="text-align:center">B-PER</td>
<td>B-PER</td>
<td style="text-align:center">B-PER</td>
</tr>
<tr>
<td style="text-align:center">朗</td>
<td style="text-align:center">I-PER</td>
<td style="text-align:center">I-PER</td>
<td>I-PER</td>
<td style="text-align:center">M-PER</td>
</tr>
<tr>
<td style="text-align:center">普</td>
<td style="text-align:center">I-PER</td>
<td style="text-align:center">I-PER</td>
<td>E-PER</td>
<td style="text-align:center">E-PER</td>
</tr>
<tr>
<td style="text-align:center">在</td>
<td style="text-align:center">O</td>
<td style="text-align:center">O</td>
<td>O</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">白</td>
<td style="text-align:center">I-LOC</td>
<td style="text-align:center">B-LOC</td>
<td>B-LOC</td>
<td style="text-align:center">B-LOC</td>
</tr>
<tr>
<td style="text-align:center">宫</td>
<td style="text-align:center">I-LOC</td>
<td style="text-align:center">I-LOC</td>
<td>E-LOC</td>
<td style="text-align:center">E-LOC</td>
</tr>
<tr>
<td style="text-align:center">签</td>
<td style="text-align:center">O</td>
<td style="text-align:center">O</td>
<td>O</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">署</td>
<td style="text-align:center">O</td>
<td style="text-align:center">O</td>
<td>O</td>
<td style="text-align:center">O</td>
</tr>
</tbody>
</table>
</div>
<h3 id="基于规则和词典的实体识别"><a href="#基于规则和词典的实体识别" class="headerlink" title="基于规则和词典的实体识别"></a>基于规则和词典的实体识别</h3><p>流程</p>
<ol>
<li>预处理<ol>
<li>划分句子</li>
<li>分词+词性标注</li>
<li>构建词典</li>
</ol>
</li>
<li>识别实体边界<ol>
<li>初始化边界：词典匹配、拼写规则、特殊字符、特征词和标点符号等</li>
</ol>
</li>
<li>命名实体分类<ol>
<li>使用分类规则</li>
<li>基于词典的分类</li>
</ol>
</li>
</ol>
<p>词典的三个使用场景</p>
<ul>
<li>在分词时辅助分词</li>
<li>实体抽取时根据词典匹配实体</li>
<li>基于词典对实体分类</li>
</ul>
<p>词典的构建</p>
<blockquote>
<p>基于统计分析得到候选词典，然后在人工进行筛选，同时人工提取领域中重要的术语和复用领域现有词典。现有的综合中文语义词库包括：CSC、howne和Chinese Open Wordnet。</p>
</blockquote>
<p>词典构建统计分析方法：</p>
<ul>
<li>去停用词后统计词频，选取一定范围的名词</li>
<li>关键词抽取：TF-IDF、TextRank</li>
<li>借助维基百科页面的分类系统</li>
<li>特征词分词：词共现、特定模式</li>
<li>词性分析：从标记为人名(nh)、组织（ni）、日期（nt）等词中抽取</li>
<li>依存句法分析</li>
</ul>
<h3 id="基于机器学习的实体识别"><a href="#基于机器学习的实体识别" class="headerlink" title="基于机器学习的实体识别"></a>基于机器学习的实体识别</h3><p>主要包括</p>
<ul>
<li>隐式马尔科夫模型 Hidden Markov Model,HMM</li>
<li>最大熵马尔科夫模型 Maximum Entropy Markov Model,MEMM</li>
<li>条件随机场 Conditional Random Fields，CRF</li>
<li>支持向量机 Support Vector Machine,SVM</li>
</ul>
<ol>
<li>隐式马尔科夫模型<ul>
<li>有向图模型</li>
<li>生成模型</li>
<li>特征分布独立假设</li>
</ul>
</li>
<li>条件随机场模型<ul>
<li>无向图模型</li>
<li>判别式模型</li>
<li>无特征分布独立假设</li>
</ul>
</li>
</ol>
<h3 id="基于深度学习的实体识别"><a href="#基于深度学习的实体识别" class="headerlink" title="基于深度学习的实体识别"></a>基于深度学习的实体识别</h3><p>NN/CNN+CRF模型</p>
<p>Bi-LSTM+CRF</p>
<p>Bi-LSTM-CNN-CRF</p>
<h3 id="基于半监督学习的实体识别"><a href="#基于半监督学习的实体识别" class="headerlink" title="基于半监督学习的实体识别"></a>基于半监督学习的实体识别</h3><p>Language Model Augmented Sequence Taggers （TagLM）   Peters et al.[2017]</p>
<ol>
<li>使用海量无标注语料训练Bi-LSTM</li>
<li>获取LM embedding和Word embeding</li>
<li>将词的向量和语言模型向量混合输入到序列标注模型中进行预测</li>
</ol>
<h3 id="基于迁移学习的实体识别"><a href="#基于迁移学习的实体识别" class="headerlink" title="基于迁移学习的实体识别"></a>基于迁移学习的实体识别</h3><p>迁移学习的核心：找出新问题和原问题之间的<strong>相似性</strong>.</p>
<p>迁移学习是机器学习的一种，但也有一些区别</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>传统机器学习</th>
<th>迁移学习</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>训练和测试数据服从相同的分布</td>
<td>训练和测试数据服从不同的分布</td>
</tr>
<tr>
<td>数据标注</td>
<td>需要足够的数据标注来训练模型</td>
<td>不需要足够的数据标注</td>
</tr>
<tr>
<td>模型</td>
<td>每个任务分别建模</td>
<td>模型可以在不同任务之间迁移</td>
</tr>
</tbody>
</table>
</div>
<p>迁移学习的三种模式：跨域、跨应用、跨语言</p>
<p>Yang et al.[2017]</p>
<h3 id="基于预训练的实体识别"><a href="#基于预训练的实体识别" class="headerlink" title="基于预训练的实体识别"></a>基于预训练的实体识别</h3><p>BERT模型：重新设计了语言模型预训练阶段的目标任务，提出了遮挡语言模型 Masked LM和下一个句子预测 NSP</p>
<ul>
<li>Masked LM：在输入的词序列中，随机选15%的词进行[MASK]，然后在15%的词中，有80%的词被真正打上[MASK]标签，10%的词随机替换成任意词汇，10%的词不做任何处理。模型的任务是去正确预测带有[MASK]标签的词，相比传统的语言模型，Masked LM可以从前后两个方向预测这些带有[Mask]标签的词</li>
<li>NSP本质上是一个二分类任务，以50%的概率输入一个句子和下一个句子的拼接，标签属于正例；另外50%的概率输入一个句子和非下一个随机句子的拼接，对应标签为负例。</li>
</ul>
<h2 id="关系抽取"><a href="#关系抽取" class="headerlink" title="关系抽取"></a>关系抽取</h2><p>语义关系</p>
<ul>
<li>指隐藏在句法结构后面由词语的语义范畴建立起来的关系</li>
<li>在句子中的地位很重要</li>
<li>连接文本中的实体</li>
<li>与实体一起表达出文本中的含义</li>
<li>并不是很难识别</li>
</ul>
<p>句法关系 Syntactic relations</p>
<ul>
<li><p>位置关系 relation  of position</p>
<ul>
<li><p>位置关系是组合关系 （Syntagmatic Relations）一个方面的表现</p>
</li>
<li><p>也被叫做横向关系或链状关系</p>
</li>
<li>Word Order<ul>
<li>SVO、VSO、SOV、OVS、OSV、VOS</li>
<li>英语就是SVO</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>替代关系 relation of substitutability</p>
<ul>
<li>指的是在某个结构的<strong>位置</strong>上彼此可以<strong>相互替换</strong>的成分之间的关系</li>
<li>The <em>__</em> smiles.<ul>
<li>比如 ：man、boy、girl</li>
<li>必须满足以下条件</li>
<li>必须有生命</li>
<li>只有人类可以</li>
<li>和smiles连接的名词必须是单数</li>
</ul>
</li>
<li>也被称为联想关系或聚合关系</li>
<li>也被称为纵聚合关系或纵向关系或选择关系</li>
</ul>
</li>
<li><p>同现关系 relation of co-occurence</p>
<ul>
<li>指的是小句子中不同集合关系的词语允许或要求和另一个集合或类别中的词语一起组成句子或句子的某一特定部分。</li>
<li>同现关系部分属于组合关系，部分属于聚合关系</li>
</ul>
</li>
</ul>
<p>组合关系 Versus 聚合关系</p>
<ul>
<li>Harris,1987 频繁出现的组合关系可能称为我们记忆中的一部分，从而称为范式</li>
<li>Gardin,1965  聚合关系的实例来源于累积的组合数据</li>
<li>反映了当前对开放文本关系抽取的思考</li>
</ul>
<p>谓词逻辑 Predicate logic [Frege,1879]</p>
<ul>
<li><p>固有关系的形式化</p>
</li>
<li><p>例如 Google buys YouTube 表示为 buy(Google,YouTube)</p>
<p>问题：</p>
<ul>
<li><p>如何处理多个参数</p>
<p>buy(Google,YouTube,for $1.65B,in 2006)</p>
</li>
<li><p>如何处理多谓词或者无谓词的情况</p>
<p>buy(Google,YouTube) ^ for($1.65B) ^ jumped(stock) ^ immediately</p>
</li>
</ul>
</li>
</ul>
<p>戴维森逻辑表示 [Davidson,1980]</p>
<ul>
<li><p>用附加的变量表示事件或者关系</p>
</li>
<li><p>事件可以被明确的修改或者量化</p>
<script type="math/tex; mode=display">
\begin{align}
& \exist e\; buy(e,Google,YouTube) \and for(e,$1.65B) \and in(e,2006) \\
& \exist e_1\; buy(e_1,Google,YouTube) \and for(e_1,$1.65B) \and \exist e_2\;jumped(e_2,stock) \and immediately(e_2) \and \exist e_3 belong-to(e_3,stock,Google)
\end{align}</script></li>
<li><p>问题</p>
<ul>
<li><p>如何处理确实或者可选的参数</p>
<p>YouTube was bought for $1.65B in 2006 没有主语</p>
</li>
</ul>
</li>
</ul>
<p>新戴维森逻辑表示</p>
<ul>
<li><p>谓词参数分解为主题角色</p>
<script type="math/tex; mode=display">
\exist e \;InstanceOfBuying(e) \and agent(e,Google) \and patient(e,YouTube)</script><script type="math/tex; mode=display">
\exist e\; InstanceOf(e,Buying) \and agent(e,Google) \and patient(e,YouTube)</script></li>
</ul>
<p>一阶逻辑的图表示</p>
<ul>
<li>Begriffsschrift(‘concepte-script’)</li>
<li>Relational graphs</li>
<li>Existential graphs</li>
<li>Conceptual graphs</li>
<li>Discourse representation structure</li>
</ul>
<p>语义关系的双重性</p>
<ul>
<li><p>逻辑方面：谓词</p>
<p>用于AI以支持基于知识的表示和推理</p>
</li>
<li><p>图方面：弧形连接概念</p>
<p>在NLP中可以表示事实性知识</p>
<p>主要是二元关系</p>
</li>
</ul>
<p>推理系统的兴起</p>
<ul>
<li>logic-based reasoning, no language</li>
<li>early NLP systems with semantic knowledge<ul>
<li>interactive English dialogue system</li>
<li>understanding children’s stories</li>
<li>conceptual shift from the “shallow” architecture of primitive conversion systems such as ELIZA</li>
</ul>
</li>
<li>large-scale hand-crafted ontologies<ul>
<li>Cyc</li>
<li>OpenMind Common Sense</li>
<li>MindPixel</li>
<li>FreeBase-truly large-scale</li>
<li>DBpedia</li>
<li>Wikidata</li>
</ul>
</li>
</ul>
<p>知识和语言的十字路口</p>
<ul>
<li>词典中的词汇可以从文本中自动学习得到</li>
<li>语义网络<ul>
<li>一种用图来表示知识的结构化方式，信息被表达为一组结点，结点通过一组带标记的有向直线彼此相连，用于表示结点之间的关系。<ul>
<li>顶点是映射文本中单词的概念</li>
<li>边代表概念间的关系</li>
</ul>
</li>
</ul>
</li>
<li>WordNet<ul>
<li>包含155000个单词 （名词、动词、形容词、副词）</li>
<li>包含十几种语义关系，例如同义词、反义词、超代名词。</li>
</ul>
</li>
</ul>
<p>自动化知识获取</p>
<ul>
<li>学习本体关系<ul>
<li>is-a</li>
<li>part-of</li>
</ul>
</li>
<li>bootstrapping</li>
<li>开放式关系抽取<ul>
<li>没有预先指定的关系列表或关系模型</li>
<li>学习关系表达的模式<ul>
<li>POS</li>
<li>paths in a syntactic tree</li>
<li>sequences of high-frequency words</li>
</ul>
</li>
<li>抽取结果很难映射到知识库中</li>
</ul>
</li>
</ul>
<p>关系抽取的用处</p>
<ol>
<li><p>构建知识库</p>
</li>
<li><p>文本分析</p>
</li>
<li><p>NLP应用</p>
<p>信息抽取、信息检索、自动摘要、机器翻译、问答、释义、文本蕴涵推理、叙词表构建、语义网络构建、词义消歧、语言建模</p>
</li>
</ol>
<h3 id="语义关系"><a href="#语义关系" class="headerlink" title="语义关系"></a>语义关系</h3><p>语义关系的两种视角</p>
<ul>
<li>概念间的关系<ul>
<li>主要是关于世界的知识</li>
<li>可以从文本中发现</li>
</ul>
</li>
<li>名词间的关系<ul>
<li>主要关注文本所表达的事件或者形势</li>
<li>可以通过知识库信息进行发现</li>
</ul>
</li>
</ul>
<p>Casagrande &amp; Hale 1967在讲外语的人实验者门得出一系列单词的定义，从中抽取了13中关系</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Relation</th>
<th style="text-align:center">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">attributive</td>
<td style="text-align:center">toad-small</td>
</tr>
<tr>
<td style="text-align:center">function</td>
<td style="text-align:center">ear-hearing</td>
</tr>
<tr>
<td style="text-align:center">operational</td>
<td style="text-align:center">shirt-wear</td>
</tr>
<tr>
<td style="text-align:center">exemplification</td>
<td style="text-align:center">circular-wheel</td>
</tr>
<tr>
<td style="text-align:center">synonymy</td>
<td style="text-align:center">thousand-ten hundred</td>
</tr>
<tr>
<td style="text-align:center">provenience</td>
<td style="text-align:center">milk-cow</td>
</tr>
<tr>
<td style="text-align:center">circularity</td>
<td style="text-align:center">X is defined as X</td>
</tr>
<tr>
<td style="text-align:center">contingency</td>
<td style="text-align:center">lightning-rain</td>
</tr>
<tr>
<td style="text-align:center">spatial</td>
<td style="text-align:center">tongue-mouth</td>
</tr>
<tr>
<td style="text-align:center">comparison</td>
<td style="text-align:center">wolf-coyote</td>
</tr>
<tr>
<td style="text-align:center">class inclusion</td>
<td style="text-align:center">bee-insect</td>
</tr>
<tr>
<td style="text-align:center">antonymy</td>
<td style="text-align:center">low-high</td>
</tr>
<tr>
<td style="text-align:center">grading</td>
<td style="text-align:center">Monday-Sunday</td>
</tr>
</tbody>
</table>
</div>
<p>Chaffin &amp; Hermann,1984 对31中语义关系的实体进行分组，最终发现五个粗粒度的类别：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Relation</th>
<th style="text-align:center">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">constrasts</td>
<td style="text-align:center">night-day</td>
</tr>
<tr>
<td style="text-align:center">similars</td>
<td style="text-align:center">car-auto</td>
</tr>
<tr>
<td style="text-align:center">class inclusion</td>
<td style="text-align:center">vehicle-car</td>
</tr>
<tr>
<td style="text-align:center">part-whole</td>
<td style="text-align:center">airplane-wing</td>
</tr>
<tr>
<td style="text-align:center">case</td>
<td style="text-align:center">relations-agent,instrument</td>
</tr>
</tbody>
</table>
</div>
<p>复合名词中的语义关系</p>
<p>复合名词</p>
<ul>
<li>定义：两个或更多名词连在一起所构成的词</li>
<li>例如：Silkworm、 healthcare reform….</li>
<li>性质:<ul>
<li>隐式关系编码：难以解读</li>
<li>丰富性：难以忽略</li>
<li>高产：无法被列入词典</li>
</ul>
</li>
</ul>
<p>复合名词是一个缩影：表征问题反映了一般语义关系</p>
<ul>
<li>语义学的大量文献 www.cl.cam.ac.uk/~do242/Resources/compound_bibliography.html</li>
<li>互补的观点<ul>
<li>语言学的：寻找最全面的解释表达</li>
<li>NLP：为特定应用选择最有用的表示方式<ul>
<li>计算易处理的</li>
<li>向下游系统提供信息输出</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>复合名词的关系能否从一个小的封闭的清单中得出的吗？</p>
<p>即是否存在一个合理小的集合，完全涵盖文本中名词短语邻近的内容。</p>
<p>布朗语料库综合研究产生的关系：</p>
<ul>
<li><p>一个四级关系层级</p>
<p>L1: Constitute</p>
<p>​    L2: Source-Result</p>
<p>​    L2: Result-Source</p>
<p>​    L2: Copula</p>
<p>​        L3: Adjective-Like_Modifier</p>
<p>​        L3:Subsumptive</p>
<p>​        L3:Attributive</p>
<p>​            L4:Animate_Head (e.g. girl firend)</p>
<p>​            L4:Inanimate_Head (e.g. house boat)</p>
</li>
<li><p>六大语义关系</p>
<p>|    Relation    |     Example     |<br>| :——————: | :——————-: |<br>|   Possession   |  family estate  |<br>|    Location    |   water polo    |<br>|    Purpose     |  water bucket   |<br>| Activity-actor | crime syndicate |<br>|  Resemblance   |   cherry bomb   |<br>|   Constitute   |    clay bird    |</p>
</li>
</ul>
<h3 id="语义关系学习"><a href="#语义关系学习" class="headerlink" title="语义关系学习"></a>语义关系学习</h3><p>方法：</p>
<ul>
<li>监督学习<ul>
<li>优点：表现很好</li>
<li>缺点：需要大量的标记数据和特征表示</li>
</ul>
</li>
<li>无监督学习<ul>
<li>优点：可扩展，适用于开放式信息提取</li>
<li>缺点：表现比较差</li>
</ul>
</li>
</ul>
<p>特征</p>
<ul>
<li><p>目的：将数据映射维向量</p>
</li>
<li><p>Entity features and relational features [Turney, 2006]</p>
</li>
<li><p>实体特征：捕获关系实体中参数语义的一些表示</p>
<ul>
<li>Basic entity feature<ul>
<li>基本实体特征包括每个候选参数的字符串值以及标记这写参数的单个单词，可能是词形化或词干化</li>
<li>例如。字符串值、单独的词、词形化或词干化</li>
<li>优点：大多数情况下，这些特征对于一个良好的关系是信息足够的</li>
<li>缺点：特征比较稀疏</li>
</ul>
</li>
<li>Background entity features<ul>
<li>句法信息，例如：语法角色</li>
<li>语义信息，例如：语义类别</li>
<li>优点：解决了数据的稀疏性问题</li>
<li>缺点：需要人工标注</li>
<li>可以使用语义类别进行聚类<ul>
<li>Brown clusters [Brown&amp;al., 1992]</li>
<li>Clustering By Committee [Pantel &amp; Lin, 2002]</li>
<li>Latent Dirichlet Allocation [Blei&amp;al., 2003]</li>
</ul>
</li>
<li>直接表示特征空间中的单词共现<ul>
<li>协调、分布表示、关系语义表示</li>
</ul>
</li>
<li>词嵌入</li>
</ul>
</li>
</ul>
</li>
<li><p>关系特征：直接对关系进行表征，表征参数间的相互作用，如对文本实体的上下文进行建模。</p>
</li>
<li><p>Basic relational features</p>
<ul>
<li>对上下文进行建模<ul>
<li>在两个参数之间的单词</li>
<li>处于参数的特定窗口或者一侧的单词</li>
<li>链接参数的依赖路径</li>
<li>一个完整的依赖图</li>
<li>最小支配子树</li>
</ul>
</li>
</ul>
</li>
<li><p>Background relational features</p>
<ul>
<li>编码关于实体通常是如何交互的知识，而不仅仅是上下文<ul>
<li>通过释义进行关系表征</li>
<li>占位符模式</li>
<li>通过聚类寻找相似上下文</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="关系抽取数据集"><a href="#关系抽取数据集" class="headerlink" title="关系抽取数据集"></a>关系抽取数据集</h3><p>语义关系学习的标注数据</p>
<ul>
<li>small-scale/large-scale</li>
<li>general-purpose/domain-specific</li>
<li>arguments marked / not marked</li>
<li>additional information about the arguments / no additional information</li>
</ul>
<p>数据：MUC和ACE</p>
<p>数据：SemEval</p>
<ul>
<li>小数量的关系</li>
<li>标注的实体</li>
<li>附加的实体信息</li>
<li>句子语境和挖掘模式</li>
</ul>
<p>SemEval-2007 Task4 SemEval-2010 Task8</p>
<p>数据：FewRel</p>
<h3 id="基于模板的实体关系抽取"><a href="#基于模板的实体关系抽取" class="headerlink" title="基于模板的实体关系抽取"></a>基于模板的实体关系抽取</h3><p>基于模板的方法：</p>
<ul>
<li>使用模式/规则挖掘关系，基于触发词/字符串等</li>
<li>基于依存句法</li>
</ul>
<p>关系挖掘模式</p>
<ul>
<li>支持大多数关系抽取系统的基本概念是关系模式<ul>
<li>它是一个表达式，当与文本片段匹配时，它能够标识出响应的关系实例</li>
</ul>
</li>
<li>例如 词典项、通配符、词性、句法关系、正则表达式等等</li>
</ul>
<p>基于依存句法</p>
<p>通常可以以动词为起点构建规则，对节点上的词性和边上的依存关系进行限定。</p>
<ol>
<li>对句子进行分词、词性标注、命名实体识别、依存分析等处理</li>
<li>根据句子依存语法树结构上匹配规则，每匹配一条规则就生成一个三元组</li>
<li>根据扩展规则对抽取到的三元组进行扩展</li>
<li>对三元组实体和触发词进一步抽取出关系</li>
</ol>
<p>例子：董卿现身国家博物馆看展优雅大方</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">词顺序</th>
<th style="text-align:center">词</th>
<th style="text-align:center">词性</th>
<th style="text-align:center">依存关系路径</th>
<th style="text-align:center">依存关系</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">董卿</td>
<td style="text-align:center">人名</td>
<td style="text-align:center">1</td>
<td style="text-align:center">主语</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">现身</td>
<td style="text-align:center">动词</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">核心词</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">国家博物馆</td>
<td style="text-align:center">地名</td>
<td style="text-align:center">1</td>
<td style="text-align:center">宾语</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">看</td>
<td style="text-align:center">动词</td>
<td style="text-align:center">1</td>
<td style="text-align:center">顺承</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">展</td>
<td style="text-align:center">动词</td>
<td style="text-align:center">3</td>
<td style="text-align:center">补语</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">优雅</td>
<td style="text-align:center">形容词</td>
<td style="text-align:center">7</td>
<td style="text-align:center">定语</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">端庄</td>
<td style="text-align:center">形容词</td>
<td style="text-align:center">7</td>
<td style="text-align:center">定语</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">大方</td>
<td style="text-align:center">形容词</td>
<td style="text-align:center">4</td>
<td style="text-align:center">定语</td>
</tr>
</tbody>
</table>
</div>
<p>规则抽取结果</p>
<p>（董卿，现身，国家博物馆） —-&gt; 位于（董卿，国家博物馆）</p>
<ul>
<li>优点<ul>
<li>人工规则具有高准确率</li>
<li>可以为特定领域定制</li>
<li>在小规模数据集上容易实现，构建简单</li>
</ul>
</li>
<li>缺点<ul>
<li>低召回率</li>
<li>特定领域的模板需要专家构建，要考虑周全所有可能的pattern很难，也费时间尽力</li>
<li>需要为每条关系来定义pattern</li>
<li>难以维护</li>
<li>可移植性差</li>
</ul>
</li>
</ul>
<h3 id="有监督实体关系抽取"><a href="#有监督实体关系抽取" class="headerlink" title="有监督实体关系抽取"></a>有监督实体关系抽取</h3><p>关系学习的算法</p>
<ul>
<li>基于特征向量的方法<ul>
<li>从上下文信息、词性、语法等中抽取一系列特征</li>
</ul>
</li>
<li>核分类<ul>
<li>关系特征可能拥有复杂的结构</li>
</ul>
</li>
<li>序列标注方法<ul>
<li>关系中参数的跨度是可变的</li>
</ul>
</li>
</ul>
<h4 id="基于特征向量的方法"><a href="#基于特征向量的方法" class="headerlink" title="基于特征向量的方法"></a>基于特征向量的方法</h4><p>定义：从上下文信息、词性、语法等中抽取一系列特征，来训练一个分类器（朴素贝叶斯、支持向量机、最大熵等），然后完成关系抽取。</p>
<p>对于一组训练数据:</p>
<script type="math/tex; mode=display">
(x^1,y^1),(x^2,y^2),\cdots(x^n,y^n)</script><p>将二元关系抽取视为分类问题：$y^i={-1,1}$</p>
<p>进而学习得出一个分类函数</p>
<script type="math/tex; mode=display">
f = \begin{cases}
& 1 \quad存在某种关系 \\
& -1 \quad 其他情况
\end{cases}</script><h4 id="核分类"><a href="#核分类" class="headerlink" title="核分类"></a>核分类</h4><ul>
<li>观点：两个实体的相似度可以在高维的特征空间计算得到而不需要枚举特征空间的各个维度</li>
<li>convolution kernels<ul>
<li>易于对特征进行组合，例如：实体和关系</li>
</ul>
</li>
<li>kernelizable classifiers<ul>
<li>SVM、Logistic Regression、KNN、Naive Bayes</li>
</ul>
</li>
</ul>
<p>Kernels for linguistic structures</p>
<ul>
<li>string sequenceies</li>
<li>dependency paths</li>
<li>shallow parse tree</li>
<li>constituent parse trees</li>
<li>dependency parse trees</li>
<li>feature-enriched/semantic tree kernel</li>
<li>directed acyclic graphs</li>
</ul>
<h4 id="Sequential-labeling-method"><a href="#Sequential-labeling-method" class="headerlink" title="Sequential labeling method"></a>Sequential labeling method</h4><ul>
<li>能够识别句子中的实体，并且打上对应的语义类型标签，如：person、organization、location、protein等</li>
<li>对于识别出的实体，给出句子中存在的关系，如：president-of、born-in、cause、side-effect</li>
<li>HMMs / MEMMs / CRFs</li>
<li>useful for<ul>
<li>argument identification</li>
<li>relation extraction</li>
</ul>
</li>
</ul>
<ol>
<li>Sequential labeling : argument identification<ul>
<li>words: individual words,previous/following two words,word substrings,capitalization,digit patterns,manual lexicon。</li>
<li>labels: individual labels, previous/following two labels</li>
<li>combinations of words and labels</li>
</ul>
</li>
<li>relation extraction<ul>
<li>某些情况，关系抽取可以退化维序列标注问题</li>
<li>HMMs、CRFs</li>
<li>Dynamic graphical model</li>
</ul>
</li>
</ol>
<h3 id="弱监督关系抽取"><a href="#弱监督关系抽取" class="headerlink" title="弱监督关系抽取"></a>弱监督关系抽取</h3><h3 id="远程监督关系抽取"><a href="#远程监督关系抽取" class="headerlink" title="远程监督关系抽取"></a>远程监督关系抽取</h3><h3 id="无监督关系抽取"><a href="#无监督关系抽取" class="headerlink" title="无监督关系抽取"></a>无监督关系抽取</h3><h3 id="基于深度学习的关系抽取"><a href="#基于深度学习的关系抽取" class="headerlink" title="基于深度学习的关系抽取"></a>基于深度学习的关系抽取</h3><h4 id="词嵌入"><a href="#词嵌入" class="headerlink" title="词嵌入"></a>词嵌入</h4><ul>
<li>映射单词到一个实值的低维空间向量</li>
<li>做法<ul>
<li>neural networks （e.g. CBOW, skip-gram）</li>
<li>dimensionality reduction (e.g LSA,LDA,PCA)</li>
<li>explicit representation (words in the context)</li>
</ul>
</li>
<li>对于很多NLP任务都很重要</li>
</ul>
<p>Word Embeddings from a Neural LM [Bengio &amp;al.2003]</p>
<p>NNLM模型</p>
<p>Efficient Estimation of Word Representations in Vector Space [Mikolov &amp;al.2013]</p>
<p>Word2VecLinguistic Regularities in Continuous Space Word Representations [Mikolov &amp;al.2013]</p>
<p>RNNLM</p>
<p>基于句法的词嵌入</p>
<p>Linguistic Regularities in Continuous Space Word Representations [Mikolov &amp;al.2013]</p>
<p>Dependency-Based Word Embeddings [Levy&amp;Goldberg,2014]</p>
<p>Semantic Compositionality through Recursive Matrix-Vector Spaces [Socher&amp;al., 2012]</p>
<p>MV-RNN</p>
<p>Relation Classification via Convolutional Deep Neural Network [Zeng&amp;al., 2014]</p>
<p>CNN: Convolutional Deep Neural Network</p>
<p>Attention-Based Bidirectional Long Short-Term Memory Networks for Relation Classification. [Zhou, 2016, ACL]</p>
<p>RESIDE: Improving Distantly-Supervised Neural Relation Extraction using Side Information [Vashishth1, 2018, EMNLP]</p>
<p>Syntax-aware Entity Embedding for Neural Relation Extraction [He, 2018, AAAI]</p>
<p>A Hierarchical Framework for Relation Extraction with Reinforcement Learning [Takanobu, 2019, AAAI]</p>
<p>Jointly Extracting Multiple Triplets with Multilayer Translation Constraints. [Tan, 2019, AAAI]</p>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title>矩阵分析与计算</title>
    <url>/2019/11/23/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="矩阵分析与计算回顾"><a href="#矩阵分析与计算回顾" class="headerlink" title="矩阵分析与计算回顾"></a>矩阵分析与计算回顾</h1><blockquote>
<p>回顾矩阵和分析重点知识点和内容</p>
</blockquote>
<h2 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h2><ul>
<li>向量范数 $L_1,L_2,L_p$</li>
<li>矩阵范数 $m1,m_\infty,F$</li>
<li>算子范数：极大列和范数，极大行和范数，谱范数</li>
<li>算子范数和矩阵范数的关系</li>
<li>条件范数$cond(A)$在误差估计的应用</li>
<li>正规矩阵，Hermite矩阵（对称举证的推广），酉矩阵（正交矩阵的推广），正定举证</li>
<li>距离，赋范线性空间</li>
</ul>
<h2 id="矩阵的特征值"><a href="#矩阵的特征值" class="headerlink" title="矩阵的特征值"></a>矩阵的特征值</h2><ul>
<li><p>Smith标准型</p>
</li>
<li><p>$\lambda$-矩阵，不变因子，行列式因子，初等因子</p>
</li>
<li><p>Jordan标准型</p>
</li>
<li><p>盖尔圆，特征值的隔离</p>
</li>
<li><p>幂迭代法，逆幂迭代法 求主特征值和特征向量，以下为幂迭代法的公式</p>
<script type="math/tex; mode=display">
\begin{split}
& u_0 = v_0\\
& v_k = Av_{k-1}\\
& m_k = \max v_k\\
& u_k = \frac{v_k}{m_k}\\
\end{split}</script></li>
</ul>
<h2 id="矩阵分解和广义逆"><a href="#矩阵分解和广义逆" class="headerlink" title="矩阵分解和广义逆"></a>矩阵分解和广义逆</h2><ul>
<li>三角分解，Doolittle 分解</li>
<li>Chomlesky 分解</li>
<li>QR分解</li>
<li>满秩分解</li>
<li>奇异值分解</li>
<li>广义逆</li>
<li>Moore-Penrose 逆的直接解法：满秩分解，奇异值分解</li>
</ul>
<h2 id="矩阵的数值计算"><a href="#矩阵的数值计算" class="headerlink" title="矩阵的数值计算"></a>矩阵的数值计算</h2><ul>
<li>Gauss 消元法，选列主元。</li>
<li>三角分解</li>
<li>平方根，改进平方跟</li>
<li>…</li>
<li>J迭代法，G-S迭代法，SOR迭代法</li>
<li>极小化方法：（将矩阵计算转为泛函极值问题）最速下降法，共轭梯度法</li>
</ul>
<h2 id="最优化方法"><a href="#最优化方法" class="headerlink" title="最优化方法"></a>最优化方法</h2><ul>
<li>单纯形法</li>
<li>K-K-T点求解</li>
<li>最速下降法，牛顿法，阻尼牛顿法，共轭梯度法</li>
<li>罚函数法：外点罚函数，内点罚函数</li>
<li>广义乘子法</li>
</ul>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>编辑距离算法</title>
    <url>/2019/11/26/%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="编辑距离-Edit-Distance"><a href="#编辑距离-Edit-Distance" class="headerlink" title="编辑距离 Edit Distance"></a>编辑距离 Edit Distance</h1><blockquote>
<p>指两个字串之间，由一个转成另一个所需的最少编辑操作次数，如果它们的距离越大，说明它们越是不同。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。又称<code>Levenshtein</code>距离</p>
</blockquote>
<p>三种基本操作：插入，删除，替换</p>
<h2 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h2><ol>
<li>A和B的长度为0返回另一个字符串的长度。</li>
<li>初始化矩阵，shape：(n+1)(m+1)，第一行和第一列从0开始增长，如果A[i]==B[j]，temp=0，否则为1.然后在矩阵<code>mat[i][j]</code>中赋值为<code>mat[i-1][j]+1,mat[i][j-1]+1,mat[i-1][j-1]+temp</code>三者中的最小值，这三个操作分别对应插入、删除、替换。</li>
</ol>
<p>3.扫描完后，返回矩阵的最后一个值<code>mat[n][m]</code>即是它们的距离。</p>
<p>相似度公式:$\frac{1-mat[n][m]}{\max(n,m)}$</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>C</th>
<th>o</th>
<th>w</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>C</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>a</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>t</td>
<td>3</td>
<td>3</td>
<td>2</td>
<td>2</td>
</tr>
</tbody>
</table>
</div>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑距离算法</span></span><br><span class="line">A = <span class="string">'Cat'</span></span><br><span class="line">B = <span class="string">'Cow'</span></span><br><span class="line"></span><br><span class="line">n, m = len(A)+<span class="number">1</span>, len(B)+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">matrix = [[<span class="number">0</span>]*m <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    matrix[i][<span class="number">0</span>] = i</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">    matrix[<span class="number">0</span>][j] = j</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">        tmp = <span class="number">0</span> <span class="keyword">if</span> A[i<span class="number">-1</span>] == B[j<span class="number">-1</span>] <span class="keyword">else</span> <span class="number">1</span></span><br><span class="line">        matrix[i][j] = min(matrix[i<span class="number">-1</span>][j]+<span class="number">1</span>, matrix[i]</span><br><span class="line">                           [j<span class="number">-1</span>]+<span class="number">1</span>, matrix[i<span class="number">-1</span>][j<span class="number">-1</span>]+tmp)</span><br><span class="line"></span><br><span class="line">print(<span class="string">f'编辑距离:<span class="subst">&#123;matrix[n<span class="number">-1</span>][m<span class="number">-1</span>]&#125;</span>'</span>)</span><br><span class="line">print(<span class="string">f'相似度:<span class="subst">&#123;<span class="number">1</span>-matrix[n<span class="number">-1</span>][m<span class="number">-1</span>]/max(n<span class="number">-1</span>,m<span class="number">-1</span>)&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://blog.csdn.net/chichoxian/article/details/53944188" target="_blank" rel="noopener">https://blog.csdn.net/chichoxian/article/details/53944188</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title>常用IDE快捷键</title>
    <url>/2019/11/15/%E5%B8%B8%E7%94%A8IDE%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<h1 id="常用IDE快捷键"><a href="#常用IDE快捷键" class="headerlink" title="常用IDE快捷键"></a>常用IDE快捷键</h1><h2 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h2><ul>
<li>Trigger Suggestion: <code>Ctrl+Space</code></li>
<li>Format document: <code>Ctrl+Shift+I</code></li>
<li>Show Command Palette: <code>Ctrl+Shift+P</code> </li>
<li>Quick Open,Go to File… : <code>Ctrl+P</code></li>
<li>New Window/instance: <code>Ctrl+Shift+N</code></li>
<li>Close Window/instance: <code>Ctrl+W</code></li>
<li>Cut line: <code>Ctrl+X</code></li>
<li>Copy line: <code>Ctrl+C</code></li>
<li>Rename Symbol: <code>F2</code></li>
</ul>
<h2 id="the-Series-of-JetBrains-IDE"><a href="#the-Series-of-JetBrains-IDE" class="headerlink" title="the Series of JetBrains IDE"></a>the Series of JetBrains IDE</h2><ul>
<li>代码自动完成提示：<code>Ctrl+Space</code></li>
<li>显示意图和快速修复：<code>Alt+Enter</code></li>
<li>参数信息：<code>Ctrl+P</code></li>
<li>快速查找文件：<code>Ctrl+Q</code></li>
<li>生成代码：<code>Alt+Insert</code></li>
<li>格式化带啊：<code>Ctrl+Alt+L</code></li>
<li>删除光标所在行：<code>Ctrl+Y</code></li>
<li>复制当前行或选定的块：<code>Ctrl+D</code></li>
<li>开始新行：<code>Shift+Enter</code></li>
<li>历史粘贴：<code>Ctrl+Shift+V</code></li>
<li>运行：<code>Shift+F10</code></li>
<li>从编辑器运行上下文配置：<code>Ctrl+Shift+F10</code></li>
<li>在命令行运行：<code>Ctrl+Shift+X</code></li>
<li>查找/替换：<code>Ctrl+F/R</code></li>
<li>跳转到指定类：<code>Ctrl+N</code></li>
<li>跳转到文件：<code>Ctrl+Shift+N</code></li>
<li>跳转到符号：<code>Ctrl+Alt+Shift+N</code></li>
<li>跳转到第几行：<code>Ctrl+G</code></li>
<li>切换编辑器：<code>Alt+Right/Left</code></li>
<li>弹出最近编辑文件：<code>Ctrl+E</code></li>
<li>搜索任何地方：<code>Shift+Shift</code></li>
<li>查找Action：<code>Ctrl+Shift+A</code></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2020/05/18/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><blockquote>
<p>给定一组有固定价值和固定重量的物品，以及一个已知最大承重量的背包，求在不超过背包最大承重量的前提下，能放进背包里面的物品的最大总价值。</p>
</blockquote>
<a id="more"></a>
<h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><p>每一种物品都只有一件，可以选择放或不妨。假设有n件物品，背包承重为m。</p>
<p>可以采用一个二维数组去解决：$f[i][j]$，其中$i$代表加入背包的前$i$件物品，$j$表示背包的承重，$f[i][j]$表示当前状态下能放进背包里面的物品的最大总价值。那么$f[n][m]$就是最终结果。</p>
<p>采用<strong>动态规划</strong>，必须知道<strong>初始状态</strong>和<strong>状态转移方程</strong>。初始状态容易知道，状态转移方程如何求解？</p>
<p>对于一件物品，我们可以选择放或者不放进背包两种选择：</p>
<ol>
<li>假如放进背包，$f[i][j]=f[i-1][j-weight[i]]+value[i]$，右边的公式可以这样理解：在没放进这件物品之前的状态值加上要放进去这件物品的价值。$f[i-1][j-weight[i]]$部分，$i-1$容易理解，关键的是$j-weight[i]$意味着：要将这件物品放入背包，背包中必须预留这部分空间。</li>
<li>假如不放进背包，$f[i][j]=f[i-1][j]$，这是理所当然的。</li>
</ol>
<p>因此，状态转移方程就是：$f[i][j]=max(f[i-1][j],f[i-1][j-weight[i]]+value[i])$</p>
<p>除此之外，还有一种特殊情况，这种情况就是背包放不了当前这一物品，这种情况下$f[i][j]=f[i-1][j]$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> V 500</span></span><br><span class="line"><span class="keyword">int</span> weight[<span class="number">20</span>+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> value[<span class="number">20</span>+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">20</span>+<span class="number">1</span>][V+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入物品个数："</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请分别输入"</span> &lt;&lt; n &lt;&lt; <span class="string">"物品的重量和价值："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; weight[i] &gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入背包的容量："</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (weight[i] &gt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                f[i][j] = f[i<span class="number">-1</span>][j] &gt; f[i<span class="number">-1</span>][j-weight[i]] + value[i] ? f[i<span class="number">-1</span>][j] : f[i<span class="number">-1</span>][j-weight[i]] + value[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"背包能放的最大价值为："</span>&lt;&lt; f[n][m] &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>0-1背包还可以使用一维数组解决：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> V 500</span></span><br><span class="line"><span class="keyword">int</span> weight[<span class="number">20</span>+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> value[<span class="number">20</span>+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> f[V+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入物品个数:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请分别输入"</span> &lt;&lt; n &lt;&lt; <span class="string">"个物品的重量和价值:"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; weight[i] &gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入背包容量:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (weight[i] &lt;= j) &#123;</span><br><span class="line">                f[j] = f[j] &gt; f[j - weight[i]] + value[i] ? f[j] : f[j - weight[i]] + value[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"背包能放的最大价值为:"</span> &lt;&lt; f[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>完全背包中的每种物品都有无限件。</p>
<p>相关代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> V 500</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> weight[<span class="number">20</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> value[<span class="number">20</span> + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> f[V + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入物品个数:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请分别输入"</span> &lt;&lt; n &lt;&lt; <span class="string">"个物品的重量和价值:"</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; weight[i] &gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请输入背包容量:"</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = weight[i]; j &lt;= m; j++) &#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"背包能放的最大价值为:"</span> &lt;&lt; f[m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>未完参考<a href="https://www.cnblogs.com/mfrank/p/10803417.html" target="_blank" rel="noopener">https://www.cnblogs.com/mfrank/p/10803417.html</a></p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title>已知语言构建文法</title>
    <url>/2019/11/14/%E5%B7%B2%E7%9F%A5%E8%AF%AD%E8%A8%80%E6%9E%84%E5%BB%BA%E6%96%87%E6%B3%95/</url>
    <content><![CDATA[<h1 id="已知语言构建文法"><a href="#已知语言构建文法" class="headerlink" title="已知语言构建文法"></a>已知语言构建文法</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>常用方法</p>
<ul>
<li>对称法</li>
<li>逐步求精法（分解法）</li>
<li>等价法</li>
<li>电路状态转换法</li>
<li>混合法（混合上面的方法）</li>
</ul>
<h2 id="对称法"><a href="#对称法" class="headerlink" title="对称法"></a>对称法</h2><p>适用于存在对称性的语言。</p>
<p>两点：</p>
<ol>
<li>找出对称轴</li>
<li>找出对称性</li>
</ol>
<p>例题：$L={a^{2n}b^n | n\gt 1 \; and \;a,b\in V_T}$</p>
<p>观察语言：</p>
<script type="math/tex; mode=display">
\begin{split}
& when \; n=1, L=aab \\
& when \; n=2, L=aaaabb \rightarrow \; L=aa\;aab\;b
\end{split}</script><p>所以推出文法：</p>
<script type="math/tex; mode=display">
\begin{split}
& S \rightarrow aaSb \\
& S \rightarrow aab
\end{split}</script><h2 id="逐步求精法（分解法）"><a href="#逐步求精法（分解法）" class="headerlink" title="逐步求精法（分解法）"></a>逐步求精法（分解法）</h2><p>两种：自上而下 或者从左向右</p>
<p>前提：语言中各成分之间没有关联。</p>
<p>例题：$L={a^ib^jc^k|i,j,k \ge 1 \; and \; a,b,c \in V_T}$</p>
<ol>
<li><p>自上而下求精法</p>
<script type="math/tex; mode=display">
S\rightarrow ABC,\; A \rightarrow aA|a,\; B \rightarrow bB|b,\; C  \rightarrow cC|c</script><p>分析：将$a^i,b^j,c^k$各自看成一个整体，由$i \ge 1$，语言中最少存在一个$a$，所以可以写成这样的文法：$A \rightarrow aA|a$。同理可以得到其他两个$B \rightarrow bB|b,\; C \rightarrow cC|c$。所以$S \rightarrow ABC$。</p>
</li>
<li><p>从左向右求精法</p>
<script type="math/tex; mode=display">
S \rightarrow aS|aA,\; A\rightarrow bA|bB,\; B\rightarrow cB|c</script><p>分析：$a^ib^jc^k=a^*a^{i-1}b^jc^k$，其中$i-1 \ge 0$。</p>
<p>当$i-1\ge 1$时，$S \rightarrow aS$；当$i-1=0$时，$S \rightarrow aA$。</p>
<p>$A$对应的语言是$b^jc^k$，同理推出$A\rightarrow bA|bB$。</p>
</li>
</ol>
<h2 id="等价法"><a href="#等价法" class="headerlink" title="等价法"></a>等价法</h2><p>产生式两边具有相同的特性</p>
<p>例题：$L={\omega | \omega \in (a,b)^* \;and\; there\; are\; as\; many\; a’s\; as\; b’s\; in \; \omega}$</p>
<p>在语言中，a和b的数量一样多。</p>
<p>首先写出下面三个产生式：</p>
<p>当以a开头时，$S \rightarrow aA$；</p>
<p>当以b开头时，$S \rightarrow bB$；</p>
<p>$S$可以为空：$S \rightarrow \varepsilon$</p>
<p>在$S、A、B$中，a和b的数量满足：</p>
<script type="math/tex; mode=display">
\begin{split} 
& S \quad |a|=|b| \\
& A \quad |a|+1 = |b| \\
& B \quad |b|+1 = |a|
\end{split}</script><p>在$A$中</p>
<ul>
<li><p>若以b开头：$A\rightarrow bS|b$</p>
</li>
<li><p>若以a开头：$A \rightarrow aAA \quad (aA == S)$</p>
</li>
</ul>
<p>同理 $B \rightarrow bS|b|bBB$</p>
<p>所以最后得到的文法是：</p>
<script type="math/tex; mode=display">
S \rightarrow aA|bB|\varepsilon \\
A \rightarrow bS|b|aAA \\
B \rightarrow aS|a|bBB</script><h2 id="电路状态转换法"><a href="#电路状态转换法" class="headerlink" title="电路状态转换法"></a>电路状态转换法</h2><p>适用于语言对元素的奇偶有要求的。</p>
<p>电路状态的概念：0代表偶数，1代表奇数。</p>
<p>比如000代表语言中的a,b,c的个数都是偶数。</p>
<p><img src="/images/电路转换图.png" alt="电路转换图"></p>
<p>解题步骤：</p>
<ol>
<li><p>构建电路状态转换图</p>
<ul>
<li>确定状态，如果有n个元素，则存在$2^n$个状态。</li>
<li>然后链接状态</li>
</ul>
</li>
<li><p>确定开始状态和结束状态</p>
<p>开始状态和结束状态是相对的，根据题目情况确定。</p>
<ol>
<li>以全是0为结束状态，以题目要求为开始状态。</li>
<li>以题目要求作为结束状态，以全是0为开始状态。</li>
</ol>
<p>比如对于某种L，以a或b开头，c结尾，abc数量皆为偶数，则开始状态不唯一，所以不能用 全是0作为开始状态，而结束状态是唯一的，所以可拿全是0作为结束状态。</p>
</li>
<li><p>命名各个状态</p>
<p>初始状态用S，其他状态用A、B、C…..命名。</p>
</li>
<li><p>写出相应的产生式</p>
<p>每条边的变化对应一条产生式</p>
<p>对结束状态要增加一条产生式$S \rightarrow \varepsilon$</p>
<p>严格的说最后可以写出$2^{n(n+1)}+1$条产生式。</p>
</li>
</ol>
<p>例题：$L={\omega| \omega \in (0,1)^*, 1的数量是偶数}$</p>
<p>电路状态转换图如下所示：</p>
<p><img src="/images/电路状态转换图2.png" alt="电路状态转换图2"></p>
<p>本题中，只有两个状态：</p>
<p>S：1的数量是偶数，A：1的数量是奇数。</p>
<p>S组作为终止状态。</p>
<p>根据状态转换图写出产生式：</p>
<script type="math/tex; mode=display">
S \rightarrow 0S|1A|\varepsilon \\
A \rightarrow 0A|1S</script><h2 id="混合法（混合上面的方法）"><a href="#混合法（混合上面的方法）" class="headerlink" title="混合法（混合上面的方法）"></a>混合法（混合上面的方法）</h2><p>常用的如：分解法+对称法/分解法+电路转换法等。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://blog.csdn.net/Follower_JC/article/details/84036349" target="_blank" rel="noopener">https://blog.csdn.net/Follower_JC/article/details/84036349</a></li>
</ol>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
  </entry>
  <entry>
    <title>遗传算法Java实现</title>
    <url>/2020/01/11/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95Java%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="遗传算法Java实现"><a href="#遗传算法Java实现" class="headerlink" title="遗传算法Java实现"></a>遗传算法Java实现</h1><blockquote>
<p>采用了最优策略的GA：每次迭代保存当前最优的个体</p>
</blockquote>
<ol>
<li>GA （主要文件）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 种群规模</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> scale;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大迭代次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxGen;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前迭代次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> curGen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交叉概率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> rateOfCross;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 变异概率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> rateOfMutate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 染色体长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> dnaLength;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始种群，父代种群，行数表示种群规模，一行代表一个个体，即染色体，列表示染色体基因片段</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[][] oldPopulation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新的种群，子代种群</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[][] newPopulation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 种群适应度，表示种群中各个个体的适应度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] fitness;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义域范围</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> minThreshold;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> maxThreshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 累积矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] accumlateMatrix;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 评估类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> IEvalFunc eval;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GA</span><span class="params">(<span class="keyword">int</span> scale, <span class="keyword">int</span> maxGen, <span class="keyword">double</span> rateOfCross, <span class="keyword">double</span> rateOfMutate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scale = scale;</span><br><span class="line">        <span class="keyword">this</span>.maxGen = maxGen;</span><br><span class="line">        <span class="keyword">this</span>.rateOfCross = rateOfCross;</span><br><span class="line">        <span class="keyword">this</span>.rateOfMutate = rateOfMutate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dnaLength</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> minThreshold</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxThreshold</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> dnaLength, <span class="keyword">double</span> minThreshold, <span class="keyword">double</span> maxThreshold, IEvalFunc eval)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.oldPopulation = <span class="keyword">new</span> <span class="keyword">double</span>[scale][dnaLength];</span><br><span class="line">        <span class="keyword">this</span>.newPopulation = <span class="keyword">new</span> <span class="keyword">double</span>[scale][dnaLength];</span><br><span class="line">        <span class="keyword">this</span>.fitness = <span class="keyword">new</span> <span class="keyword">double</span>[scale];</span><br><span class="line">        <span class="keyword">this</span>.minThreshold = minThreshold;</span><br><span class="line">        <span class="keyword">this</span>.maxThreshold = maxThreshold;</span><br><span class="line">        <span class="keyword">this</span>.random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">this</span>.dnaLength = dnaLength;</span><br><span class="line">        <span class="keyword">this</span>.eval = eval;</span><br><span class="line">        <span class="keyword">this</span>.accumlateMatrix = <span class="keyword">new</span> <span class="keyword">double</span>[scale];</span><br><span class="line">        <span class="keyword">this</span>.curGen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化种群</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scale; i++) &#123;</span><br><span class="line">            <span class="keyword">double</span>[] individual = <span class="keyword">new</span> <span class="keyword">double</span>[dnaLength];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dnaLength; j++) &#123;</span><br><span class="line">                individual[j] = minThreshold + (maxThreshold - minThreshold) * getRandom();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.oldPopulation[i] = individual;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算初始种群的适应度和累积矩阵</span></span><br><span class="line">        calFitness();</span><br><span class="line">        calAccumulateMatrix();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算适应度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calFitness</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scale; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.fitness[i] = evaluate(<span class="keyword">this</span>.oldPopulation[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算累积矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calAccumulateMatrix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计算初始累积概率</span></span><br><span class="line">        <span class="keyword">double</span> sumEval = <span class="number">0.0</span>;</span><br><span class="line">        <span class="comment">//double minFitness = Arrays.stream(this.fitness).min().getAsDouble();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scale; i++) &#123;</span><br><span class="line">            <span class="keyword">double</span> curFitness = <span class="keyword">this</span>.fitness[i];</span><br><span class="line">            sumEval += curFitness;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.accumlateMatrix[i] = curFitness;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.accumlateMatrix[i] = <span class="keyword">this</span>.accumlateMatrix[i - <span class="number">1</span>] + curFitness;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; scale; j++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.accumlateMatrix[j] /= sumEval;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始进化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (curGen = <span class="number">0</span>; curGen &lt; maxGen; curGen++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//达到最小误差 退出</span></span><br><span class="line"><span class="comment">//            if (Math.abs(this.fitness[scale-2]-this.fitness[scale-1]) &lt; 10E-5)&#123;</span></span><br><span class="line"><span class="comment">//                break;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每次迭代 保存最优个体</span></span><br><span class="line">            <span class="keyword">double</span> tmpFitness = <span class="keyword">this</span>.fitness[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> bestIndividualIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.scale; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.fitness[i] &gt; tmpFitness) &#123;</span><br><span class="line">                    tmpFitness = <span class="keyword">this</span>.fitness[i];</span><br><span class="line">                    bestIndividualIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            newPopulation[<span class="number">0</span>] = <span class="keyword">this</span>.oldPopulation[bestIndividualIndex];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//选择剩下scale-1个体</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; scale; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> A = choose();</span><br><span class="line">                <span class="keyword">int</span> B;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    B = choose();</span><br><span class="line">                &#125; <span class="keyword">while</span> (A == B);</span><br><span class="line">                <span class="comment">//交叉</span></span><br><span class="line">                crossover(A, B, i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对于每个位置变异</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; scale; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.random.nextDouble() &lt; rateOfMutate) &#123;</span><br><span class="line">                    mutate(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            reCalculate();</span><br><span class="line">            System.out.println(String.format(<span class="string">"curGen: %d, the best fitness is %.6f"</span>, curGen, Arrays.stream(<span class="keyword">this</span>.fitness).max().getAsDouble()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重新计算参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reCalculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; scale; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.oldPopulation[i] = <span class="keyword">this</span>.newPopulation[i];</span><br><span class="line">        &#125;</span><br><span class="line">        calFitness();</span><br><span class="line">        calAccumulateMatrix();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选择</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回选择个体的index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">choose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据累积矩阵选择</span></span><br><span class="line">        <span class="keyword">double</span> rate = getRandom();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.scale - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rate &lt; <span class="keyword">this</span>.accumlateMatrix[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (rate &gt; <span class="keyword">this</span>.accumlateMatrix[i] &amp;&amp; rate &lt; <span class="keyword">this</span>.accumlateMatrix[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.scale - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交叉</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A     父母</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> B     父母</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 新种群的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">crossover</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果不满足交叉概率，直接将A插入新的种群</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.random.nextDouble() &gt; <span class="keyword">this</span>.rateOfCross) &#123;</span><br><span class="line">            <span class="keyword">this</span>.newPopulation[index] = <span class="keyword">this</span>.oldPopulation[A];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span>[] newIndividual = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="keyword">this</span>.dnaLength];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dnaLength; i++) &#123;</span><br><span class="line">            newIndividual[i] = <span class="number">0.5</span> * <span class="keyword">this</span>.oldPopulation[A][i] + (<span class="number">1</span> - <span class="number">0.5</span>) * <span class="keyword">this</span>.oldPopulation[B][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.newPopulation[index] = newIndividual;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 变异</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 个体的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mutate</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> stepDistance = <span class="number">0.05</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dnaLength; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> dir = <span class="keyword">this</span>.random.nextInt() % <span class="number">2</span> == <span class="number">0</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">this</span>.newPopulation[index][i] = <span class="keyword">this</span>.newPopulation[index][i] + stepDistance * dir;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 评估</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">evaluate</span><span class="params">(<span class="keyword">double</span>[] individual)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        return -(Math.pow(individual[0], 2) + 2 * individual[0] + 1);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.eval.eval(individual);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.random.nextDouble();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>evaluate 接口</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 评估函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IEvalFunc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">eval</span><span class="params">(<span class="keyword">double</span>[] A)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>测试文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GAMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GA ga = <span class="keyword">new</span> GA(<span class="number">10</span>, <span class="number">300</span>, <span class="number">1</span>, <span class="number">0.015</span>);</span><br><span class="line">        <span class="comment">// -(x^2+2x+1)</span></span><br><span class="line"><span class="comment">//        ga.init(1,-2,2, A -&gt; -(Math.pow(A[0], 2) + 3 * A[0] + 1));</span></span><br><span class="line">        ga.init(<span class="number">2</span>,-<span class="number">2</span>,<span class="number">2</span>, A -&gt; (Math.cos(A[<span class="number">0</span>]) + Math.sin(A[<span class="number">1</span>])));</span><br><span class="line">        ga.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> [] item : ga.oldPopulation)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; item.length; i++) &#123;</span><br><span class="line">                System.out.print(item[i]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title>面向对象设计原则</title>
    <url>/2019/11/29/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="面向对象的七种设计原则"><a href="#面向对象的七种设计原则" class="headerlink" title="面向对象的七种设计原则"></a>面向对象的七种设计原则</h1><hr>
<h2 id="原则一：（SRP：Single-responsibility-principle）单一职责原则又称单一功能原则"><a href="#原则一：（SRP：Single-responsibility-principle）单一职责原则又称单一功能原则" class="headerlink" title="原则一：（SRP：Single responsibility principle）单一职责原则又称单一功能原则"></a>原则一：（SRP：Single responsibility principle）单一职责原则又称单一功能原则</h2><p><strong>核心</strong>：解耦和增强内聚性（高内聚，低耦合）</p>
<p><strong>描述</strong>：类被修改的几率很大，因此应该专注于单一的功能。如果你把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能，这时就需要新一轮的测试来避免可能出现的问题。</p>
<a id="more"></a>
<h2 id="原则二：开闭原则（OCP：Open-Closed-Principle）"><a href="#原则二：开闭原则（OCP：Open-Closed-Principle）" class="headerlink" title="原则二：开闭原则（OCP：Open Closed Principle）"></a>原则二：开闭原则（OCP：Open Closed Principle）</h2><p><strong>核心思想</strong>：对扩展开放，对修改关闭。即在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。根据开闭原则，在设计一个软件系统模块（类，方法）的时候，应该可以在不修改原有的模块（修改关闭）的基础上，能扩展其功能（扩展开放）。</p>
<p><strong>扩展开放</strong>：某模块的功能是可扩展的，则该模块是扩展开放的。软件系统的功能上的可扩展性要求模块是扩展开放的。</p>
<p><strong>修改关闭</strong>：某模块被其他模块调用，如果该模块的源代码不允许修改，则该模块修改关闭的。软件系统的功能上的稳定性，持续性要求是修改关的。</p>
<h2 id="原则三：里氏替换原则（LSP：Liskov-Substitution-Principle）"><a href="#原则三：里氏替换原则（LSP：Liskov-Substitution-Principle）" class="headerlink" title="原则三：里氏替换原则（LSP：Liskov Substitution Principle）"></a>原则三：里氏替换原则（LSP：Liskov Substitution Principle）</h2><p><strong>核心</strong>：</p>
<ol>
<li><p>在任何父类出现的地方都可以用他的子类来替代（子类应当可以替换父类并出现在父类能够出现的任何地方）子类必须完全实现父类的方法。在类中调用其他类是务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。</p>
</li>
<li><p>子类可以有自己的个性。子类当然可以有自己的行为和外观了，也就是方法和属性</p>
</li>
<li><p>覆盖或实现父类的方法时输入参数可以被放大。即子类可以重载父类的方法，但输入参数应比父类方法中的大，这样在子类代替父类的时候，调用的仍然是父类的方法。即以子类中方法的前置条件必须与超类中被覆盖的方法的前置条件相同或者更宽松。</p>
</li>
<li><p>覆盖或实现父类的方法时输出结果可以被缩小。</p>
</li>
</ol>
<h2 id="原则四：依赖倒转原则-DIP：Dependence-Inversion-Principle"><a href="#原则四：依赖倒转原则-DIP：Dependence-Inversion-Principle" class="headerlink" title="原则四：依赖倒转原则(DIP：Dependence Inversion Principle)"></a>原则四：依赖倒转原则(DIP：Dependence Inversion Principle)</h2><p><strong>别名</strong>：依赖倒置原则或依赖反转原则</p>
<p><strong>核心</strong>：要依赖于抽象，不要依赖于具体的实现</p>
<ol>
<li><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象（抽象类或接口）</p>
</li>
<li><p>抽象不应该依赖细节（具体实现）</p>
</li>
<li><p>细节（具体实现）应该依赖抽象。</p>
</li>
</ol>
<p><strong>三种实现方式</strong>:</p>
<ol>
<li><p>通过构造函数传递依赖对象</p>
</li>
<li><p>通过setter方法传递依赖对象</p>
</li>
<li><p>接口声明实现依赖对象</p>
</li>
</ol>
<h2 id="原则五：接口分离原则-ISP：Interface-Segregation-Principle"><a href="#原则五：接口分离原则-ISP：Interface-Segregation-Principle" class="headerlink" title="原则五：接口分离原则(ISP：Interface Segregation Principle)"></a>原则五：接口分离原则(ISP：Interface Segregation Principle)</h2><p><strong>核心思想</strong>：不应该强迫客户程序依赖他们不需要使用的方法。</p>
<p><strong>接口分离原则的意思就是</strong>：一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口当中.</p>
<p><strong>分离接口的两种实现方法</strong>：</p>
<ol>
<li><p>使用委托分离接口。（Separation through Delegation）</p>
</li>
<li><p>使用多重继承分离接口。（Separation through Multiple Inheritance）</p>
</li>
</ol>
<h2 id="原则六：合成复用原则（CRP：Composite-Reuse-Principle）"><a href="#原则六：合成复用原则（CRP：Composite-Reuse-Principle）" class="headerlink" title="原则六：合成复用原则（CRP：Composite Reuse Principle）"></a>原则六：合成复用原则（CRP：Composite Reuse Principle）</h2><p><strong>核心思想</strong>：尽量使用对象组合，而不是继承来达到复用的目的。该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。</p>
<p><strong>复用的种类</strong>：</p>
<ol>
<li><p>继承</p>
</li>
<li><p>合成聚合</p>
</li>
</ol>
<p><em>注：在复用时应优先考虑使用合成聚合而不是继承</em></p>
<h2 id="原则七：迪米特原则（LOD：Law-of-Demeter）"><a href="#原则七：迪米特原则（LOD：Law-of-Demeter）" class="headerlink" title="原则七：迪米特原则（LOD：Law of Demeter）"></a>原则七：迪米特原则（LOD：Law of Demeter）</h2><p>又叫最少知识原则</p>
<p><strong>核心思想</strong>：一个对象应当对其他对象有尽可能少的了解,不和陌生人说话。（类间解耦，低耦合）意思就是降低各个对象之间的耦合，提高系统的可维护性；在模块之间只通过接口来通信，而不理会模块的内部工作原理，可以使各个模块的耦合成都降到最低，促进软件的复用</p>
<p><em>注</em>：</p>
<ol>
<li><p>在类的划分上，应该创建有弱耦合的类；</p>
</li>
<li><p>在类的结构设计上，每一个类都应当尽量降低成员的访问权限；</p>
</li>
<li><p>在类的设计上，只要有可能，一个类应当设计成不变；</p>
</li>
<li><p>在对其他类的引用上，一个对象对其它对象的引用应当降到最低；</p>
</li>
<li><p>尽量降低类的访问权限；</p>
</li>
<li><p>谨慎使用序列化功能；</p>
</li>
<li><p>不要暴露类成员，而应该提供相应的访问器(属性)</p>
</li>
</ol>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
  </entry>
  <entry>
    <title>pacman常用命令</title>
    <url>/2019/11/26/pacman%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="pacman-常用命令"><a href="#pacman-常用命令" class="headerlink" title="pacman 常用命令"></a>pacman 常用命令</h1><h2 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h2><p>在 Archlinux 中，使用一条命令即可对整个系统进行更新：<br> <code>pacman -Syu</code><br> 如果你已经使用<code>pacman -Sy</code>将本地的包数据库与远程的仓库进行了同步，也可以只执行：<code>pacman -Su</code></p>
<h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><ul>
<li><code>pacman -S 包名</code>：例如，执行 <code>pacman -S firefox</code> 将安装 Firefox。你也可以同时安装多个包，只需以空格分隔包名即可。</li>
<li><code>pacman -Sy</code> 包名：与上面命令不同的是，该命令将在同步包数据库后再执行安装。</li>
<li><code>pacman -Sv 包名</code>：在显示一些操作信息后执行安装。</li>
<li><code>pacman -U</code>：安装本地包，其扩展名为 pkg.tar.gz。</li>
<li><code>pacman -U http://www.example.com/repo/example.pkg.tar.xz</code> 安装一个远程包（不在 pacman 配置的源里面）</li>
</ul>
<h2 id="删除包"><a href="#删除包" class="headerlink" title="删除包"></a>删除包</h2><ul>
<li><code>pacman -R 包名</code>：该命令将只删除包，保留其全部已经安装的依赖关系</li>
<li><code>pacman -Rs 包名</code>：在删除包的同时，删除其所有没有被其他已安装软件包使用的依赖关系</li>
<li><code>pacman -Rsc 包名</code>：在删除包的同时，删除所有依赖这个软件包的程序</li>
<li><code>pacman -Rd 包名</code>：在删除包时不检查依赖。</li>
</ul>
<h2 id="搜索包"><a href="#搜索包" class="headerlink" title="搜索包"></a>搜索包</h2><ul>
<li><code>pacman -Ss 关键字</code>：在仓库中搜索含关键字的包。</li>
<li><code>pacman -Qs 关键字</code>： 搜索已安装的包。</li>
<li><code>pacman -Qi 包名</code>：查看有关包的详尽信息。</li>
<li><code>pacman -Ql 包名</code>：列出该包的文件。</li>
</ul>
<h2 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h2><ul>
<li><code>pacman -Sw 包名</code>：只下载包，不安装。</li>
<li><code>pacman -Sc</code>：清理未安装的包文件，包文件位于 <code>/var/cache/pacman/pkg/</code> 目录。</li>
<li><code>pacman -Scc</code>：清理所有的缓存文件。</li>
</ul>
<h2 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h2><ul>
<li><a href="https://www.jianshu.com/p/ea651cdc5530" target="_blank" rel="noopener">https://www.jianshu.com/p/ea651cdc5530</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Nodejs初探</title>
    <url>/2020/03/11/Nodejs%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h1 id="Nodejs初探"><a href="#Nodejs初探" class="headerlink" title="Nodejs初探"></a>Nodejs初探</h1><h2 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title="EventEmitter"></a>EventEmitter</h2><blockquote>
<p>Node.js的所有的异步<strong>I/O</strong>操作在完成后会发送一个事件到事件队列。</p>
</blockquote>
<p>events模块只提供了一个对象：events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。</p>
<a id="more"></a>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入 events 模块</span></span><br><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="comment">// 创建 eventEmitter 对象</span></span><br><span class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//event.js 文件</span></span><br><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter; </span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> EventEmitter(); </span><br><span class="line">event.on(<span class="string">'some_event'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'some_event 事件触发'</span>); </span><br><span class="line">&#125;); </span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    event.emit(<span class="string">'some_event'</span>); </span><br><span class="line">&#125;, <span class="number">1000</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//event.js 文件</span></span><br><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>); </span><br><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> events.EventEmitter(); </span><br><span class="line">emitter.on(<span class="string">'someEvent'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'listener1'</span>, arg1, arg2); </span><br><span class="line">&#125;); </span><br><span class="line">emitter.on(<span class="string">'someEvent'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'listener2'</span>, arg1, arg2); </span><br><span class="line">&#125;); </span><br><span class="line">emitter.emit(<span class="string">'someEvent'</span>, <span class="string">'arg1 参数'</span>, <span class="string">'arg2 参数'</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">var</span> eventEmitter = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器 #1</span></span><br><span class="line"><span class="keyword">var</span> listener1 = <span class="function"><span class="keyword">function</span> <span class="title">listener1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'监听器 listener1 执行。'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听器 #2</span></span><br><span class="line"><span class="keyword">var</span> listener2 = <span class="function"><span class="keyword">function</span> <span class="title">listener2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'监听器 listener2 执行。'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 connection 事件，处理函数为 listener1 </span></span><br><span class="line">eventEmitter.addListener(<span class="string">'connection'</span>, listener1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绑定 connection 事件，处理函数为 listener2</span></span><br><span class="line">eventEmitter.on(<span class="string">'connection'</span>, listener2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> eventListeners = eventEmitter.listenerCount(<span class="string">'connection'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(eventListeners + <span class="string">" 个监听器监听连接事件。"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理 connection 事件 </span></span><br><span class="line">eventEmitter.emit(<span class="string">'connection'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除监绑定的 listener1 函数</span></span><br><span class="line">eventEmitter.removeListener(<span class="string">'connection'</span>, listener1);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"listener1 不再受监听。"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发连接事件</span></span><br><span class="line">eventEmitter.emit(<span class="string">'connection'</span>);</span><br><span class="line"></span><br><span class="line">eventListeners = eventEmitter.listenerCount(<span class="string">'connection'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(eventListeners + <span class="string">" 个监听器监听连接事件。"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕。"</span>);</span><br></pre></td></tr></table></figure>
<p>error事件</p>
<p>EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。</p>
<p>当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p>
<p>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>); </span><br><span class="line"><span class="keyword">var</span> emitter = <span class="keyword">new</span> events.EventEmitter(); </span><br><span class="line">emitter.emit(<span class="string">'error'</span>);</span><br></pre></td></tr></table></figure>
<p>大多数情况并不会直接使用EventEmitter，而是通过继承实现，比如fs、net、http，只要支持事件响应的核心模块都是它的子类。</p>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><blockquote>
<p>Buffer类，用于创建专门存放二进制数据的缓存区</p>
</blockquote>
<ol>
<li><p>字符编码</p>
<p>Buffer 实例用于表示编码字符的序列，比如 UTF-8,UCS2,Base64等等。可以通过编码，将Buffer实例和普通的JS字符串相互转换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = Buffer.from(<span class="string">'runoob'</span>, <span class="string">'ascii'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 72756e6f6f62</span></span><br><span class="line"><span class="built_in">console</span>.log(buf.toString(<span class="string">'hex'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 cnVub29i</span></span><br><span class="line"><span class="built_in">console</span>.log(buf.toString(<span class="string">'base64'</span>));</span><br></pre></td></tr></table></figure>
<p>当前Node.js支持的编码包括</p>
<ul>
<li><strong>ascii</strong> - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。</li>
<li><strong>utf8</strong> - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。</li>
<li><strong>utf16le</strong> - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。</li>
<li><strong>ucs2</strong> - <strong>utf16le</strong> 的别名。</li>
<li><strong>base64</strong> - Base64 编码。</li>
<li><strong>latin1</strong> - 一种把 <strong>Buffer</strong> 编码成一字节编码的字符串的方式。</li>
<li><strong>binary</strong> - <strong>latin1</strong> 的别名。</li>
<li><strong>hex</strong> - 将每个字节编码为两个十六进制字符。</li>
</ul>
</li>
<li><p>创建Buffer实例</p>
<ul>
<li><strong>Buffer.alloc(size[, fill[, encoding]])：</strong> 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0</li>
<li><strong>Buffer.allocUnsafe(size)：</strong> 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据</li>
<li><strong>Buffer.allocUnsafeSlow(size)</strong></li>
<li><strong>Buffer.from(array)：</strong> 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）</li>
<li><strong>Buffer.from(arrayBuffer[, byteOffset[, length]])：</strong> 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。</li>
<li><strong>Buffer.from(buffer)：</strong> 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例</li>
<li><strong>Buffer.from(string[, encoding])：</strong> 返回一个被 string 的值初始化的新的 Buffer 实例</li>
</ul>
</li>
<li><p>写入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">buf.write(string[, offset[, length]][, encoding])</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>string</strong> - 写入缓冲区的字符串。</li>
<li><strong>offset</strong> - 缓冲区开始写入的索引值，默认为 0 。</li>
<li><strong>length</strong> - 写入的字节数，默认为 buffer.length</li>
<li><strong>encoding</strong> - 使用的编码。默认为 ‘utf8’ 。</li>
</ul>
</li>
<li><p>读取</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">buf.toString([encoding[, start[, end]]])</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>encoding</strong> - 使用的编码。默认为 ‘utf8’ 。</li>
<li><strong>start</strong> - 指定开始读取的索引位置，默认为 0。</li>
<li><strong>end</strong> - 结束位置，默认为缓冲区的末尾。</li>
</ul>
</li>
<li><p>转换为JSON对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">buf.toJSON()</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = Buffer.from([<span class="number">0x1</span>, <span class="number">0x2</span>, <span class="number">0x3</span>, <span class="number">0x4</span>, <span class="number">0x5</span>]);</span><br><span class="line"><span class="keyword">const</span> json = <span class="built_in">JSON</span>.stringify(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: &#123;"type":"Buffer","data":[1,2,3,4,5]&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(json);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> copy = <span class="built_in">JSON</span>.parse(json, (key, value) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> value &amp;&amp; value.type === <span class="string">'Buffer'</span> ?</span><br><span class="line">    Buffer.from(value.data) :</span><br><span class="line">    value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: &lt;Buffer 01 02 03 04 05&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(copy);</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Buffer.concat(list[, totalLength])</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>list</strong> - 用于合并的 Buffer 对象数组列表。</li>
<li><strong>totalLength</strong> - 指定合并后Buffer对象的总长度。</li>
</ul>
</li>
<li><p>比较</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer1 = Buffer.from(<span class="string">'ABC'</span>);</span><br><span class="line"><span class="keyword">var</span> buffer2 = Buffer.from(<span class="string">'ABCD'</span>);</span><br><span class="line"><span class="keyword">var</span> result = buffer1.compare(buffer2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(buffer1 + <span class="string">" 在 "</span> + buffer2 + <span class="string">"之前"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(result == <span class="number">0</span>)&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(buffer1 + <span class="string">" 与 "</span> + buffer2 + <span class="string">"相同"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(buffer1 + <span class="string">" 在 "</span> + buffer2 + <span class="string">"之后"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拷贝</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buf1 = Buffer.from(<span class="string">'abcdefghijkl'</span>);</span><br><span class="line"><span class="keyword">var</span> buf2 = Buffer.from(<span class="string">'RUNOOB'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将 buf2 插入到 buf1 指定位置上</span></span><br><span class="line">buf2.copy(buf1, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(buf1.toString());</span><br></pre></td></tr></table></figure>
</li>
<li><p>裁剪</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">buf.slice([start[, end]])</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer1 = Buffer.from(<span class="string">'runoob'</span>);</span><br><span class="line"><span class="comment">// 剪切缓冲区</span></span><br><span class="line"><span class="keyword">var</span> buffer2 = buffer1.slice(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"buffer2 content: "</span> + buffer2.toString());</span><br></pre></td></tr></table></figure>
</li>
<li><p>长度gg</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> buffer = Buffer.from(<span class="string">'www.runoob.com'</span>);</span><br><span class="line"><span class="comment">//  缓冲区长度</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"buffer length: "</span> + buffer.length);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><blockquote>
<p>Stream是一个抽象接口，Node中的很多对象实现了这个接口，比如http发起的请求对象，stdout等等。</p>
</blockquote>
<p>Stream一共包括四种类型：</p>
<ul>
<li>Readable</li>
<li>Writeable</li>
<li>Duplex 可读可写操作</li>
<li>Transform 操作被写入的数据，然后读出结果</li>
</ul>
<p>Stream对象都是EventEmitter的实例。包括的事件有</p>
<ul>
<li><strong>data</strong> - 当有数据可读时触发。</li>
<li><strong>end</strong> - 没有更多的数据可读时触发。</li>
<li><strong>error</strong> - 在接收和写入过程中发生错误时触发。</li>
<li><strong>finish</strong> - 所有数据已被写入到底层系统时触发。</li>
</ul>
<ol>
<li><p>从流中读取数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建可读流</span></span><br><span class="line"><span class="keyword">var</span> readerStream = fs.createReadStream(<span class="string">'input.txt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置编码为 utf8。</span></span><br><span class="line">readerStream.setEncoding(<span class="string">'UTF8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理流事件 --&gt; data, end, and error</span></span><br><span class="line">readerStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">   data += chunk;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">readerStream.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">readerStream.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(err.stack);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>写入流</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">'菜鸟教程官网地址：www.runoob.com'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个可以写入的流，写入到文件 output.txt 中</span></span><br><span class="line"><span class="keyword">var</span> writerStream = fs.createWriteStream(<span class="string">'output.txt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 utf8 编码写入数据</span></span><br><span class="line">writerStream.write(data,<span class="string">'UTF8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记文件末尾</span></span><br><span class="line">writerStream.end();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理流事件 --&gt; data, end, and error</span></span><br><span class="line">writerStream.on(<span class="string">'finish'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"写入完成。"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">writerStream.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(err.stack);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>管道流</p>
<blockquote>
<p>管道提供了输出流到输入流的机制，用于从一个流获取数据传递到另一个流中</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个可读流</span></span><br><span class="line"><span class="keyword">var</span> readerStream = fs.createReadStream(<span class="string">'input.txt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个可写流</span></span><br><span class="line"><span class="keyword">var</span> writerStream = fs.createWriteStream(<span class="string">'output.txt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管道读写操作</span></span><br><span class="line"><span class="comment">// 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中</span></span><br><span class="line">readerStream.pipe(writerStream);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>链式流</p>
<p>压缩文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩 input.txt 文件为 input.txt.gz</span></span><br><span class="line">fs.createReadStream(<span class="string">'input.txt'</span>)</span><br><span class="line">  .pipe(zlib.createGzip())</span><br><span class="line">  .pipe(fs.createWriteStream(<span class="string">'input.txt.gz'</span>));</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"文件压缩完成。"</span>);</span><br></pre></td></tr></table></figure>
<p>解压文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解压 input.txt.gz 文件为 input.txt</span></span><br><span class="line">fs.createReadStream(<span class="string">'input.txt.gz'</span>)</span><br><span class="line">  .pipe(zlib.createGunzip())</span><br><span class="line">  .pipe(fs.createWriteStream(<span class="string">'input.txt'</span>));</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"文件解压完成。"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h2><blockquote>
<p>为了Node.js的文件可以互相使用，通过提供模块来实现。</p>
<p>模块是Node.js Application的基本组成部分。文件和模块是一对一的。</p>
<p>一个Node.js文件就是一个模块，遮盖文件可以是JavaScript代码、JSON或编译过的C/C++扩展</p>
</blockquote>
<ol>
<li><p>创建模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hello = <span class="built_in">require</span>(<span class="string">'./hello'</span>);</span><br><span class="line">hello.world();</span><br></pre></td></tr></table></figure>
<p><code>require(&#39;./hello&#39;)</code>引入了当前目录下的<code>hello.js</code>文件，node.js默认后缀是js。</p>
<p>Node.js提供了<code>export</code>和<code>require</code>两个对象</p>
<ul>
<li><code>export</code>:模块公开的接口</li>
<li><code>require</code>:从外部获取模块的接口，即获取模块的<code>export</code>对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exports.world = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以直接访问<code>hello.js</code>中<code>export</code>对象的成员函数了。</p>
<p>有时候需要将一个对象封装到模块中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hello.js </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> name; </span><br><span class="line">    <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">thyName</span>) </span>&#123; </span><br><span class="line">        name = thyName; </span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + name); </span><br><span class="line">    &#125;; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="built_in">module</span>.exports = Hello;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Hello = <span class="built_in">require</span>(<span class="string">'./hello'</span>); </span><br><span class="line">hello = <span class="keyword">new</span> Hello(); </span><br><span class="line">hello.setName(<span class="string">'BYVoid'</span>); </span><br><span class="line">hello.sayHello();</span><br></pre></td></tr></table></figure>
</li>
<li><p>模块的查找策略</p>
<p>require方法中的文件查找策略：</p>
<p>Node.js中存在四种模块：原生模块和三种文件模块。加载的过程如下。</p>
<p><img src="/images/nodejs/nodejs-require.jpg" alt="nodejs-require"></p>
</li>
</ol>
<p>优先级：文件模块缓存区 &gt;&gt; 原生模块 &gt;&gt; 文件模块</p>
<p>当文件模块缓存和原生模块都不满足的话，Node.js就会解析require传入的参数，从文件系统中加载实际的文件。</p>
<p>require参数</p>
<ul>
<li>http、fs、path等，原生模块</li>
<li>./mod or ../mod，相对路径的文件模块</li>
<li>/pathtomodule/mod，绝对路径的文件模块</li>
<li>mod，非原生模块的文件模块</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在JavaScript中，一个函数可以作为参数传递，在Node.js中也是类似的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">word</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(word);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">someFunction, value</span>) </span>&#123;</span><br><span class="line">  someFunction(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">execute(say, <span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure>
<p>匿名函数，将函数作为变量传递，可以定义和传递，不需要事先定义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params">someFunction, value</span>) </span>&#123;</span><br><span class="line">  someFunction(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">execute(<span class="function"><span class="keyword">function</span>(<span class="params">word</span>)</span>&#123; <span class="built_in">console</span>.log(word) &#125;, <span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure>
<p>http模块中的函数传递</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">  response.write(<span class="string">"Hello World"</span>);</span><br><span class="line">  response.end();</span><br><span class="line">&#125;).listen(<span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">  response.write(<span class="string">"Hello World"</span>);</span><br><span class="line">  response.end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br></pre></td></tr></table></figure>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>路由需要请求的URL和其他的GET和POST等等的参数，然后由路由决定执行代码，因此，需要检查HTTP请求，从中提取出这些信息。</p>
<p>在http模块中，所有的数据都包含在<code>request</code>对象中。该对象作为onRequest()回调函数的第一个参数传递，但是为了解析数据，还需要url和querystring模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                   url.parse(string).query</span><br><span class="line">                                           |</span><br><span class="line">           url.parse(string).pathname      |</span><br><span class="line">                       |                   |</span><br><span class="line">                       |                   |</span><br><span class="line">                     ------ -------------------</span><br><span class="line">http:&#x2F;&#x2F;localhost:8888&#x2F;start?foo&#x3D;bar&amp;hello&#x3D;world</span><br><span class="line">                                ---       -----</span><br><span class="line">                                 |          |</span><br><span class="line">                                 |          |</span><br><span class="line">              querystring.parse(queryString)[&quot;foo&quot;]    |</span><br><span class="line">                                            |</span><br><span class="line">                         querystring.parse(queryString)[&quot;hello&quot;]</span><br></pre></td></tr></table></figure>
<p>server.js文件代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">" received."</span>);</span><br><span class="line"> </span><br><span class="line">    route(pathname);</span><br><span class="line"> </span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">    response.write(<span class="string">"Hello World"</span>);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  http.createServer(onRequest).listen(<span class="number">8888</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">exports.start = start;</span><br></pre></td></tr></table></figure>
<p>router.js文件代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">pathname</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"About to route a request for "</span> + pathname);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">exports.route = route;</span><br></pre></td></tr></table></figure>
<p>index.js 代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">"./server"</span>);</span><br><span class="line"><span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">"./router"</span>);</span><br><span class="line"> </span><br><span class="line">server.start(router.route);</span><br></pre></td></tr></table></figure>
<h2 id="全局对象"><a href="#全局对象" class="headerlink" title="　全局对象"></a>　全局对象</h2><blockquote>
<p>全局对象本身及其属性可以在程序的任何地方访问。</p>
<p>Node.js中的全局对象是<strong>global</strong>，所有的全局变量都是global对象的属性。</p>
<p>在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。</p>
</blockquote>
<ol>
<li><p>全局对象和全局变量</p>
<p>global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量：</p>
<ul>
<li>在最外层定义的变量；</li>
<li>全局对象的属性；</li>
<li>隐式定义的变量（未定义直接赋值的变量）。</li>
</ul>
</li>
<li><p><strong>__filename</strong>：当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。</p>
</li>
<li><p><strong>__dirname</strong> 表示当前执行脚本所在的目录。</p>
</li>
<li><p><strong>setTimeout(cb, ms)</strong> 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：setTimeout() 只执行一次指定函数。</p>
</li>
<li><p><strong>clearTimeout( t )</strong> 全局函数用于停止一个之前通过 setTimeout() 创建的定时器。 参数 <strong>t</strong> 是通过 setTimeout() 函数创建的定时器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log( <span class="string">"Hello, World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两秒后执行以上函数</span></span><br><span class="line"><span class="keyword">var</span> t = setTimeout(printHello, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除定时器</span></span><br><span class="line">clearTimeout(t);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>setInterval(cb, ms)</strong> 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log( <span class="string">"Hello, World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 两秒后执行以上函数</span></span><br><span class="line">setInterval(printHello, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>console 用于提供控制台标准输出</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>console.log([data][, …])</strong> 向标准输出流打印字符并以换行符结束。该方法接收若干 个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>console.info([data][, …])</strong> 该命令的作用是返回信息性消息，这个命令与console.log差别并不大，除了在chrome中只会输出文字外，其余的会显示一个蓝色的惊叹号。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>console.error([data][, …])</strong> 输出错误消息的。控制台在出现错误时会显示是红色的叉子。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>console.warn([data][, …])</strong> 输出警告消息。控制台出现有黄色的惊叹号。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>console.dir(obj[, options])</strong> 用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>console.time(label)</strong> 输出时间，表示计时开始。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>console.timeEnd(label)</strong> 结束时间，表示计时结束。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><strong>console.trace(message[, …])</strong> 当前执行的代码在堆栈中的调用路径，这个测试函数运行很有帮助，只要给想测试的函数里面加入 console.trace 就行了。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><strong>console.assert(value[, message][, …])</strong> 用于判断某个表达式或变量是否为真，接收两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li><p>process 是一个全局变量，即 global 对象的属性。</p>
<p>它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要 和它打交道。下面将会介绍 process 对象的一些最常用的成员方法。</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">事件 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>exit</strong> 当进程准备退出时触发。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>beforeExit</strong> 当 node 清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时 node 退出，但是 ‘beforeExit’ 的监听器可以异步调用，这样 node 就会继续执行。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>uncaughtException</strong> 当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监视器，默认的操作（打印堆栈跟踪信息并退出）就不会发生。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>Signal 事件</strong> 当进程接收到信号时就触发。信号列表详见标准的 POSIX 信号名，如 SIGINT、SIGUSR1 等。</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">process.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下代码永远不会执行</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"该代码不会执行"</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'退出码为:'</span>, code);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行结束"</span>);</span><br></pre></td></tr></table></figure>
<p>退出状态码如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">名称 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>Uncaught Fatal Exception</strong> 有未捕获异常，并且没有被域或 uncaughtException 处理函数处理。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>Unused</strong> 保留</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>Internal JavaScript Parse Error</strong> JavaScript的源码启动 Node 进程时引起解析错误。非常罕见，仅会在开发 Node 时才会有。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>Internal JavaScript Evaluation Failure</strong> JavaScript 的源码启动 Node 进程，评估时返回函数失败。非常罕见，仅会在开发 Node 时才会有。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>Fatal Error</strong> V8 里致命的不可恢复的错误。通常会打印到 stderr ，内容为： FATAL ERROR</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>Non-function Internal Exception Handler</strong> 未捕获异常，内部异常处理函数不知为何设置为on-function，并且不能被调用。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>Internal Exception Handler Run-Time Failure</strong> 未捕获的异常， 并且异常处理函数处理时自己抛出了异常。例如，如果 process.on(‘uncaughtException’) 或 domain.on(‘error’) 抛出了异常。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><strong>Unused</strong> 保留</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><strong>Invalid Argument</strong> 可能是给了未知的参数，或者给的参数没有值。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><strong>Internal JavaScript Run-Time Failure</strong> JavaScript的源码启动 Node 进程时抛出错误，非常罕见，仅会在开发 Node 时才会有。</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><strong>Invalid Debug Argument</strong> 设置了参数—debug 和/或 —debug-brk，但是选择了错误端口。</td>
</tr>
<tr>
<td style="text-align:left">128</td>
<td style="text-align:left"><strong>Signal Exits</strong> 如果 Node 接收到致命信号，比如SIGKILL 或 SIGHUP，那么退出代码就是128 加信号代码。这是标准的 Unix 做法，退出信号代码放在高位。</td>
</tr>
</tbody>
</table>
</div>
<p>Process 提供了很多有用的属性，便于我们更好的控制系统的交互：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号.</th>
<th style="text-align:left">属性 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>stdout</strong> 标准输出流。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>stderr</strong> 标准错误流。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>stdin</strong> 标准输入流。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>argv</strong> argv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>execPath</strong> 返回执行当前脚本的 Node 二进制文件的绝对路径。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>execArgv</strong> 返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>env</strong> 返回一个对象，成员为当前 shell 的环境变量</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><strong>exitCode</strong> 进程退出时的代码，如果进程优通过 process.exit() 退出，不需要指定退出码。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><strong>version</strong> Node 的版本，比如v0.10.18。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><strong>versions</strong> 一个属性，包含了 node 的版本和依赖.</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><strong>config</strong> 一个包含用来编译当前 node 执行文件的 javascript 配置选项的对象。它与运行 ./configure 脚本生成的 “config.gypi” 文件相同。</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><strong>pid</strong> 当前进程的进程号。</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><strong>title</strong> 进程名，默认值为”node”，可以自定义该值。</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><strong>arch</strong> 当前 CPU 的架构：’arm’、’ia32’ 或者 ‘x64’。</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left"><strong>platform</strong> 运行程序所在的平台系统 ‘darwin’, ‘freebsd’, ‘linux’, ‘sunos’ 或 ‘win32’</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left"><strong>mainModule</strong> require.main 的备选方法。不同点，如果主模块在运行时改变，require.main可能会继续返回老的模块。可以认为，这两者引用了同一个模块。</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出到终端</span></span><br><span class="line">process.stdout.write(<span class="string">"Hello World!"</span> + <span class="string">"\n"</span>);</span><br><span class="line"><span class="comment">// 通过参数读取</span></span><br><span class="line">process.argv.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">val, index, array</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(index + <span class="string">': '</span> + val);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 获取执行路径</span></span><br><span class="line"><span class="built_in">console</span>.log(process.execPath);</span><br><span class="line"><span class="comment">// 平台信息</span></span><br><span class="line"><span class="built_in">console</span>.log(process.platform);</span><br></pre></td></tr></table></figure>
<p>Process 提供了很多有用的方法，便于我们更好的控制系统的交互：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>abort()</strong> 这将导致 node 触发 abort 事件。会让 node 退出并生成一个核心文件。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>chdir(directory)</strong> 改变当前工作进程的目录，如果操作失败抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>cwd()</strong> 返回当前进程的工作目录</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>exit([code])</strong> 使用指定的 code 结束进程。如果忽略，将会使用 code 0。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>getgid()</strong> 获取进程的群组标识（参见 getgid(2)）。获取到得时群组的数字 id，而不是名字。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>setgid(id)</strong> 设置进程的群组标识（参见 setgid(2)）。可以接收数字 ID 或者群组名。如果指定了群组名，会阻塞等待解析为数字 ID 。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>getuid()</strong> 获取进程的用户标识(参见 getuid(2))。这是数字的用户 id，不是用户名。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><strong>setuid(id)</strong> 设置进程的用户标识（参见setuid(2)）。接收数字 ID或字符串名字。果指定了群组名，会阻塞等待解析为数字 ID 。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><strong>getgroups()</strong> 返回进程的群组 iD 数组。POSIX 系统没有保证一定有，但是 node.js 保证有。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><strong>setgroups(groups)</strong> 设置进程的群组 ID。这是授权操作，所以你需要有 root 权限，或者有 CAP_SETGID 能力。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><strong>initgroups(user, extra_group)</strong> 读取 /etc/group ，并初始化群组访问列表，使用成员所在的所有群组。这是授权操作，所以你需要有 root 权限，或者有 CAP_SETGID 能力。 注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><strong>kill(pid[, signal])</strong> 发送信号给进程. pid 是进程id，并且 signal 是发送的信号的字符串描述。信号名是字符串，比如 ‘SIGINT’ 或 ‘SIGHUP’。如果忽略，信号会是 ‘SIGTERM’。</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><strong>memoryUsage()</strong> 返回一个对象，描述了 Node 进程所用的内存状况，单位为字节。</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><strong>nextTick(callback)</strong> 一旦当前事件循环结束，调用回调函数。</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left"><strong>umask([mask])</strong> 设置或读取进程文件的掩码。子进程从父进程继承掩码。如果mask 参数有效，返回旧的掩码。否则，返回当前掩码。</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left"><strong>uptime()</strong> 返回 Node 已经运行的秒数。</td>
</tr>
<tr>
<td style="text-align:left">17</td>
<td style="text-align:left"><strong>hrtime()</strong> 返回当前进程的高分辨时间，形式为 [seconds, nanoseconds]数组。它是相对于过去的任意事件。该值与日期无关，因此不受时钟漂移的影响。主要用途是可以通过精确的时间间隔，来衡量程序的性能。 你可以将之前的结果传递给当前的 process.hrtime() ，会返回两者间的时间差，用来基准和测量时间间隔</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出当前目录</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'当前目录: '</span> + process.cwd());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出当前版本</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'当前版本: '</span> + process.version);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出内存使用情况</span></span><br><span class="line"><span class="built_in">console</span>.log(process.memoryUsage());</span><br></pre></td></tr></table></figure>
<h2 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h2><p>util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心 JavaScript 的功能 过于精简的不足。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li><p>util.callbackify</p>
<p><strong>util.callbackify(original)</strong> 将 <code>async</code> 异步函数（或者一个返回值为 <code>Promise</code> 的函数）转换成遵循异常优先的<strong>回调风格</strong>的函数，例如将 <code>(err, value) =&gt; ...</code> 回调作为最后一个参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>)</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello world'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> callbackFunction = util.callbackify(fn);</span><br><span class="line"></span><br><span class="line">callbackFunction(<span class="function">(<span class="params">err, ret</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(ret);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>回调函数是异步执行的，并且有异常堆栈错误跟踪。如果回调函数抛出一个异常，进程就会触发<code>uncaughtException</code>,如果没有被捕获，进程就会推出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> callbackFunction = util.callbackify(fn);</span><br><span class="line"></span><br><span class="line">callbackFunction(<span class="function">(<span class="params">err, ret</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 当 Promise 被以 `null` 拒绝时，它被包装为 Error 并且原始值存储在 `reason` 中。</span></span><br><span class="line">  err &amp;&amp; err.hasOwnProperty(<span class="string">'reason'</span>) &amp;&amp; err.reason === <span class="literal">null</span>;  <span class="comment">// true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>util.inherits</p>
<p><strong>util.inherits(constructor, superConstructor)</strong> 是一个实现对象间原型继承的函数。</p>
<p>JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有提供对象继承的语言级别特性，而是通过原型复制来实现的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>); </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Base</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'base'</span>; </span><br><span class="line">    <span class="keyword">this</span>.base = <span class="number">1991</span>; </span><br><span class="line">    <span class="keyword">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello '</span> + <span class="keyword">this</span>.name); </span><br><span class="line">    &#125;; </span><br><span class="line">&#125; </span><br><span class="line">Base.prototype.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'sub'</span>; </span><br><span class="line">&#125; </span><br><span class="line">util.inherits(Sub, Base); </span><br><span class="line"><span class="keyword">var</span> objBase = <span class="keyword">new</span> Base(); </span><br><span class="line">objBase.showName(); </span><br><span class="line">objBase.sayHello(); </span><br><span class="line"><span class="built_in">console</span>.log(objBase); </span><br><span class="line"><span class="keyword">var</span> objSub = <span class="keyword">new</span> Sub(); </span><br><span class="line">objSub.showName(); </span><br><span class="line"><span class="comment">//objSub.sayHello(); </span></span><br><span class="line"><span class="built_in">console</span>.log(objSub);</span><br></pre></td></tr></table></figure>
</li>
<li><p>util.inspect</p>
<p><strong>util.inspect(object,[showHidden],[depth],[colors])</strong> 是一个将任意对象转换 为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>); </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'byvoid'</span>; </span><br><span class="line">    <span class="keyword">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name; </span><br><span class="line">    &#125;; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="built_in">console</span>.log(util.inspect(obj)); </span><br><span class="line"><span class="built_in">console</span>.log(util.inspect(obj, <span class="literal">true</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>util.isArray(obj)</p>
<p>如果给定的参数 “object” 是一个数组返回 true，否则返回 false。</p>
</li>
<li><p>util.isRegExp(object)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line">util.isRegExp(<span class="regexp">/some regexp/</span>)</span><br><span class="line">  <span class="comment">// true</span></span><br><span class="line">util.isRegExp(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'another regexp'</span>))</span><br><span class="line">  <span class="comment">// true</span></span><br><span class="line">util.isRegExp(&#123;&#125;)</span><br><span class="line">  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>util.isDate(obj)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line">util.isDate(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">  <span class="comment">// true</span></span><br><span class="line">util.isDate(<span class="built_in">Date</span>())</span><br><span class="line">  <span class="comment">// false (without 'new' returns a String)</span></span><br><span class="line">util.isDate(&#123;&#125;)</span><br><span class="line">  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><blockquote>
<p>Node.js提供了一组类似UNIX/POSIX标准的文件操作API。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li><p>异步和同步</p>
<p>fs模块中的方法均提供了同步和异步version。</p>
<p>异步的方法函数的最后一个参数为回调函数，回调函数的第一个参数包含了错误信息</p>
<p>异步的方法性能更高，速度更快，没有阻塞。</p>
</li>
<li><p>打开文件</p>
<p>fs.open(path, flags[, mode], callback)</p>
<ul>
<li><strong>path</strong> - 文件的路径。</li>
<li><strong>flags</strong> - 文件打开的行为。具体值详见下文。</li>
<li><strong>mode</strong> - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。</li>
<li><strong>callback</strong> - 回调函数，带有两个参数如：callback(err, fd)。</li>
</ul>
<p>| Flag | 描述                                                   |<br>| :—- | :——————————————————————————- |<br>| r    | 以读取模式打开文件。如果文件不存在抛出异常。           |<br>| r+   | 以读写模式打开文件。如果文件不存在抛出异常。           |<br>| rs   | 以同步的方式读取文件。                                 |<br>| rs+  | 以同步的方式读取和写入文件。                           |<br>| w    | 以写入模式打开文件，如果文件不存在则创建。             |<br>| wx   | 类似 ‘w’，但是如果文件路径存在，则文件写入失败。       |<br>| w+   | 以读写模式打开文件，如果文件不存在则创建。             |<br>| wx+  | 类似 ‘w+’， 但是如果文件路径存在，则文件读写失败。     |<br>| a    | 以追加模式打开文件，如果文件不存在则创建。             |<br>| ax   | 类似 ‘a’， 但是如果文件路径存在，则文件追加失败。      |<br>| a+   | 以读取追加模式打开文件，如果文件不存在则创建。         |<br>| ax+  | 类似 ‘a+’， 但是如果文件路径存在，则文件读取追加失败。 |</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步打开文件</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"准备打开文件！"</span>);</span><br><span class="line">fs.open(<span class="string">'input.txt'</span>, <span class="string">'r+'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, fd</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"文件打开成功！"</span>);     </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取文件信息</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.stat(path, callback)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>path</strong> - 文件路径。</li>
<li><strong>callback</strong> - 回调函数，带有两个参数如：(err, stats), <strong>stats</strong> 是 fs.Stats 对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"准备打开文件！"</span>);</span><br><span class="line">fs.stat(<span class="string">'input.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(stats);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"读取文件信息成功！"</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 检测文件类型</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"是否为文件(isFile) ? "</span> + stats.isFile());</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"是否为目录(isDirectory) ? "</span> + stats.isDirectory());    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>| 方法                      | 描述                                                         |<br>| :———————————— | :—————————————————————————————- |<br>| stats.isFile()            | 如果是文件返回 true，否则返回 false。                        |<br>| stats.isDirectory()       | 如果是目录返回 true，否则返回 false。                        |<br>| stats.isBlockDevice()     | 如果是块设备返回 true，否则返回 false。                      |<br>| stats.isCharacterDevice() | 如果是字符设备返回 true，否则返回 false。                    |<br>| stats.isSymbolicLink()    | 如果是软链接返回 true，否则返回 false。                      |<br>| stats.isFIFO()            | 如果是FIFO，返回true，否则返回 false。FIFO是UNIX中的一种特殊类型的命令管道。 |<br>| stats.isSocket()          | 如果是 Socket 返回 true，否则返回 false。                    |</p>
</li>
<li><p>写入文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.writeFile(file, data[, options], callback)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>file</strong> - 文件名或文件描述符。</li>
<li><strong>data</strong> - 要写入文件的数据，可以是 String(字符串) 或 Buffer(缓冲) 对象。</li>
<li><strong>options</strong> - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为 utf8, 模式为 0666 ， flag 为 ‘w’</li>
<li><strong>callback</strong> - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"准备写入文件"</span>);</span><br><span class="line">fs.writeFile(<span class="string">'input.txt'</span>, <span class="string">'我是通 过fs.writeFile 写入文件的内容'</span>,  <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"数据写入成功！"</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"--------我是分割线-------------"</span>)</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"读取写入的数据！"</span>);</span><br><span class="line">   fs.readFile(<span class="string">'input.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"异步读取文件数据: "</span> + data.toString());</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.read(fd, buffer, offset, length, position, callback)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>fd</strong> - 通过 fs.open() 方法返回的文件描述符。</li>
<li><strong>buffer</strong> - 数据写入的缓冲区。</li>
<li><strong>offset</strong> - 缓冲区写入的写入偏移量。</li>
<li><strong>length</strong> - 要从文件中读取的字节数。</li>
<li><strong>position</strong> - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。</li>
<li><strong>callback</strong> - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer.alloc(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"准备打开已存在的文件！"</span>);</span><br><span class="line">fs.open(<span class="string">'input.txt'</span>, <span class="string">'r+'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, fd</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"文件打开成功！"</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"准备读取文件："</span>);</span><br><span class="line">   fs.read(fd, buf, <span class="number">0</span>, buf.length, <span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, bytes</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err)&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(bytes + <span class="string">"  字节被读取"</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 仅输出读取的字节</span></span><br><span class="line">      <span class="keyword">if</span>(bytes &gt; <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(buf.slice(<span class="number">0</span>, bytes).toString());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.close(fd, callback)</span><br></pre></td></tr></table></figure>
<p>参数使用说明如下：</p>
<ul>
<li><strong>fd</strong> - 通过 fs.open() 方法返回的文件描述符。</li>
<li><strong>callback</strong> - 回调函数，没有参数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer.alloc(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"准备打开文件！"</span>);</span><br><span class="line">fs.open(<span class="string">'input.txt'</span>, <span class="string">'r+'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, fd</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"文件打开成功！"</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"准备读取文件！"</span>);</span><br><span class="line">   fs.read(fd, buf, <span class="number">0</span>, buf.length, <span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, bytes</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err)&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 仅输出读取的字节</span></span><br><span class="line">      <span class="keyword">if</span>(bytes &gt; <span class="number">0</span>)&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(buf.slice(<span class="number">0</span>, bytes).toString());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 关闭文件</span></span><br><span class="line">      fs.close(fd, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (err)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">         &#125; </span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">"文件关闭成功"</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>截取文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.ftruncate(fd, len, callback)</span><br></pre></td></tr></table></figure>
<p>参数使用说明如下：</p>
<ul>
<li><strong>fd</strong> - 通过 fs.open() 方法返回的文件描述符。</li>
<li><strong>len</strong> - 文件内容截取的长度。</li>
<li><strong>callback</strong> - 回调函数，没有参数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer.alloc(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"准备打开文件！"</span>);</span><br><span class="line">fs.open(<span class="string">'input.txt'</span>, <span class="string">'r+'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, fd</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"文件打开成功！"</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"截取10字节内的文件内容，超出部分将被去除。"</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 截取文件</span></span><br><span class="line">   fs.ftruncate(fd, <span class="number">10</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err)&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"文件截取成功。"</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"读取相同的文件"</span>); </span><br><span class="line">      fs.read(fd, buf, <span class="number">0</span>, buf.length, <span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, bytes</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (err)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 仅输出读取的字节</span></span><br><span class="line">         <span class="keyword">if</span>(bytes &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(buf.slice(<span class="number">0</span>, bytes).toString());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 关闭文件</span></span><br><span class="line">         fs.close(fd, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (err)&#123;</span><br><span class="line">               <span class="built_in">console</span>.log(err);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"文件关闭成功！"</span>);</span><br><span class="line">         &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.unlink(path, callback)</span><br></pre></td></tr></table></figure>
<p>参数使用说明如下：</p>
<ul>
<li><strong>path</strong> - 文件路径。</li>
<li><strong>callback</strong> - 回调函数，没有参数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"准备删除文件！"</span>);</span><br><span class="line">fs.unlink(<span class="string">'input.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"文件删除成功！"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建目录</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.mkdir(path[, options], callback)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>path</strong> - 文件路径。</li>
<li>options 参数可以是：<ul>
<li><strong>recursive</strong> - 是否以递归的方式创建目录，默认为 false。</li>
<li><strong>mode</strong> - 设置目录权限，默认为 0777。</li>
</ul>
</li>
<li><strong>callback</strong> - 回调函数，没有参数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.mkdir(<span class="string">'/tmp/a/apple'</span>, &#123; <span class="attr">recursive</span>: <span class="literal">true</span> &#125;, (err) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>读取目录</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.readdir(path, callback)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>path</strong> - 文件路径。</li>
<li><strong>callback</strong> - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为 目录下的文件数组列表。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"查看 /tmp 目录"</span>);</span><br><span class="line">fs.readdir(<span class="string">"/tmp/"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err, files</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   files.forEach( <span class="function"><span class="keyword">function</span> (<span class="params">file</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log( file );</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除目录</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fs.rmdir(path, callback)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>path</strong> - 文件路径。</li>
<li><strong>callback</strong> - 回调函数，没有参数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="comment">// 执行前创建一个空的 /tmp/test 目录</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"准备删除目录 /tmp/test"</span>);</span><br><span class="line">fs.rmdir(<span class="string">"/tmp/test"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (err) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"读取 /tmp 目录"</span>);</span><br><span class="line">   fs.readdir(<span class="string">"/tmp/"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err, files</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">      &#125;</span><br><span class="line">      files.forEach( <span class="function"><span class="keyword">function</span> (<span class="params">file</span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log( file );</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">方法 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>fs.rename(oldPath, newPath, callback)</strong> 异步 rename().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>fs.ftruncate(fd, len, callback)</strong> 异步 ftruncate().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>fs.ftruncateSync(fd, len)</strong> 同步 ftruncate()</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>fs.truncate(path, len, callback)</strong> 异步 truncate().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>fs.truncateSync(path, len)</strong> 同步 truncate()</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>fs.chown(path, uid, gid, callback)</strong> 异步 chown().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>fs.chownSync(path, uid, gid)</strong> 同步 chown()</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><strong>fs.fchown(fd, uid, gid, callback)</strong> 异步 fchown().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><strong>fs.fchownSync(fd, uid, gid)</strong> 同步 fchown()</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><strong>fs.lchown(path, uid, gid, callback)</strong> 异步 lchown().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><strong>fs.lchownSync(path, uid, gid)</strong> 同步 lchown()</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><strong>fs.chmod(path, mode, callback)</strong> 异步 chmod().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><strong>fs.chmodSync(path, mode)</strong> 同步 chmod().</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><strong>fs.fchmod(fd, mode, callback)</strong> 异步 fchmod().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left"><strong>fs.fchmodSync(fd, mode)</strong> 同步 fchmod().</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left"><strong>fs.lchmod(path, mode, callback)</strong> 异步 lchmod().回调函数没有参数，但可能抛出异常。Only available on Mac OS X.</td>
</tr>
<tr>
<td style="text-align:left">17</td>
<td style="text-align:left"><strong>fs.lchmodSync(path, mode)</strong> 同步 lchmod().</td>
</tr>
<tr>
<td style="text-align:left">18</td>
<td style="text-align:left"><strong>fs.stat(path, callback)</strong> 异步 stat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。</td>
</tr>
<tr>
<td style="text-align:left">19</td>
<td style="text-align:left"><strong>fs.lstat(path, callback)</strong> 异步 lstat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。</td>
</tr>
<tr>
<td style="text-align:left">20</td>
<td style="text-align:left"><strong>fs.fstat(fd, callback)</strong> 异步 fstat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。</td>
</tr>
<tr>
<td style="text-align:left">21</td>
<td style="text-align:left"><strong>fs.statSync(path)</strong> 同步 stat(). 返回 fs.Stats 的实例。</td>
</tr>
<tr>
<td style="text-align:left">22</td>
<td style="text-align:left"><strong>fs.lstatSync(path)</strong> 同步 lstat(). 返回 fs.Stats 的实例。</td>
</tr>
<tr>
<td style="text-align:left">23</td>
<td style="text-align:left"><strong>fs.fstatSync(fd)</strong> 同步 fstat(). 返回 fs.Stats 的实例。</td>
</tr>
<tr>
<td style="text-align:left">24</td>
<td style="text-align:left"><strong>fs.link(srcpath, dstpath, callback)</strong> 异步 link().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">25</td>
<td style="text-align:left"><strong>fs.linkSync(srcpath, dstpath)</strong> 同步 link().</td>
</tr>
<tr>
<td style="text-align:left">26</td>
<td style="text-align:left"><strong>fs.symlink(srcpath, dstpath[, type], callback)</strong> 异步 symlink().回调函数没有参数，但可能抛出异常。 type 参数可以设置为 ‘dir’, ‘file’, 或 ‘junction’ (默认为 ‘file’) 。</td>
</tr>
<tr>
<td style="text-align:left">27</td>
<td style="text-align:left"><strong>fs.symlinkSync(srcpath, dstpath[, type])</strong> 同步 symlink().</td>
</tr>
<tr>
<td style="text-align:left">28</td>
<td style="text-align:left"><strong>fs.readlink(path, callback)</strong> 异步 readlink(). 回调函数有两个参数 err, linkString。</td>
</tr>
<tr>
<td style="text-align:left">29</td>
<td style="text-align:left"><strong>fs.realpath(path[, cache], callback)</strong> 异步 realpath(). 回调函数有两个参数 err, resolvedPath。</td>
</tr>
<tr>
<td style="text-align:left">30</td>
<td style="text-align:left"><strong>fs.realpathSync(path[, cache])</strong> 同步 realpath()。返回绝对路径。</td>
</tr>
<tr>
<td style="text-align:left">31</td>
<td style="text-align:left"><strong>fs.unlink(path, callback)</strong> 异步 unlink().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">32</td>
<td style="text-align:left"><strong>fs.unlinkSync(path)</strong> 同步 unlink().</td>
</tr>
<tr>
<td style="text-align:left">33</td>
<td style="text-align:left"><strong>fs.rmdir(path, callback)</strong> 异步 rmdir().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">34</td>
<td style="text-align:left"><strong>fs.rmdirSync(path)</strong> 同步 rmdir().</td>
</tr>
<tr>
<td style="text-align:left">35</td>
<td style="text-align:left"><strong>fs.mkdir(path[, mode], callback)</strong> S异步 mkdir(2).回调函数没有参数，但可能抛出异常。 访问权限默认为 0777。</td>
</tr>
<tr>
<td style="text-align:left">36</td>
<td style="text-align:left"><strong>fs.mkdirSync(path[, mode])</strong> 同步 mkdir().</td>
</tr>
<tr>
<td style="text-align:left">37</td>
<td style="text-align:left"><strong>fs.readdir(path, callback)</strong> 异步 readdir(3). 读取目录的内容。</td>
</tr>
<tr>
<td style="text-align:left">38</td>
<td style="text-align:left"><strong>fs.readdirSync(path)</strong> 同步 readdir().返回文件数组列表。</td>
</tr>
<tr>
<td style="text-align:left">39</td>
<td style="text-align:left"><strong>fs.close(fd, callback)</strong> 异步 close().回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">40</td>
<td style="text-align:left"><strong>fs.closeSync(fd)</strong> 同步 close().</td>
</tr>
<tr>
<td style="text-align:left">41</td>
<td style="text-align:left"><strong>fs.open(path, flags[, mode], callback)</strong> 异步打开文件。</td>
</tr>
<tr>
<td style="text-align:left">42</td>
<td style="text-align:left"><strong>fs.openSync(path, flags[, mode])</strong> 同步 version of fs.open().</td>
</tr>
<tr>
<td style="text-align:left">43</td>
<td style="text-align:left"><strong>fs.utimes(path, atime, mtime, callback)</strong></td>
</tr>
<tr>
<td style="text-align:left">44</td>
<td style="text-align:left"><strong>fs.utimesSync(path, atime, mtime)</strong> 修改文件时间戳，文件通过指定的文件路径。</td>
</tr>
<tr>
<td style="text-align:left">45</td>
<td style="text-align:left"><strong>fs.futimes(fd, atime, mtime, callback)</strong></td>
</tr>
<tr>
<td style="text-align:left">46</td>
<td style="text-align:left"><strong>fs.futimesSync(fd, atime, mtime)</strong> 修改文件时间戳，通过文件描述符指定。</td>
</tr>
<tr>
<td style="text-align:left">47</td>
<td style="text-align:left"><strong>fs.fsync(fd, callback)</strong> 异步 fsync.回调函数没有参数，但可能抛出异常。</td>
</tr>
<tr>
<td style="text-align:left">48</td>
<td style="text-align:left"><strong>fs.fsyncSync(fd)</strong> 同步 fsync.</td>
</tr>
<tr>
<td style="text-align:left">49</td>
<td style="text-align:left"><strong>fs.write(fd, buffer, offset, length[, position], callback)</strong> 将缓冲区内容写入到通过文件描述符指定的文件。</td>
</tr>
<tr>
<td style="text-align:left">50</td>
<td style="text-align:left"><strong>fs.write(fd, data[, position[, encoding]], callback)</strong> 通过文件描述符 fd 写入文件内容。</td>
</tr>
<tr>
<td style="text-align:left">51</td>
<td style="text-align:left"><strong>fs.writeSync(fd, buffer, offset, length[, position])</strong> 同步版的 fs.write()。</td>
</tr>
<tr>
<td style="text-align:left">52</td>
<td style="text-align:left"><strong>fs.writeSync(fd, data[, position[, encoding]])</strong> 同步版的 fs.write().</td>
</tr>
<tr>
<td style="text-align:left">53</td>
<td style="text-align:left"><strong>fs.read(fd, buffer, offset, length, position, callback)</strong> 通过文件描述符 fd 读取文件内容。</td>
</tr>
<tr>
<td style="text-align:left">54</td>
<td style="text-align:left"><strong>fs.readSync(fd, buffer, offset, length, position)</strong> 同步版的 fs.read.</td>
</tr>
<tr>
<td style="text-align:left">55</td>
<td style="text-align:left"><strong>fs.readFile(filename[, options], callback)</strong> 异步读取文件内容。</td>
</tr>
<tr>
<td style="text-align:left">56</td>
<td style="text-align:left"><strong>fs.readFileSync(filename[, options])</strong></td>
</tr>
<tr>
<td style="text-align:left">57</td>
<td style="text-align:left"><strong>fs.writeFile(filename, data[, options], callback)</strong> 异步写入文件内容。</td>
</tr>
<tr>
<td style="text-align:left">58</td>
<td style="text-align:left"><strong>fs.writeFileSync(filename, data[, options])</strong> 同步版的 fs.writeFile。</td>
</tr>
<tr>
<td style="text-align:left">59</td>
<td style="text-align:left"><strong>fs.appendFile(filename, data[, options], callback)</strong> 异步追加文件内容。</td>
</tr>
<tr>
<td style="text-align:left">60</td>
<td style="text-align:left"><strong>fs.appendFileSync(filename, data[, options])</strong> The 同步 version of fs.appendFile.</td>
</tr>
<tr>
<td style="text-align:left">61</td>
<td style="text-align:left"><strong>fs.watchFile(filename[, options], listener)</strong> 查看文件的修改。</td>
</tr>
<tr>
<td style="text-align:left">62</td>
<td style="text-align:left"><strong>fs.unwatchFile(filename[, listener])</strong> 停止查看 filename 的修改。</td>
</tr>
<tr>
<td style="text-align:left">63</td>
<td style="text-align:left"><strong>fs.watch(filename[, options][, listener])</strong> 查看 filename 的修改，filename 可以是文件或目录。返回 fs.FSWatcher 对象。</td>
</tr>
<tr>
<td style="text-align:left">64</td>
<td style="text-align:left"><strong>fs.exists(path, callback)</strong> 检测给定的路径是否存在。</td>
</tr>
<tr>
<td style="text-align:left">65</td>
<td style="text-align:left"><strong>fs.existsSync(path)</strong> 同步版的 fs.exists.</td>
</tr>
<tr>
<td style="text-align:left">66</td>
<td style="text-align:left"><strong>fs.access(path[, mode], callback)</strong> 测试指定路径用户权限。</td>
</tr>
<tr>
<td style="text-align:left">67</td>
<td style="text-align:left"><strong>fs.accessSync(path[, mode])</strong> 同步版的 fs.access。</td>
</tr>
<tr>
<td style="text-align:left">68</td>
<td style="text-align:left"><strong>fs.createReadStream(path[, options])</strong> 返回ReadStream 对象。</td>
</tr>
<tr>
<td style="text-align:left">69</td>
<td style="text-align:left"><strong>fs.createWriteStream(path[, options])</strong> 返回 WriteStream 对象。</td>
</tr>
<tr>
<td style="text-align:left">70</td>
<td style="text-align:left"><strong>fs.symlink(srcpath, dstpath[, type], callback)</strong> 异步 symlink().回调函数没有参数，但可能抛出异常。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="GET-POST请求"><a href="#GET-POST请求" class="headerlink" title="　GET/POST请求"></a>　GET/POST请求</h2><ol>
<li><p>获取GET请求内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"> </span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain; charset=utf-8'</span>&#125;);</span><br><span class="line">    res.end(util.inspect(url.parse(req.url, <span class="literal">true</span>)));</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取url参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"> </span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 解析 url 参数</span></span><br><span class="line">    <span class="keyword">var</span> params = url.parse(req.url, <span class="literal">true</span>).query;</span><br><span class="line">    res.write(<span class="string">"网站名："</span> + params.name);</span><br><span class="line">    res.write(<span class="string">"\n"</span>);</span><br><span class="line">    res.write(<span class="string">"网站 URL："</span> + params.url);</span><br><span class="line">    res.end();</span><br><span class="line"> </span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取POST请求内容</p>
<p>POST 请求的内容全部的都在请求体中，http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。</p>
<p>比如上传文件，而很多时候我们可能并不需要理会请求体的内容，恶意的POST请求会大大消耗服务器的资源，所以 node.js 默认是不会解析请求体的，当你需要的时候，需要手动来做。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"> </span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 定义了一个post变量，用于暂存请求体的信息</span></span><br><span class="line">    <span class="keyword">var</span> post = <span class="string">''</span>;     </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中</span></span><br><span class="line">    req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;    </span><br><span class="line">        post += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。</span></span><br><span class="line">    req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">        post = querystring.parse(post);</span><br><span class="line">        res.end(util.inspect(post));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> postHTML = </span><br><span class="line">  <span class="string">'&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;菜鸟教程 Node.js 实例&lt;/title&gt;&lt;/head&gt;'</span> +</span><br><span class="line">  <span class="string">'&lt;body&gt;'</span> +</span><br><span class="line">  <span class="string">'&lt;form method="post"&gt;'</span> +</span><br><span class="line">  <span class="string">'网站名： &lt;input name="name"&gt;&lt;br&gt;'</span> +</span><br><span class="line">  <span class="string">'网站 URL： &lt;input name="url"&gt;&lt;br&gt;'</span> +</span><br><span class="line">  <span class="string">'&lt;input type="submit"&gt;'</span> +</span><br><span class="line">  <span class="string">'&lt;/form&gt;'</span> +</span><br><span class="line">  <span class="string">'&lt;/body&gt;&lt;/html&gt;'</span>;</span><br><span class="line"> </span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> body = <span class="string">""</span>;</span><br><span class="line">  req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    body += chunk;</span><br><span class="line">  &#125;);</span><br><span class="line">  req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 解析参数</span></span><br><span class="line">    body = querystring.parse(body);</span><br><span class="line">    <span class="comment">// 设置响应头部信息及编码</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/html; charset=utf8'</span>&#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(body.name &amp;&amp; body.url) &#123; <span class="comment">// 输出提交的数据</span></span><br><span class="line">        res.write(<span class="string">"网站名："</span> + body.name);</span><br><span class="line">        res.write(<span class="string">"&lt;br&gt;"</span>);</span><br><span class="line">        res.write(<span class="string">"网站 URL："</span> + body.url);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 输出表单</span></span><br><span class="line">        res.write(postHTML);</span><br><span class="line">    &#125;</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工具模块"><a href="#工具模块" class="headerlink" title="工具模块"></a>工具模块</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">模块名 &amp; 描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://www.runoob.com/nodejs/nodejs-os-module.html" target="_blank" rel="noopener"><strong>OS 模块</strong></a> 提供基本的系统操作函数。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><a href="https://www.runoob.com/nodejs/nodejs-path-module.html" target="_blank" rel="noopener"><strong>Path 模块</strong></a> 提供了处理和转换文件路径的工具。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><a href="https://www.runoob.com/nodejs/nodejs-net-module.html" target="_blank" rel="noopener"><strong>Net 模块</strong></a> 用于底层的网络通信。提供了服务端和客户端的的操作。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><a href="https://www.runoob.com/nodejs/nodejs-dns-module.html" target="_blank" rel="noopener"><strong>DNS 模块</strong></a> 用于解析域名。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><a href="https://www.runoob.com/nodejs/nodejs-domain-module.html" target="_blank" rel="noopener"><strong>Domain 模块</strong></a> 简化异步代码的异常处理，可以捕捉处理try catch无法捕捉的。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Web模块"><a href="#Web模块" class="headerlink" title="Web模块"></a>Web模块</h2><p><img src="/images/nodejs/web_architecture.jpg" alt="web_architecture"></p>
<ul>
<li><strong>Client</strong> - 客户端，一般指浏览器，浏览器可以通过 HTTP 协议向服务器请求数据。</li>
<li><strong>Server</strong> - 服务端，一般指 Web 服务器，可以接收客户端请求，并向客户端发送响应数据。</li>
<li><strong>Business</strong> - 业务层， 通过 Web 服务器处理应用程序，如与数据库交互，逻辑运算，调用外部程序等。</li>
<li><strong>Data</strong> - 数据层，一般由数据库组成。</li>
</ul>
<ol>
<li><p>创建服务器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 创建服务器</span></span><br><span class="line">http.createServer( <span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;  </span><br><span class="line">   <span class="comment">// 解析请求，包括文件名</span></span><br><span class="line">   <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 输出请求的文件名</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">" received."</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 从文件系统中读取请求的文件内容</span></span><br><span class="line">   fs.readFile(pathname.substr(<span class="number">1</span>), <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(err);</span><br><span class="line">         <span class="comment">// HTTP 状态码: 404 : NOT FOUND</span></span><br><span class="line">         <span class="comment">// Content Type: text/html</span></span><br><span class="line">         response.writeHead(<span class="number">404</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/html'</span>&#125;);</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;             </span><br><span class="line">         <span class="comment">// HTTP 状态码: 200 : OK</span></span><br><span class="line">         <span class="comment">// Content Type: text/html</span></span><br><span class="line">         response.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/html'</span>&#125;);    </span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 响应文件内容</span></span><br><span class="line">         response.write(data.toString());        </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//  发送响应数据</span></span><br><span class="line">      response.end();</span><br><span class="line">   &#125;);   </span><br><span class="line">&#125;).listen(<span class="number">8080</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 控制台会输出以下信息</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:8080/'</span>);</span><br></pre></td></tr></table></figure>
<p>在同一目录下创建index.html文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建客户端</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 用于请求的选项</span></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">   host: <span class="string">'localhost'</span>,</span><br><span class="line">   port: <span class="string">'8080'</span>,</span><br><span class="line">   path: <span class="string">'/index.html'</span>  </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 处理响应的回调函数</span></span><br><span class="line"><span class="keyword">var</span> callback = <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">   <span class="comment">// 不断更新数据</span></span><br><span class="line">   <span class="keyword">var</span> body = <span class="string">''</span>;</span><br><span class="line">   response.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      body += data;</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   response.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 数据接收完成</span></span><br><span class="line">      <span class="built_in">console</span>.log(body);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向服务端发送请求</span></span><br><span class="line"><span class="keyword">var</span> req = http.request(options, callback);</span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Express框架"><a href="#Express框架" class="headerlink" title="Express框架"></a>Express框架</h2><blockquote>
<p>Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。</p>
</blockquote>
<p>使用 Express 可以快速地搭建一个完整功能的网站。</p>
<p>Express 框架核心特性：</p>
<ul>
<li>可以设置中间件来响应 HTTP 请求。</li>
<li>定义了路由表用于执行不同的 HTTP 请求动作。</li>
<li>可以通过向模板传递参数来动态渲染 HTML 页面。</li>
</ul>
<p>安装 Express 并将其保存到依赖列表中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cnpm install express --save</span></span><br></pre></td></tr></table></figure>
<p>以上命令会将 Express 框架安装在当前目录的 <strong>node_modules</strong> 目录中， <strong>node_modules</strong> 目录下会自动创建 express 目录。以下几个重要的模块是需要与 express 框架一起安装的：</p>
<ul>
<li><strong>body-parser</strong> - node.js 中间件，用于处理 JSON, Raw, Text 和 URL 编码的数据。</li>
<li><strong>cookie-parser</strong> - 这就是一个解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象。</li>
<li><strong>multer</strong> - node.js 中间件，用于处理 enctype=”multipart/form-data”（设置表单的MIME编码）的表单数据。</li>
</ul>
<h3 id="Express框架实例"><a href="#Express框架实例" class="headerlink" title="Express框架实例"></a>Express框架实例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//express_demo.js 文件</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"> </span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   res.send(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8081</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> host = server.address().address</span><br><span class="line">  <span class="keyword">var</span> port = server.address().port</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"应用实例，访问地址为 http://%s:%s"</span>, host, port)</span><br><span class="line"> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h3><p>Express 应用使用回调函数的参数： <strong>request</strong> 和 <strong>response</strong> 对象来处理请求和响应的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// --</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>Request 对象</strong> - request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。常见属性有：</p>
<ol>
<li>req.app：当callback为外部文件时，用req.app访问express的实例</li>
<li>req.baseUrl：获取路由当前安装的URL路径</li>
<li>req.body / req.cookies：获得「请求主体」/ Cookies</li>
<li>req.fresh / req.stale：判断请求是否还「新鲜」</li>
<li>req.hostname / req.ip：获取主机名和IP地址</li>
<li>req.originalUrl：获取原始请求URL</li>
<li>req.params：获取路由的parameters</li>
<li>req.path：获取请求路径</li>
<li>req.protocol：获取协议类型</li>
<li>req.query：获取URL的查询参数串</li>
<li>req.route：获取当前匹配的路由</li>
<li>req.subdomains：获取子域名</li>
<li>req.accepts()：检查可接受的请求的文档类型</li>
<li>req.acceptsCharsets / req.acceptsEncodings / req.acceptsLanguages：返回指定字符集的第一个可接受字符编码</li>
<li>req.get()：获取指定的HTTP请求头</li>
<li>req.is()：判断请求头Content-Type的MIME类型</li>
</ol>
<p><strong>Response 对象</strong> - response 对象表示 HTTP 响应，即在接收到请求时向客户端发送的 HTTP 响应数据。常见属性有：</p>
<ol>
<li>res.app：同req.app一样</li>
<li>res.append()：追加指定HTTP头</li>
<li>res.set()在res.append()后将重置之前设置的头</li>
<li>res.cookie(name，value [，option])：设置Cookie</li>
<li>opition: domain / expires / httpOnly / maxAge / path / secure / signed</li>
<li>res.clearCookie()：清除Cookie</li>
<li>res.download()：传送指定路径的文件</li>
<li>res.get()：返回指定的HTTP头</li>
<li>res.json()：传送JSON响应</li>
<li>res.jsonp()：传送JSONP响应</li>
<li>res.location()：只设置响应的Location HTTP头，不设置状态码或者close response</li>
<li>res.redirect()：设置响应的Location HTTP头，并且设置状态码302</li>
<li>res.render(view,[locals],callback)：渲染一个view，同时向callback传递渲染后的字符串，如果在渲染过程中有错误发生next(err)将会被自动调用。callback将会被传入一个可能发生的错误以及渲染后的页面，这样就不会自动输出了。</li>
<li>res.send()：传送HTTP响应</li>
<li>res.sendFile(path [，options] [，fn])：传送指定路径的文件 -会自动根据文件extension设定Content-Type</li>
<li>res.set()：设置HTTP头，传入object可以一次设置多个头</li>
<li>res.status()：设置HTTP状态码</li>
<li>res.type()：设置Content-Type的MIME类型</li>
</ol>
<h3 id="路由-1"><a href="#路由-1" class="headerlink" title="路由"></a>路由</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//  主页输出 "Hello World"</span></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"主页 GET 请求"</span>);</span><br><span class="line">   res.send(<span class="string">'Hello GET'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//  POST 请求</span></span><br><span class="line">app.post(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"主页 POST 请求"</span>);</span><br><span class="line">   res.send(<span class="string">'Hello POST'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//  /del_user 页面响应</span></span><br><span class="line">app.get(<span class="string">'/del_user'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"/del_user 响应 DELETE 请求"</span>);</span><br><span class="line">   res.send(<span class="string">'删除页面'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">//  /list_user 页面 GET 请求</span></span><br><span class="line">app.get(<span class="string">'/list_user'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"/list_user GET 请求"</span>);</span><br><span class="line">   res.send(<span class="string">'用户列表页面'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 对页面 abcd, abxcd, ab123cd, 等响应 GET 请求</span></span><br><span class="line">app.get(<span class="string">'/ab*cd'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;   </span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"/ab*cd GET 请求"</span>);</span><br><span class="line">   res.send(<span class="string">'正则匹配'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8081</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> host = server.address().address</span><br><span class="line">  <span class="keyword">var</span> port = server.address().port</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"应用实例，访问地址为 http://%s:%s"</span>, host, port)</span><br><span class="line"> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h3><p>Express 提供了内置的中间件 <strong>express.static</strong> 来设置静态文件如：图片， CSS, JavaScript 等。</p>
<p>你可以使用 <strong>express.static</strong> 中间件来设置静态文件路径。例如，如果你将图片， CSS, JavaScript 文件放在 public 目录下，你可以这么写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">'/public'</span>, express.static(<span class="string">'public'</span>));</span><br></pre></td></tr></table></figure>
<h3 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法"></a>GET方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/process_get'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出 JSON 格式</span></span><br><span class="line">   <span class="keyword">var</span> response = &#123;</span><br><span class="line">       <span class="string">"first_name"</span>:req.query.first_name, <span class="comment">//获取提交的GET参数</span></span><br><span class="line">       <span class="string">"last_name"</span>:req.query.last_name</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="built_in">console</span>.log(response);</span><br><span class="line">   res.end(<span class="built_in">JSON</span>.stringify(response));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="POST方法"><a href="#POST方法" class="headerlink" title="POST方法"></a>POST方法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.post(<span class="string">'/process_post'</span>, urlencodedParser, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出 JSON 格式</span></span><br><span class="line">   <span class="keyword">var</span> response = &#123;</span><br><span class="line">       <span class="string">"first_name"</span>:req.body.first_name,</span><br><span class="line">       <span class="string">"last_name"</span>:req.body.last_name</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="built_in">console</span>.log(response);</span><br><span class="line">   res.end(<span class="built_in">JSON</span>.stringify(response));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>以下我们创建一个用于上传文件的表单，使用 POST 方法，表单 enctype 属性设置为 multipart/form-data。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);</span><br><span class="line"><span class="keyword">var</span> multer  = <span class="built_in">require</span>(<span class="string">'multer'</span>);</span><br><span class="line"> </span><br><span class="line">app.use(<span class="string">'/public'</span>, express.static(<span class="string">'public'</span>));</span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br><span class="line">app.use(multer(&#123; <span class="attr">dest</span>: <span class="string">'/tmp/'</span>&#125;).array(<span class="string">'image'</span>));</span><br><span class="line"> </span><br><span class="line">app.get(<span class="string">'/index.htm'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   res.sendFile( __dirname + <span class="string">"/"</span> + <span class="string">"index.htm"</span> );</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">app.post(<span class="string">'/file_upload'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="built_in">console</span>.log(req.files[<span class="number">0</span>]);  <span class="comment">// 上传的文件信息</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">var</span> des_file = __dirname + <span class="string">"/"</span> + req.files[<span class="number">0</span>].originalname;</span><br><span class="line">   fs.readFile( req.files[<span class="number">0</span>].path, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        fs.writeFile(des_file, data, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">         <span class="keyword">if</span>( err )&#123;</span><br><span class="line">              <span class="built_in">console</span>.log( err );</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               response = &#123;</span><br><span class="line">                   message:<span class="string">'File uploaded successfully'</span>, </span><br><span class="line">                   filename:req.files[<span class="number">0</span>].originalname</span><br><span class="line">              &#125;;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">console</span>.log( response );</span><br><span class="line">          res.end( <span class="built_in">JSON</span>.stringify( response ) );</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">8081</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> host = server.address().address</span><br><span class="line">  <span class="keyword">var</span> port = server.address().port</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"应用实例，访问地址为 http://%s:%s"</span>, host, port)</span><br><span class="line"> </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Cookie-管理"><a href="#Cookie-管理" class="headerlink" title="Cookie 管理"></a>Cookie 管理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// express_cookie.js 文件</span></span><br><span class="line"><span class="keyword">var</span> express      = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>)</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line">app.use(cookieParser())</span><br><span class="line"> </span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Cookies: "</span> + util.inspect(req.cookies));</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line">app.listen(<span class="number">8081</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>Express官网： <a href="http://expressjs.com/" target="_blank" rel="noopener">http://expressjs.com/</a></li>
<li>Express4.x API 中文版： <a href="https://www.runoob.com/w3cnote/express-4-x-api.html" target="_blank" rel="noopener">Express4.x API Chinese</a></li>
<li>Express4.x API：<a href="http://expressjs.com/zh-cn/4x/api.html" target="_blank" rel="noopener">http://expressjs.com/zh-cn/4x/api.html</a></li>
</ul>
<h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h2><blockquote>
<p>REST即表述性状态传递（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。</p>
<p>表述性状态转移是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful。需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML（标准通用标记语言下的一个子集）以及HTML（标准通用标记语言下的一个应用）这些现有的广泛流行的协议和标准。REST 通常使用 JSON 数据格式。</p>
</blockquote>
<h3 id="HTTP-方法"><a href="#HTTP-方法" class="headerlink" title="HTTP 方法"></a>HTTP 方法</h3><p>以下为 REST 基本架构的四个方法：</p>
<ul>
<li><strong>GET</strong> - 用于获取数据。</li>
<li><strong>PUT</strong> - 用于更新或添加数据。</li>
<li><strong>DELETE</strong> - 用于删除数据。</li>
<li><strong>POST</strong> - 用于添加数据。</li>
</ul>
<h3 id="RESTful-Web-Services"><a href="#RESTful-Web-Services" class="headerlink" title="RESTful Web Services"></a>RESTful Web Services</h3><p>Web service是一个平台独立的，低耦合的，自包含的、基于可编程的web的应用程序，可使用开放的XML（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的互操作的应用程序。</p>
<p>基于 REST 架构的 Web Services 即是 RESTful。</p>
<p>由于轻量级以及通过 HTTP 直接传输数据的特性，Web 服务的 RESTful 方法已经成为最常见的替代方法。可以使用各种语言（比如 Java 程序、Perl、Ruby、Python、PHP 和 Javascript[包括 Ajax]）实现客户端。</p>
<p>RESTful Web 服务通常可以通过自动客户端或代表用户的应用程序访问。但是，这种服务的简便性让用户能够与之直接交互，使用它们的 Web 浏览器构建一个 GET URL 并读取返回的内容。</p>
<p>更多介绍，可以查看：<a href="https://www.runoob.com/w3cnote/restful-architecture.html" target="_blank" rel="noopener">RESTful 架构详解</a></p>
<h3 id="创建RESTful"><a href="#创建RESTful" class="headerlink" title="创建RESTful"></a>创建RESTful</h3><p>首先，创建一个 json 数据资源文件 users.json，内容如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"user1"</span> : &#123;</span><br><span class="line">      <span class="attr">"name"</span> : <span class="string">"mahesh"</span>,</span><br><span class="line">      <span class="attr">"password"</span> : <span class="string">"password1"</span>,</span><br><span class="line">      <span class="attr">"profession"</span> : <span class="string">"teacher"</span>,</span><br><span class="line">      <span class="attr">"id"</span>: <span class="number">1</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"user2"</span> : &#123;</span><br><span class="line">      <span class="attr">"name"</span> : <span class="string">"suresh"</span>,</span><br><span class="line">      <span class="attr">"password"</span> : <span class="string">"password2"</span>,</span><br><span class="line">      <span class="attr">"profession"</span> : <span class="string">"librarian"</span>,</span><br><span class="line">      <span class="attr">"id"</span>: <span class="number">2</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"user3"</span> : &#123;</span><br><span class="line">      <span class="attr">"name"</span> : <span class="string">"ramesh"</span>,</span><br><span class="line">      <span class="attr">"password"</span> : <span class="string">"password3"</span>,</span><br><span class="line">      <span class="attr">"profession"</span> : <span class="string">"clerk"</span>,</span><br><span class="line">      <span class="attr">"id"</span>: <span class="number">3</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于以上数据，我们创建以下 RESTful API：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">URI</th>
<th style="text-align:left">HTTP 方法</th>
<th style="text-align:left">发送内容</th>
<th style="text-align:left">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">listUsers</td>
<td style="text-align:left">GET</td>
<td style="text-align:left">空</td>
<td style="text-align:left">显示所有用户列表</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">addUser</td>
<td style="text-align:left">POST</td>
<td style="text-align:left">JSON 字符串</td>
<td style="text-align:left">添加新用户</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">deleteUser</td>
<td style="text-align:left">DELETE</td>
<td style="text-align:left">JSON 字符串</td>
<td style="text-align:left">删除用户</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">:id</td>
<td style="text-align:left">GET</td>
<td style="text-align:left">空</td>
<td style="text-align:left">显示用户详细信息</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/listUsers'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   fs.readFile( __dirname + <span class="string">"/"</span> + <span class="string">"users.json"</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log( data );</span><br><span class="line">       res.end( data );</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加的新用户数据</span></span><br><span class="line"><span class="keyword">var</span> user = &#123;</span><br><span class="line">   <span class="string">"user4"</span> : &#123;</span><br><span class="line">      <span class="string">"name"</span> : <span class="string">"mohit"</span>,</span><br><span class="line">      <span class="string">"password"</span> : <span class="string">"password4"</span>,</span><br><span class="line">      <span class="string">"profession"</span> : <span class="string">"teacher"</span>,</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">4</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/addUser'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 读取已存在的数据</span></span><br><span class="line">   fs.readFile( __dirname + <span class="string">"/"</span> + <span class="string">"users.json"</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">       data = <span class="built_in">JSON</span>.parse( data );</span><br><span class="line">       data[<span class="string">"user4"</span>] = user[<span class="string">"user4"</span>];</span><br><span class="line">       <span class="built_in">console</span>.log( data );</span><br><span class="line">       res.end( <span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/:id'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 首先我们读取已存在的用户</span></span><br><span class="line">   fs.readFile( __dirname + <span class="string">"/"</span> + <span class="string">"users.json"</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">       data = <span class="built_in">JSON</span>.parse( data );</span><br><span class="line">       <span class="keyword">var</span> user = data[<span class="string">"user"</span> + req.params.id] </span><br><span class="line">       <span class="built_in">console</span>.log( user );</span><br><span class="line">       res.end( <span class="built_in">JSON</span>.stringify(user));</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/deleteUser'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// First read existing users.</span></span><br><span class="line">   fs.readFile( __dirname + <span class="string">"/"</span> + <span class="string">"users.json"</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">       data = <span class="built_in">JSON</span>.parse( data );</span><br><span class="line">       <span class="keyword">delete</span> data[<span class="string">"user"</span> + id];</span><br><span class="line">       </span><br><span class="line">       <span class="built_in">console</span>.log( data );</span><br><span class="line">       res.end( <span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><blockquote>
<p>我们都知道 Node.js 是以单线程的模式运行的，但它使用的是事件驱动来处理并发，这样有助于我们在多核 cpu 的系统上创建多个子进程，从而提高性能。</p>
<p>每个子进程总是带有三个流对象：child.stdin, child.stdout 和child.stderr。他们可能会共享父进程的 stdio 流，或者也可以是独立的被导流的流对象。</p>
</blockquote>
<p>Node 提供了 child_process 模块来创建子进程，方法有：</p>
<ul>
<li><strong>exec</strong> - child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。</li>
<li><strong>spawn</strong> - child_process.spawn 使用指定的命令行参数创建新进程。</li>
<li><strong>fork</strong> - child_process.fork 是 spawn()的特殊形式，用于在子进程中运行的模块，如 fork(‘./son.js’) 相当于 spawn(‘node’, [‘./son.js’]) 。与spawn方法不同的是，fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">child_process.exec(command[, options], callback)</span><br></pre></td></tr></table></figure>
<p><strong>command：</strong> 字符串， 将要运行的命令，参数使用空格隔开</p>
<p><strong>options ：对象，可以是：</strong></p>
<ul>
<li>cwd ，字符串，子进程的当前工作目录</li>
<li>env，对象 环境变量键值对</li>
<li>encoding ，字符串，字符编码（默认： ‘utf8’）</li>
<li>shell ，字符串，将要执行命令的 Shell（默认: 在 UNIX 中为<code>/bin/sh</code>， 在 Windows 中为<code>cmd.exe</code>， Shell 应当能识别 <code>-c</code>开关在 UNIX 中，或 <code>/s /c</code> 在 Windows 中。 在Windows 中，命令行解析应当能兼容<code>cmd.exe</code>）</li>
<li>timeout，数字，超时时间（默认： 0）</li>
<li>maxBuffer，数字， 在 stdout 或 stderr 中允许存在的最大缓冲（二进制），如果超出那么子进程将会被杀死 （默认: 200*1024）</li>
<li>killSignal ，字符串，结束信号（默认：’SIGTERM’）</li>
<li>uid，数字，设置用户进程的 ID</li>
<li>gid，数字，设置进程组的 ID</li>
</ul>
<p><strong>callback ：</strong>回调函数，包含三个参数error, stdout 和 stderr。</p>
<p>exec() 方法返回最大的缓冲区，并等待进程结束，一次性返回缓冲区的内容。</p>
<p>support.js 文件代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"进程 "</span> + process.argv[<span class="number">2</span>] + <span class="string">" 执行。"</span> );</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> workerProcess = child_process.exec(<span class="string">'node support.js '</span>+i, <span class="function"><span class="keyword">function</span> (<span class="params">error, stdout, stderr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error.stack);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Error code: '</span>+error.code);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Signal received: '</span>+error.signal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'stdout: '</span> + stdout);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'stderr: '</span> + stderr);</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    workerProcess.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'子进程已退出，退出码 '</span>+code);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">child_process.spawn(command[, args][, options])</span><br></pre></td></tr></table></figure>
<p>参数说明如下：</p>
<p><strong>command：</strong> 将要运行的命令</p>
<p><strong>args：</strong> Array 字符串参数数组</p>
<p><strong>options Object</strong></p>
<ul>
<li>cwd String 子进程的当前工作目录</li>
<li>env Object 环境变量键值对</li>
<li>stdio Array|String 子进程的 stdio 配置</li>
<li>detached Boolean 这个子进程将会变成进程组的领导</li>
<li>uid Number 设置用户进程的 ID</li>
<li>gid Number 设置进程组的 ID</li>
</ul>
<p>spawn() 方法返回流 (stdout &amp; stderr)，在进程返回大量数据时使用。进程一旦开始执行时 spawn() 就开始接收响应。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">   <span class="keyword">var</span> workerProcess = child_process.spawn(<span class="string">'node'</span>, [<span class="string">'support.js'</span>, i]);</span><br><span class="line"> </span><br><span class="line">   workerProcess.stdout.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'stdout: '</span> + data);</span><br><span class="line">   &#125;);</span><br><span class="line"> </span><br><span class="line">   workerProcess.stderr.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'stderr: '</span> + data);</span><br><span class="line">   &#125;);</span><br><span class="line"> </span><br><span class="line">   workerProcess.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'子进程已退出，退出码 '</span>+code);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">child_process.fork(modulePath[, args][, options])</span><br></pre></td></tr></table></figure>
<p>参数说明如下：</p>
<p><strong>modulePath</strong>： String，将要在子进程中运行的模块</p>
<p><strong>args</strong>： Array 字符串参数数组</p>
<p><strong>options</strong>：Object</p>
<ul>
<li>cwd String 子进程的当前工作目录</li>
<li>env Object 环境变量键值对</li>
<li>execPath String 创建子进程的可执行文件</li>
<li>execArgv Array 子进程的可执行文件的字符串参数数组（默认： process.execArgv）</li>
<li>silent Boolean 如果为<code>true</code>，子进程的<code>stdin</code>，<code>stdout</code>和<code>stderr</code>将会被关联至父进程，否则，它们将会从父进程中继承。（默认为：<code>false</code>）</li>
<li>uid Number 设置用户进程的 ID</li>
<li>gid Number 设置进程组的 ID</li>
</ul>
<p>返回的对象除了拥有ChildProcess实例的所有方法，还有一个内建的通信信道。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">   <span class="keyword">var</span> worker_process = child_process.fork(<span class="string">"support.js"</span>, [i]);    </span><br><span class="line"> </span><br><span class="line">   worker_process.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'子进程已退出，退出码 '</span> + code);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cnpm install mysql</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mysql      = <span class="built_in">require</span>(<span class="string">'mysql'</span>);</span><br><span class="line"><span class="keyword">var</span> connection = mysql.createConnection(&#123;</span><br><span class="line">  host     : <span class="string">'localhost'</span>,</span><br><span class="line">  user     : <span class="string">'root'</span>,</span><br><span class="line">  password : <span class="string">'123456'</span>,</span><br><span class="line">  database : <span class="string">'test'</span></span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">connection.connect();</span><br><span class="line"> </span><br><span class="line">connection.query(<span class="string">'SELECT 1 + 1 AS solution'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, results, fields</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) <span class="keyword">throw</span> error;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The solution is: '</span>, results[<span class="number">0</span>].solution);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">host</td>
<td style="text-align:left">主机地址 （默认：localhost）</td>
</tr>
<tr>
<td style="text-align:left">user</td>
<td style="text-align:left">用户名</td>
</tr>
<tr>
<td style="text-align:left">password</td>
<td style="text-align:left">密码</td>
</tr>
<tr>
<td style="text-align:left">port</td>
<td style="text-align:left">端口号 （默认：3306）</td>
</tr>
<tr>
<td style="text-align:left">database</td>
<td style="text-align:left">数据库名</td>
</tr>
<tr>
<td style="text-align:left">charset</td>
<td style="text-align:left">连接字符集（默认：’UTF8_GENERAL_CI’，注意字符集的字母都要大写）</td>
</tr>
<tr>
<td style="text-align:left">localAddress</td>
<td style="text-align:left">此IP用于TCP连接（可选）</td>
</tr>
<tr>
<td style="text-align:left">socketPath</td>
<td style="text-align:left">连接到unix域路径，当使用 host 和 port 时会被忽略</td>
</tr>
<tr>
<td style="text-align:left">timezone</td>
<td style="text-align:left">时区（默认：’local’）</td>
</tr>
<tr>
<td style="text-align:left">connectTimeout</td>
<td style="text-align:left">连接超时（默认：不限制；单位：毫秒）</td>
</tr>
<tr>
<td style="text-align:left">stringifyObjects</td>
<td style="text-align:left">是否序列化对象</td>
</tr>
<tr>
<td style="text-align:left">typeCast</td>
<td style="text-align:left">是否将列值转化为本地JavaScript类型值 （默认：true）</td>
</tr>
<tr>
<td style="text-align:left">queryFormat</td>
<td style="text-align:left">自定义query语句格式化方法</td>
</tr>
<tr>
<td style="text-align:left">supportBigNumbers</td>
<td style="text-align:left">数据库支持bigint或decimal类型列时，需要设此option为true （默认：false）</td>
</tr>
<tr>
<td style="text-align:left">bigNumberStrings</td>
<td style="text-align:left">supportBigNumbers和bigNumberStrings启用 强制bigint或decimal列以JavaScript字符串类型返回（默认：false）</td>
</tr>
<tr>
<td style="text-align:left">dateStrings</td>
<td style="text-align:left">强制timestamp,datetime,data类型以字符串类型返回，而不是JavaScript Date类型（默认：false）</td>
</tr>
<tr>
<td style="text-align:left">debug</td>
<td style="text-align:left">开启调试（默认：false）</td>
</tr>
<tr>
<td style="text-align:left">multipleStatements</td>
<td style="text-align:left">是否许一个query中有多个MySQL语句 （默认：false）</td>
</tr>
<tr>
<td style="text-align:left">flags</td>
<td style="text-align:left">用于修改连接标志</td>
</tr>
<tr>
<td style="text-align:left">ssl</td>
<td style="text-align:left">使用ssl参数（与crypto.createCredenitals参数格式一至）或一个包含ssl配置文件名称的字符串，目前只捆绑Amazon RDS的配置文件</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mysql  = <span class="built_in">require</span>(<span class="string">'mysql'</span>);  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> connection = mysql.createConnection(&#123;     </span><br><span class="line">  host     : <span class="string">'localhost'</span>,       </span><br><span class="line">  user     : <span class="string">'root'</span>,              </span><br><span class="line">  password : <span class="string">'123456'</span>,       </span><br><span class="line">  port: <span class="string">'3306'</span>,                   </span><br><span class="line">  database: <span class="string">'test'</span> </span><br><span class="line">&#125;); </span><br><span class="line"> </span><br><span class="line">connection.connect();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span>  sql = <span class="string">'SELECT * FROM websites'</span>;</span><br><span class="line"><span class="comment">//查</span></span><br><span class="line">connection.query(sql,<span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'[SELECT ERROR] - '</span>,err.message);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'--------------------------SELECT----------------------------'</span>);</span><br><span class="line">       <span class="built_in">console</span>.log(result);</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'------------------------------------------------------------\n\n'</span>);  </span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span>  addSql = <span class="string">'INSERT INTO websites(Id,name,url,alexa,country) VALUES(0,?,?,?,?)'</span>;</span><br><span class="line"><span class="keyword">var</span>  addSqlParams = [<span class="string">'12'</span>, <span class="string">'fas'</span>,<span class="string">'23453'</span>, <span class="string">'CN'</span>];</span><br><span class="line"><span class="comment">//增</span></span><br><span class="line">connection.query(addSql,addSqlParams,<span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'[INSERT ERROR] - '</span>,err.message);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">        &#125;        </span><br><span class="line"> </span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'--------------------------INSERT----------------------------'</span>);</span><br><span class="line">       <span class="comment">//console.log('INSERT ID:',result.insertId);        </span></span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'INSERT ID:'</span>,result);        </span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'-----------------------------------------------------------------\n\n'</span>);  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> modSql = <span class="string">'UPDATE websites SET name = ?,url = ? WHERE Id = ?'</span>;</span><br><span class="line"><span class="keyword">var</span> modSqlParams = [<span class="string">'菜鸟移动站'</span>, <span class="string">'https://m.runoob.com'</span>,<span class="number">6</span>];</span><br><span class="line"><span class="comment">//改</span></span><br><span class="line">connection.query(modSql,modSqlParams,<span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(err)&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'[UPDATE ERROR] - '</span>,err.message);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">   &#125;        </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'--------------------------UPDATE----------------------------'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'UPDATE affectedRows'</span>,result.affectedRows);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'-----------------------------------------------------------------\n\n'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> delSql = <span class="string">'DELETE FROM websites where id=6'</span>;</span><br><span class="line"><span class="comment">//删</span></span><br><span class="line">connection.query(delSql,<span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'[DELETE ERROR] - '</span>,err.message);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;        </span><br><span class="line"> </span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'--------------------------DELETE----------------------------'</span>);</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'DELETE affectedRows'</span>,result.affectedRows);</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'-----------------------------------------------------------------\n\n'</span>);  </span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">connection.end();</span><br></pre></td></tr></table></figure>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cnpm install mongodb</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> MongoClient = <span class="built_in">require</span>(<span class="string">'mongodb'</span>).MongoClient;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'mongodb://localhost:27017/runoob'</span>;</span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'数据库已创建'</span>);</span><br><span class="line">    <span class="keyword">var</span> dbase = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    dbase.createCollection(<span class="string">'site'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"创建集合!"</span>);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="keyword">var</span> myobj = &#123; <span class="attr">name</span>: <span class="string">"菜鸟教程"</span>, <span class="attr">url</span>: <span class="string">"www.runoob"</span> &#125;;</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).insertOne(myobj, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"文档插入成功"</span>);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="keyword">var</span> myobj =  [</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">'菜鸟工具'</span>, <span class="attr">url</span>: <span class="string">'https://c.runoob.com'</span>, <span class="attr">type</span>: <span class="string">'cn'</span>&#125;,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">'Google'</span>, <span class="attr">url</span>: <span class="string">'https://www.google.com'</span>, <span class="attr">type</span>: <span class="string">'en'</span>&#125;,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">'Facebook'</span>, <span class="attr">url</span>: <span class="string">'https://www.google.com'</span>, <span class="attr">type</span>: <span class="string">'en'</span>&#125;</span><br><span class="line">       ];</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).insertMany(myobj, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"插入的文档数量为: "</span> + res.insertedCount);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>). find(&#123;&#125;).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123; <span class="comment">// 返回集合中所有数据</span></span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">     <span class="keyword">var</span> whereStr = &#123;<span class="string">"name"</span>:<span class="string">'菜鸟教程'</span>&#125;;  <span class="comment">// 查询条件</span></span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).find(whereStr).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="keyword">var</span> whereStr = &#123;<span class="string">"name"</span>:<span class="string">'菜鸟教程'</span>&#125;;  <span class="comment">// 查询条件</span></span><br><span class="line">    <span class="keyword">var</span> updateStr = &#123;<span class="attr">$set</span>: &#123; <span class="string">"url"</span> : <span class="string">"https://www.runoob.com"</span> &#125;&#125;;</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).updateOne(whereStr, updateStr, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"文档更新成功"</span>);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="keyword">var</span> whereStr = &#123;<span class="string">"type"</span>:<span class="string">'en'</span>&#125;;  <span class="comment">// 查询条件</span></span><br><span class="line">    <span class="keyword">var</span> updateStr = &#123;<span class="attr">$set</span>: &#123; <span class="string">"url"</span> : <span class="string">"https://www.runoob.com"</span> &#125;&#125;;</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).updateMany(whereStr, updateStr, <span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">         <span class="built_in">console</span>.log(res.result.nModified + <span class="string">" 条文档被更新"</span>);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="keyword">var</span> whereStr = &#123;<span class="string">"name"</span>:<span class="string">'菜鸟教程'</span>&#125;;  <span class="comment">// 查询条件</span></span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).deleteOne(whereStr, <span class="function"><span class="keyword">function</span>(<span class="params">err, obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"文档删除成功"</span>);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="keyword">var</span> whereStr = &#123; <span class="attr">type</span>: <span class="string">"en"</span> &#125;;  <span class="comment">// 查询条件</span></span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).deleteMany(whereStr, <span class="function"><span class="keyword">function</span>(<span class="params">err, obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(obj.result.n + <span class="string">" 条文档被删除"</span>);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="keyword">var</span> mysort = &#123; <span class="attr">type</span>: <span class="number">1</span> &#125;;</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).find().sort(mysort).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).find().limit(<span class="number">2</span>).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        db.close();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    dbo.collection(<span class="string">"site"</span>).find().skip(<span class="number">2</span>).limit(<span class="number">2</span>).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        db.close();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">  dbo.collection(<span class="string">'orders'</span>).aggregate([</span><br><span class="line">    &#123; <span class="attr">$lookup</span>:</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">from</span>: <span class="string">'products'</span>,            <span class="comment">// 右集合</span></span><br><span class="line">         localField: <span class="string">'product_id'</span>,    <span class="comment">// 左集合 join 字段</span></span><br><span class="line">         foreignField: <span class="string">'_id'</span>,         <span class="comment">// 右集合 join 字段</span></span><br><span class="line">         <span class="keyword">as</span>: <span class="string">'orderdetails'</span>           <span class="comment">// 新生成字段（类型array）</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    ]).toArray(<span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">    db.close();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MongoClient.connect(url, &#123; <span class="attr">useNewUrlParser</span>: <span class="literal">true</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, db</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="keyword">var</span> dbo = db.db(<span class="string">"runoob"</span>);</span><br><span class="line">    <span class="comment">// 删除 test 集合</span></span><br><span class="line">    dbo.collection(<span class="string">"test"</span>).drop(<span class="function"><span class="keyword">function</span>(<span class="params">err, delOK</span>) </span>&#123;  <span class="comment">// 执行成功 delOK 返回 true，否则返回 false</span></span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="keyword">if</span> (delOK) <span class="built_in">console</span>.log(<span class="string">"集合已删除"</span>);</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2019/11/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><hr>
<h2 id="create-创建型设计模式"><a href="#create-创建型设计模式" class="headerlink" title="create 创建型设计模式"></a>create 创建型设计模式</h2><h3 id="Abstract-Factory-抽象工厂"><a href="#Abstract-Factory-抽象工厂" class="headerlink" title="Abstract Factory 抽象工厂"></a>Abstract Factory 抽象工厂</h3><ol>
<li><p>意图</p>
<blockquote>
<p>提供一个创建一系列相关或相互依赖对象的接口,而无需指定他们具体的类</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>一个系统要独立于它的产品的创建,组合和表示.</li>
<li>一个系统要由多个产品系列中的一个来配置时.</li>
<li>当要强调一系列相关的产品对象的设计以便进行联合使用时.</li>
<li>当提供一个产品类库,只想显示他们的接口而不是实现的时候.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/abstract_factory.png" alt="抽象工厂"></p>
<h3 id="Builder-生成器"><a href="#Builder-生成器" class="headerlink" title="Builder 生成器"></a>Builder 生成器</h3><ol>
<li><p>意图</p>
<blockquote>
<p>将一个复杂对象的构建与它的表示进行分离,使得同样的构建过程可以创建不同的表示.</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式时.</li>
<li>当构造过程必须允许被构造的对象有不同的表示时.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/builder.png" alt="生成器"><br><img src="/images/diagram/builder_seq.png" alt="生成器"></p>
<p>​    </p>
<h3 id="Factory-工厂方法"><a href="#Factory-工厂方法" class="headerlink" title="Factory 工厂方法"></a>Factory 工厂方法</h3><ol>
<li><p>意图</p>
<blockquote>
<p>定义一个用于创建对象的接口,让子类决定事例化那一个类,Factory Method<br> 使一个类的实例化延迟要子类.</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>当一个类不知道所必须创建的对象的类的时候.</li>
<li>当一个类希望由它的子类来指定它所创建的对象的时候.</li>
<li>当类将创建对象的职责委托给多个帮助子类中的某一个,并且你希望将哪一个帮助子类是代理<br>者这一信息局部化的时候.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/factory.png" alt="工厂方法"></p>
<p>​    </p>
<h3 id="Prototype-原型"><a href="#Prototype-原型" class="headerlink" title="Prototype 原型"></a>Prototype 原型</h3><ol>
<li><p>意图</p>
<blockquote>
<p>用原型实例指定创建类的种类,并且通过拷贝这些原型创建新的对象.</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>当一个系统应该独立于它的产品的创建.构成和表示的时候.</li>
<li>当要实例化的类是在运行时刻指定的时,如动态加载</li>
<li>当要避免创建一个与产品类层次平行的工厂类层次时.</li>
<li>当一个类的实例只能有几个不同状态组合中的一种时.建立相应数目的原型并克隆他们可能比每次用何时的状态手工实例化<br>该类更加方便一些. </li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/prototype.png" alt="原型"></p>
<h3 id="Singleton-单件"><a href="#Singleton-单件" class="headerlink" title="Singleton 单件"></a>Singleton 单件</h3><ol>
<li><p>意图</p>
<blockquote>
<p>保证一个类仅有一个实例,并提供一个全局访问它的全局访问点.</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>当类只能有一个实例,而且用户可以从一个众所周知的访问点访问它.</li>
<li>当这个唯一的实例应该是通过子类化可以拓展的,并且用户应该无需更改代码就能使用一个扩展的实例.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/singleton.png" alt="单件"></p>
<h3 id="创建性模式总结"><a href="#创建性模式总结" class="headerlink" title="创建性模式总结"></a>创建性模式总结</h3><blockquote>
<p>用一个系统创建的那些对象的类对系统进行参数化有两种常用方法:</p>
</blockquote>
<ol>
<li><p>一种生产创建对象的子类,对应工厂方法模式.缺点是为了改变产品类,就可能需要创建一个新类.这样的改变可能是级联的.</p>
</li>
<li><p>另一种对系统进行参数化的方法更多依赖于对象复合,定义一个对象负责明确产品对象的<br> 类,并将它作为系统的参数.这就是抽象工厂,Builder,Prototype的关键特征.<br> 所以这三个模式都涉及到创建一个新的负责创建产品对象的””工厂对象”</p>
<ol>
<li>Abstract Factory 由这个工厂对象产生多个类对象.</li>
<li>Builder 由这个工厂对象使用一个相对复杂的协议,逐步创建一个复杂产品.</li>
<li>Prototype 由该工厂对象通过拷贝原型对象来创建产品对象.因为由原型返回对象,<br> 所有工厂对象和原型是同一个对象. </li>
</ol>
</li>
</ol>
<h2 id="structure-结构性模式"><a href="#structure-结构性模式" class="headerlink" title="structure 结构性模式"></a>structure 结构性模式</h2><blockquote>
<p>结构型设计模式涉及到如何组合类和对象以获得更大的结构,结构型类模式采用继承机制来组合接口或实现.</p>
</blockquote>
<h3 id="Adapter-适配器"><a href="#Adapter-适配器" class="headerlink" title="Adapter 适配器"></a>Adapter 适配器</h3><ol>
<li><p>意图</p>
<blockquote>
<p>将一个类的接口转换成客户希望的另一个接口,Adapter模式使得原本由于接口不兼容而不能一起<br> 工作的那些类可以一起工作.</p>
</blockquote>
</li>
<li><p>别名</p>
<blockquote>
<p>包装器 Wrapper</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>你想使用一个已经存在的类,而它的接口不符合你的要求.</li>
<li>你想创建一个可以复用的类,该类可以和其他不相关的类或不可预见的类协同工作.</li>
<li>你想使用一些已经存在的子类,但是不可能对每一个都进行子类化以匹配它们的接口.对象适配器可以适配<br>它的父类接口.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/adapter.png" alt="适配器"></p>
<h3 id="Bridge-桥接"><a href="#Bridge-桥接" class="headerlink" title="Bridge 桥接"></a>Bridge 桥接</h3><ol>
<li><p>意图</p>
<blockquote>
<p>将抽象部分与它的实现部分分离,使它们都可以独立的变化</p>
</blockquote>
</li>
<li><p>别名</p>
<blockquote>
<p>Handle/Body</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>不希望在抽象和它的实现部分之间有一个固定的绑定关系.</li>
<li>类的抽象以及它的实现都应该可以 生成子类的方法加以扩充.</li>
<li>对一个抽象的实现部分的修改对客户不产生影响</li>
<li>想对客户隐藏抽象的实现部分.</li>
<li>有许多类要生成的类层次结构</li>
<li>想在多个对象间共享实现,但客户不知道这一点.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/bridge.png" alt="桥接"><br><img src="/images/diagram/bridge_seq.png" alt="桥接"></p>
<h3 id="Composite-组合"><a href="#Composite-组合" class="headerlink" title="Composite 组合"></a>Composite 组合</h3><ol>
<li><p>意图</p>
<blockquote>
<p>将对象组合成树形结构以表示””部分-整体”的层次结构,Composite使用户对单个对象和组合对象的<br> 使用具有一致性.</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>想表示对象部分—整体层次结构</li>
<li>希望用户忽略组合对象和单个对象的不同,用户将统一的使用组合结构中的所有对象</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/composite.png" alt="组合"></p>
<h3 id="Decorator-装饰"><a href="#Decorator-装饰" class="headerlink" title="Decorator 装饰"></a>Decorator 装饰</h3><ol>
<li><p>意图</p>
<blockquote>
<p>动态的给一个对象添加一些额外的职责.就增加功能而言,装饰者模式比生成子类<br> 更加灵活</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>在不影响其他对象的情况下,以动态,透明的方式给单个对象添加职责</li>
<li>处理那些可以撤销的职责.</li>
<li>当不能采用子类进行扩充的时候.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/decorator.png" alt="装饰者"></p>
<h3 id="Facade-外观"><a href="#Facade-外观" class="headerlink" title="Facade 外观"></a>Facade 外观</h3><ol>
<li><p>意图</p>
<blockquote>
<p>为子系统中的一组接口提供一致的界面,Facade 模式定义了一个高层接口,<br> 这个接口使得子系统更加容易使用.</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>要为一个复杂子系统提供一个简单接口时,子系统往往因为不断演化而变得越来越复杂.</li>
<li>客户程序与抽象类的实现部分存在很大的依赖性.</li>
<li>当需要构建一个层次结构的子系统时,使用facade,模式定义子系统的入口点.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/facade.png" alt="外观"></p>
<h3 id="Flyweight-享元"><a href="#Flyweight-享元" class="headerlink" title="Flyweight 享元"></a>Flyweight 享元</h3><ol>
<li><p>意图</p>
<blockquote>
<p>运用共享技术有效地支持大量细粒度的对象.</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>一个应用程序使用了大量的对象.</li>
<li>完全由于使用了大量的对象,造成很大的存储开销.</li>
<li>对象的大多数状态都可变为外部状态.</li>
<li>如果删除对象的外部状态,那么可以用相对较少的共享对象取代很多对象.</li>
<li>应用程序不依赖对象标识.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/flyweight.png" alt="享元"></p>
<h3 id="Proxy-代理"><a href="#Proxy-代理" class="headerlink" title="Proxy 代理"></a>Proxy 代理</h3><ol>
<li><p>意图</p>
<blockquote>
<p>对其他对象提供一种代理以供其他对象访问</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li></li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/proxy.png" alt="代理"></p>
<h3 id="结构型模式总结"><a href="#结构型模式总结" class="headerlink" title="结构型模式总结"></a>结构型模式总结</h3><ol>
<li><p>Adapter 模式主要解决两个一游接口之间的不匹配问题,不考虑接口如何实现,<br>也不考虑接口如何演化.</p>
</li>
<li><p>Bridge 模式对抽象接口与它的实现部分进行桥接.</p>
</li>
<li><p>Decorator 旨在不需要生成子类即可给对象添加职责.</p>
</li>
<li><p>Composite 旨在构造类,使多个相关的对象能够以统一的方式处理,多重对象可以被<br>当成一个对象来处理.</p>
</li>
<li><p>Proxy 模式构成一个对象并为用户提供一致的接口.</p>
</li>
</ol>
<h2 id="行为设计模式"><a href="#行为设计模式" class="headerlink" title="行为设计模式"></a>行为设计模式</h2><hr>
<blockquote>
<p>行为设计模式设计算法和对象间职责的分配.行为模式不仅描述类和对象的模式,<br>还描述它们之间的通信模式.</p>
</blockquote>
<h3 id="Chain-of-Responsibility-责任链"><a href="#Chain-of-Responsibility-责任链" class="headerlink" title="Chain of Responsibility 责任链"></a>Chain of Responsibility 责任链</h3><ol>
<li><p>意图</p>
<blockquote>
<p>使多个对象都有机会处理请求,从而避免请求的发送者和接受者的耦合关系.<br> 将这些对象连成一条链,并沿着这条链传递该请求,直到有一个对象处理它为止.</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>有多个的对象可以处理一个请求,那个对象处理请求运行时刻自动确定.</li>
<li>想在不明确指定接受者的情况下想多个对象中的一个提交请求.</li>
<li>可以处理一个请求的对象集合被动态指定.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/chain.png" alt="责任链"></p>
<h3 id="Command-命令"><a href="#Command-命令" class="headerlink" title="Command 命令"></a>Command 命令</h3><ol>
<li><p>意图</p>
<blockquote>
<p>将一个请求封装成一个对象,从而使得可以用不同的请求对客户进行参数化,对请求<br> 排队或记录请求日志,以及支持可撤销操作.</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>抽象出待执行的动作以参数化某对象.</li>
<li>在不同的时刻指定,排列和执行请求.</li>
<li>支持取消操作.</li>
<li>支持修改日志.</li>
<li>用构建在原语操作上的高层操作构造一个系统.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/command.png" alt="命令"></p>
<h3 id="Interpreter-解释器"><a href="#Interpreter-解释器" class="headerlink" title="Interpreter 解释器"></a>Interpreter 解释器</h3><ol>
<li><p>意图</p>
<blockquote>
<p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示<br> 来解释语言的句子.</p>
</blockquote>
</li>
<li><p>适用性:</p>
<blockquote>
<p>解释器模式适用于当有一个语言需要解释执行，并且可将该语言的句子表示为一个抽象<br> 语法树时一下情况最好。</p>
</blockquote>
<ul>
<li>该文法简单.</li>
<li>效率不是关键问题.</li>
</ul>
</li>
</ol>
<p><img src="/images/diagram/Interpreter.png" alt="解释器"></p>
<h3 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h3><ol>
<li><p>意图</p>
<blockquote>
<p>提供一种方法顺序访问一个聚合对象的各个元素，且不需要暴露该对象的内部表示。</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>访问一个聚合对象的内容而无须暴露它的内部表示.</li>
<li>支持对聚合对象的多种遍历.</li>
<li>为遍历不同的聚合结构提供一个统一的接口。</li>
</ul>
</li>
</ol>
<h3 id="Mediator-中介者"><a href="#Mediator-中介者" class="headerlink" title="Mediator 中介者"></a>Mediator 中介者</h3><ol>
<li><p>意图</p>
<blockquote>
<p>用一个中介对象来封装一系列对象的交互。中介者使各对象不需要显示地互相<br> 引用，从而使其耦合松散，可以独立地改变它们之间的交互</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li>一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解.</li>
<li>一个对象引用其他 很多对象并且与这些对象通信，导致难以复用该对象。</li>
<li>想定制一个分布在多个类中的行为，而不想生成太多的子类。</li>
</ul>
</li>
</ol>
<h3 id="Memento-备忘录"><a href="#Memento-备忘录" class="headerlink" title="Memento 备忘录"></a>Memento 备忘录</h3><ol>
<li><p>意图</p>
<blockquote>
<p>在不破坏封装性的前提下捕获一个对象的内部状态，并在对象之外保存这个状态。<br> 这样以后就可以将对象恢复到原先保存的状态。</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li><p>必须保存一个对象在某一个时刻的（部分）状态，这样以后需要时它才能恢复<br>到先前的状态。</p>
</li>
<li><p>如果一个用接口让其他对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性。</p>
</li>
</ul>
</li>
</ol>
<h3 id="Observer-观察者"><a href="#Observer-观察者" class="headerlink" title="Observer 观察者"></a>Observer 观察者</h3><ol>
<li><p>意图</p>
<blockquote>
<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li><p>当一个抽象模型有两个方面，一个方面依赖另一个方面。将这两者封装在独立的对象中以使他们可以<br>各自独立的改变和使用。</p>
</li>
<li><p>当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变。</p>
</li>
<li><p>当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即不希望这些对象是紧耦合的。</p>
</li>
</ul>
</li>
</ol>
<h3 id="State-状态"><a href="#State-状态" class="headerlink" title="State 状态"></a>State 状态</h3><ol>
<li><p>意图</p>
<blockquote>
<p>允许一个对象在其内部状态改变时改变它的行为。对象似乎修改了它的类。</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li><p>一个对象的行为决定于它的状态，并且它必须在运行时刻根据状态改变它的行为。</p>
</li>
<li><p>一个操作中含有庞大的多分支的条件语句，并且这些分支依赖于该对象的状态。这个状态常用一个或多个枚举常量表示<br>。</p>
</li>
</ul>
</li>
</ol>
<p>​    </p>
<h3 id="Strategy-策略"><a href="#Strategy-策略" class="headerlink" title="Strategy 策略"></a>Strategy 策略</h3><ol>
<li><p>意图</p>
<blockquote>
<p>定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li><p>许多相关的类仅仅行为有异。</p>
</li>
<li><p>需要使用一个算法的不同变体。</p>
</li>
<li><p>算法使客户不应该知道的数据。</p>
</li>
<li><p>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，<br>将相关条件的分支移入它们各自的Strategy类中，以替代这些条件语句。</p>
</li>
</ul>
</li>
</ol>
<h3 id="Template-Method-模板方法"><a href="#Template-Method-模板方法" class="headerlink" title="Template Method 模板方法"></a>Template Method 模板方法</h3><ol>
<li><p>意图</p>
<blockquote>
<p>定义一个操作的算法骨架，而将一些步骤延迟到子类。</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li><p>一次性实现一个算法中不变的部分，将可变的部分留给子类实现。</p>
</li>
<li><p>各子类的公共的行为应该被提取出来并集中到一个公共父类中，避免代码的重复。</p>
</li>
<li><p>控制子类的扩展。模板方法旨在特点调用“hook”操作（默认的行为，子类可以在必要的时候进行重定义扩展），<br>这就只允许在这些点进行扩展。</p>
</li>
</ul>
</li>
</ol>
<h3 id="Visitor-访问者"><a href="#Visitor-访问者" class="headerlink" title="Visitor  访问者"></a>Visitor  访问者</h3><ol>
<li><p>意图</p>
<blockquote>
<p>表示一个作用于某对象结构的各元素的操作，它允许在不改变各元素的类的前提下定义作用于这些元素<br> 的新操作。</p>
</blockquote>
</li>
<li><p>适用性:</p>
<ul>
<li><p>一个对象结构包含很多类对象，它们有不同的接口，而用户想对这些对象实施一些依赖于其具体类的操作。</p>
</li>
<li><p>需要对一个对象结构中的对象进行很多不同并且 不相关的操作，而又想要避免这些操作“污染”这些对象的类。</p>
</li>
<li><p>定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。</p>
</li>
</ul>
</li>
</ol>
<h3 id="行为模式比较"><a href="#行为模式比较" class="headerlink" title="行为模式比较"></a>行为模式比较</h3><ul>
<li>一个Strategy 对象封装一个算法：</li>
<li>一个State对象封装一个与状态相关的行为：</li>
<li>一个Mediator 对象封装对象间的协议：</li>
<li>一个Iterator对象封装访问和遍历一个聚合对象中的各个组件的方法。</li>
<li>Chain of  Responsibility 可以处理任意数目的对象（一条链）</li>
<li>一个Visitor对象是一个多态的Accept操作的参数</li>
<li>在Command 中，令牌代表一个请求</li>
<li>在Memento 中，两台代表一个对象在某个特定时刻的内部状态 </li>
</ul>
]]></content>
      <categories>
        <category>软件开发</category>
      </categories>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2020/04/25/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><blockquote>
<p>R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p>
</blockquote>
<p>特点</p>
<ol>
<li>每个节点是黑色或者红色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点(NIL)是黑色。注：这里的叶子节点，指的是看空（NULL or NIL）的叶子节点</li>
<li>如果一个节点是红色的，则它的子节点必须是黑色。</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑色节点。</li>
</ol>
<ul>
<li>特点3中的叶子节点，只能为空的节点。</li>
<li>特点5，确保没有一条路径会比其他路径长出两倍。因此，红黑树是相对接近平衡的二叉树。</li>
</ul>
<a id="more"></a>
<h2 id="红黑树的应用"><a href="#红黑树的应用" class="headerlink" title="红黑树的应用"></a>红黑树的应用</h2><p>主要用于存储有序的数据，它的时间复杂度是$O(\log n)$，效率非常高。</p>
<p>例如：Java集合中的<code>TreeSet</code>和<code>TreeMap</code>，C++ <code>STL</code> 中的<code>set</code>,<code>map</code>。以及Linux虚拟内存的管理。</p>
<h2 id="红黑树的时间复杂度和相关证明"><a href="#红黑树的时间复杂度和相关证明" class="headerlink" title="红黑树的时间复杂度和相关证明"></a>红黑树的时间复杂度和相关证明</h2><p><strong>红黑树的时间复杂度为：$O\log n$</strong></p>
<p>使用数学归纳法进行证明：</p>
<p>定理：一棵含有n个节点的红黑树的高度至多为$2\log(n+1)$</p>
<p>证明：</p>
<h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><p><a href="https://www.cnblogs.com/skywang12345/p/3245399.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3245399.html</a></p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title>常见数据结构</title>
    <url>/2019/11/28/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="常见的数据结构和算法"><a href="#常见的数据结构和算法" class="headerlink" title="常见的数据结构和算法"></a>常见的数据结构和算法</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p><strong>线性表</strong>$Linear List$是由$n(n \geq 0)$个具有相同类型的数据元素$a_1,a_2,\dots,a_n$组成的有限序列。其中元素的个数$n$定义为表的长度。</p>
<p>非空线性表的逻辑特征：</p>
<ul>
<li>有且仅有一个开始结点$a_1$，该结点没有前趋，仅有一个后继$a_2$。</li>
<li>有且仅有一个终点结点$a<em>n$，该结点没有后继，仅有一个前趋$a</em>{n-1}$</li>
<li>其余内部内部结点$a<em>i \; (2 \leq i \leq n-1)\;$都有且仅有一个前趋$a</em>{i-1}$和一个后继$a_{i+1}$。</li>
</ul>
<p>线性表中的数据元素不限定形式，但同一线性表中的数据元素必须具有相同特性，相邻元素之间存在着序偶。</p>
<h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h3><p>线性表的两种存储表示方法：</p>
<ul>
<li>顺序存储表示</li>
<li>链式存储表示</li>
</ul>
<p>顺序表：线性表的顺序存储指的是把线性表的数据元素按逻辑顺序依次存放一组地址连续的存储单元里。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LISTINCREMENT = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqList_d</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    SqList_d(<span class="keyword">int</span> n);</span><br><span class="line">    ~SqList_d();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SqListInsert</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">SqListDelete</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printAllData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SqList_d::SqList_d(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    elem = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">    maxSize = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SqList_d::~SqList_d()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] elem;</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">    maxSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SqList_d::SqListInsert</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &gt;= maxSize)</span><br><span class="line">    &#123;</span><br><span class="line">        elem = (<span class="keyword">int</span> *)<span class="built_in">realloc</span>(elem, (maxSize + LISTINCREMENT) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; length + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入位置异常"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = length; j &gt;= i; j--)</span><br><span class="line">        elem[j] = elem[j - <span class="number">1</span>];</span><br><span class="line">    elem[i - <span class="number">1</span>] = e;</span><br><span class="line">    length++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SqList_d::SqListDelete</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"溢出"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; length + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"删除位置异常"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    e = elem[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; length; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        elem[j - <span class="number">1</span>] = elem[j];</span><br><span class="line">    &#125;</span><br><span class="line">    length--;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SqList_d::printAllData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Item: "</span> &lt;&lt; i &lt;&lt; <span class="string">" value: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;elem[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    SqList_d la = SqList_d(<span class="number">10</span>);</span><br><span class="line">    la.SqListInsert(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    la.printAllData();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设顺序吧每个数据元素占有$m$个存储单元，且数据元素的存储位置定义为其所占的存储空间中第一个单元的存储地址，则表中相邻的数据元素$a<em>i$和$a</em>{i+1}$的存储位置$LOC(a<em>i)$和$LOC(a</em>{i+1})$也是相邻的，且满足如下关系：</p>
<script type="math/tex; mode=display">LOC(a_{i+1}) = LOC(a_i) + m</script><p>如果知道第一个元素$a_i$的存储位置则：</p>
<script type="math/tex; mode=display">LOC(a_{i}) = LOC(a_1) + (i-1)*m</script><p>由于计算任意数据元素存储地址的时间都是相等的，因此顺序表是一种 <strong>随机存取</strong>$(Random\;Access)$结构</p>
<p>顺序表的优点：</p>
<ul>
<li>节省存储空间</li>
<li>随机存取(直接存取)</li>
</ul>
<p>顺序表的缺点：</p>
<ul>
<li>插入和删除需要移动大量元素</li>
<li>表容量</li>
</ul>
<h3 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h3><p>链式存储结构：用一组地址任意的存储单元来依次存放线性表中的数据元素。</p>
<p>链式存储结构中的每个数据节点需要保存以下两部分信息：</p>
<ul>
<li>存储数据元素自身信息的部分。称为数据域；</li>
<li>存储与前驱和后继结点的逻辑关系。称为指针域。</li>
</ul>
<ol>
<li><p>单链表</p>
<p>单链表：如果结点只包含一个指针域。则称为单链表$Single\;Linked\;List$。</p>
<p>结构为：$\boxed{data|next}$</p>
<p>$data$为数据域，用来存放数据元素自身的信息；$next$为指针域也成链域，用来存放后继结点的地址。</p>
<p>表中的第一个结点$a_1$无前驱，故设置一个头指针$(Head\;Pointer)head$指向$a_1$,此外最后一个结点无后继，故$a_n$的指针域为空。</p>
<script type="math/tex; mode=display">head\;\to\;\boxed{a_1|\quad}\;\to\;\boxed{a_2|\quad}\;\to\;\boxed{a_3|\quad}\;\to\dots\;\to\;\boxed{a_n|\land}</script><p>链式映像或非顺序映像：逻辑上相邻的两个数据元素其存储的物理位置不一定相邻。</p>
<p>单链表是 <strong>非随机存取</strong> 的存储结构。(顺序存取)</p>
<p>单链表基本操作的实现：</p>
<ul>
<li>创建链表<ul>
<li>头插入法</li>
<li>尾插入法</li>
</ul>
</li>
<li>查找操作<ul>
<li>按位序查找</li>
<li>按值查找</li>
</ul>
</li>
<li>插入操作</li>
<li>删除操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Node *Head;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        LinkList();</span><br><span class="line">        ~LinkList();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">CreateList1</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">CreateList2</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ListInsert</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> e)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ListDelete</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">GetElem</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(<span class="keyword">int</span> e)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">ListLength</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkList::CreateList1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//头插法创建线性表：不停的从头部插入</span></span><br><span class="line">    Node *p,*s;</span><br><span class="line">    p = Head;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"请依次输入"</span> &lt;&lt; n &lt;&lt; <span class="string">"个数据元素值："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s = <span class="keyword">new</span> Node;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s-&gt;data;</span><br><span class="line">        s-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态链表</p>
<p>静态链表：指用一维数组表示的单链表。</p>
</li>
<li><p>循环链表</p>
<p>循环链表：一种头尾相连的链表</p>
</li>
<li><p>双向链表</p>
<p>双向链表的结点结构：</p>
<script type="math/tex; mode=display">\boxed{piror|data|next}</script></li>
</ol>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><blockquote>
<p>栈和队列属于特殊的线性表 ，它们在逻辑结构上和线性表相似。栈和队列在操作比一般线性表多一些限制，栈只能在表的一端进行操作，而队列只能在一端进行插入，一端进行删除。</p>
</blockquote>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><strong>栈</strong>：$Stack$，是限定仅在表尾进行插入或删除操作的线性表。</p>
<ul>
<li>栈顶：允许插入和删除的一端。</li>
<li>栈底：另一端。</li>
<li>空栈：当栈中没有任何元素。</li>
<li>进栈(入栈)：将一个元素从栈顶插入到栈的操作。</li>
<li>出栈(弹出):从栈顶删除一个元素的操作。</li>
</ul>
<p>特点：<strong>先进先出</strong>$FIFO$和<strong>后进先出</strong>$LIFO$</p>
<p>栈的抽象数据类型:</p>
<ul>
<li>数据对象：$D={a_i | a_i \in  ElemSet,i=1,2,\cdots,n,n \ge 0}$</li>
<li>数据关系：$R={<a_{i-1},a_i>,a<em>i&gt;|a</em>{i-1},a_i \in D,i=1,2,\cdots,n}$</li>
</ul>
<p>约定$a_n$端为栈顶，$a_1$端为栈底。</p>
<ul>
<li>基本操作：<ul>
<li>$InitStack(\&amp;S)$</li>
<li>$DestroyStack(\&amp;S)$</li>
<li>$CleanStack(\&amp;S)$</li>
<li>$StackEmpty(S)$</li>
<li>$StackLength(S)$</li>
<li>$GetTop(S,\&amp;e)$</li>
<li>$Push(\&amp;S,e)$</li>
<li>$PopStack(\&amp;S,\&amp;e)$</li>
<li>$StackTraverse(S,visit())$</li>
</ul>
</li>
</ul>
<h4 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h4><p>顺序栈：采用顺序存储结构的栈。</p>
<p>顺序栈：利用一组地址连续的存储单元一次存放自栈底到栈顶的数据元素，同时附设$top$指针指示栈顶元素在顺序栈的位置。通常$top=0$表示空栈。</p>
<p>顺序栈的类定义和基本操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *base; <span class="comment">//栈底指针</span></span><br><span class="line">    <span class="keyword">int</span> top;   <span class="comment">//栈顶</span></span><br><span class="line">    <span class="keyword">int</span> stackSize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    SqStack(<span class="keyword">int</span> m);</span><br><span class="line">    ~SqStack()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] base;</span><br><span class="line">        top = <span class="number">-1</span>;</span><br><span class="line">        stackSize = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StackEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StackTranverse</span><span class="params">()</span></span>; <span class="comment">//显示栈中元素</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SqStack::Push</span><span class="params">(<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == stackSize - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"栈满，无法入栈"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    top++;</span><br><span class="line">    base[top] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SqStack::Pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">if</span> (top = <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"栈空，无法出栈"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = base[top--];</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SqStack::GetTop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SqStack::StackTranverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"空栈"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"index: "</span> &lt;&lt; i &lt;&lt; <span class="string">" value: "</span> &lt;&lt; base[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序栈的应用：</p>
<ul>
<li>数制转换</li>
<li>括号匹配的检验</li>
<li>行编辑程序问题</li>
<li>迷宫求解</li>
</ul>
<h4 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h4><p>链栈的结点结构和单链表的结点结构相同。链表只能在栈顶执行插入和删除操作，因此以单链表的头部作为栈顶最方便，而且也没必要为单链表附加头结点链表的头指针即为栈顶指针。</p>
<p>链栈的类定义和基本操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    Node *top;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    LinkStack() &#123; top == <span class="literal">NULL</span>; &#125;;</span><br><span class="line">    ~LinkStack();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetTop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (top != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> top != <span class="literal">NULL</span> ? <span class="number">1</span> : <span class="number">0</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LinkStack::~LinkStack()</span><br><span class="line">&#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">while</span> (top)</span><br><span class="line">    &#123;</span><br><span class="line">        p = top-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> top;</span><br><span class="line">        top = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkStack::Push</span><span class="params">(<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *s = <span class="keyword">new</span> Node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"内存分配失败"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = top;</span><br><span class="line">    top = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkStack::Pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"栈溢出"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x = top-&gt;data;</span><br><span class="line">    Node *p = top;</span><br><span class="line">    top = top-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是线性表的特例。它将元素排列成队，有入口和出口，数据元素只能从队尾入队，从队头离队。队列具有<strong>先进先出 FIFO</strong>或<strong>后进后出LILO</strong></p>
<p><strong>队列</strong>：$Queue$是另一种限定存取位置的线性表。只允许在表的一端进入，在另一端删除，其中允许插入的一端称为<strong>队尾（Rear）</strong>，允许删除的一端称为<strong>队头（Front）</strong></p>
<ul>
<li>入队：从队尾插入元素</li>
<li>出队：从队头删除元素</li>
</ul>
<p>队列的抽象数据类型：</p>
<ul>
<li>数据对象：$D={a_i | a_i \in ElemSet,i=1,2,\cdots,n,n \ge 0}$</li>
<li>数据关系：$R={<a_{i-1},a_i> | a_{i_1},a_i \in D,i=2,\cdots,n}$</li>
</ul>
<p>确定 $a_1$端为队头，$a_n$端为队尾。</p>
<ul>
<li>基本操作：<ul>
<li>$InitQueue(\&amp;Q)$</li>
<li>$DestroyQueue(\&amp;Q)$</li>
<li>$CleanQueue(\&amp;Q)$</li>
<li>$QueueEmpty(Q)$</li>
<li>$QueueLength(Q)$</li>
<li>$GetHead(Q,\&amp;e)$</li>
<li>$EnQueue(\&amp;Q,e)$</li>
<li>$DeQueue(\&amp;Q,\&amp;e)$</li>
<li>$QueueTraverse(Q,visit())$</li>
</ul>
</li>
</ul>
<h4 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h4><p>顺序队列：队列的顺序存储结构。</p>
<p>用一组地址连续的存储单元依次存放从队头到队尾的元素，由于队列的队头和队尾的位置是变化的，因而还需要两个指针front和rear作为队头指针和队尾指针来分别指示队头和队尾在队列中的位置。</p>
<p>当rear大于等于容量时，新元素无法入队，但事实上队列的低端还有空闲的存储单元，这种现象称为“假溢”。</p>
<p>为了解决这种现象引入了循环队列。</p>
<p>解决“假溢”现象的方法：将存储队列的数组看成是头尾相接的圆环，并成为循环存储空间，即允许队列直接从数组中下标最大的位置延续到下标最小的位置。</p>
<p>循环队列$(Circular\;Queue)$：队列的头尾相接的顺序存储结构</p>
<p>这种队列，队空和队满时头尾指针均相等，故无法通过$front==rear$来判断队列“空”还是“满”。</p>
<p>解决这个问题的办法：</p>
<ul>
<li>设置一个布尔变量以区别队列的空和满</li>
<li>少用一个元素空间：约定入队前，测试尾指针在循环意义下加1后是否等于头指针，若相等则认为队满，但实际还有一个空位置</li>
<li>使用一个计数器记录队列中元素的总数，即队列长度。</li>
</ul>
<p>以方法2讨论：</p>
<p>循环队列的长度$(rear-front+QueunSize) \% QueueSize$</p>
<p>循环队列的类定义和基本操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> *base; <span class="comment">//存储空间基址</span></span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">int</span> queueSize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    CQueue(<span class="keyword">int</span> m);</span><br><span class="line">    ~CQueue();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(<span class="keyword">int</span> e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetHead</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetLast</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">QueueDisplay</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CQueue::CQueue(<span class="keyword">int</span> m)</span><br><span class="line">&#123;</span><br><span class="line">    queueSize = m;</span><br><span class="line">    base = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(queueSize * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    front = <span class="number">0</span>;</span><br><span class="line">    rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CQueue::~CQueue()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] base;</span><br><span class="line">    front = <span class="number">0</span>;</span><br><span class="line">    rear = <span class="number">0</span>;</span><br><span class="line">    queueSize = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CQueue::EnQueue</span><span class="params">(<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((rear + <span class="number">1</span>) % (queueSize) == front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"上溢，无法入队"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    base[rear] = e;</span><br><span class="line">    rear = (rear + <span class="number">1</span>) % queueSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CQueue::DeQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (front == rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"下溢，不能出队"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = base[front];</span><br><span class="line">    front = (front + <span class="number">1</span>) % queueSize;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CQueue::GetHead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">if</span> (front == rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"队空，无元素"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = base[front];</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CQueue::GetLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">if</span> (front == rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"队空，无元素"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = base[rear];</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CQueue::QueueDisplay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (front == rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"队空，无元素"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = front % queueSize; i &lt; rear; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index = i;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; queueSize) &#123;</span><br><span class="line">            index = i % queueSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"index: "</span> &lt;&lt; index &lt;&lt; <span class="string">" value: "</span> &lt;&lt; base[index] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; (rear) % queueSize; i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; "index: " &lt;&lt; i &lt;&lt; " value: " &lt;&lt; base[i] &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CQueue cq = CQueue(<span class="number">6</span>);</span><br><span class="line">    cq.EnQueue(<span class="number">1</span>);</span><br><span class="line">    cq.EnQueue(<span class="number">2</span>);</span><br><span class="line">    cq.EnQueue(<span class="number">3</span>);</span><br><span class="line">    cq.EnQueue(<span class="number">4</span>);</span><br><span class="line">    cq.EnQueue(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"入队后："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    cq.QueueDisplay();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"第一个元素出队后："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    cq.DeQueue();</span><br><span class="line">    cq.QueueDisplay();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h4><p>队列的链式存储结构称为<strong>链队列$(Linked\;Queue)$</strong></p>
<p>根据队列先进先出的特性，链队列是仅在表头删除元素和表尾插入元素的单链表。</p>
<p>链队列的类定义和基本操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    Node *front;</span><br><span class="line">    Node *rear;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    LinkQueue();</span><br><span class="line">    ~LinkQueue();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(<span class="keyword">int</span> e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DeQueue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetHead</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetLast</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">QueueDisplay</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LinkQueue::LinkQueue()</span><br><span class="line">&#123;</span><br><span class="line">    front = <span class="keyword">new</span> Node;</span><br><span class="line">    front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    rear = front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LinkQueue::~LinkQueue()</span><br><span class="line">&#123;</span><br><span class="line">    Node *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (front != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = front;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkQueue::EnQueue</span><span class="params">(<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">"进入队列！！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    Node *s = <span class="keyword">new</span> Node;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = rear-&gt;next;</span><br><span class="line">    rear-&gt;next = s;</span><br><span class="line">    rear = s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (front-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        front-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkQueue::DeQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    Node *p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rear == front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"下溢"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p = front-&gt;next;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    front-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rear = front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkQueue::GetHead</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">if</span> (front == rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"下溢"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p = front-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"当前队列为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LinkQueue::GetLast</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">if</span> (front == rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"下溢"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = rear-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LinkQueue::QueueDisplay</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (front == rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"队列为空"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = front-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((p != rear));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LinkQueue lq = LinkQueue();</span><br><span class="line">    lq.EnQueue(<span class="number">1</span>);</span><br><span class="line">    lq.EnQueue(<span class="number">2</span>);</span><br><span class="line">    lq.EnQueue(<span class="number">3</span>);</span><br><span class="line">    lq.EnQueue(<span class="number">4</span>);</span><br><span class="line">    lq.EnQueue(<span class="number">5</span>);</span><br><span class="line">    lq.EnQueue(<span class="number">7</span>);</span><br><span class="line">    lq.EnQueue(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> e = lq.DeQueue();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    e = lq.DeQueue();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    e = lq.GetHead();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    e = lq.GetLast();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    lq.QueueDisplay();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组和广义表"><a href="#数组和广义表" class="headerlink" title="数组和广义表"></a>数组和广义表</h2><p>数组和广义表可以看做是线性表的扩展，即数组和广义表中的数据元素本身也是一种数据结构。数组中每个数据元素具有相同的结构，广义表中的数据元素可以有不同的数据结构。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组$(Array)$是由相同类型的一组数据元素组成的一个有限序列。其数据元素也称为数组元素。数组中的每个元素都有一个序号，称为<strong>下标$(index)$</strong>。可以通过下标访问数据元素。</p>
<p>数组元素受$n(n\ge1)$个线性关系的约束，每个数据元素在$n$<br>个线性关系中的符号$i_1,i_2,\cdots,i_n$成为数据元素的下标，并称该数组为$n$维数组。</p>
<p>当$n=2$是，为二维数组，任何一个数据元素有两个下标，一个为行号，一个为列号。如$a_{ij}$表示第$i$行第$j$列的数据元素</p>
<p>一维数组可以看作是一个线性表，二维数组可以看作数据元素是一维数组的线性表。</p>
<p>数组中的每个数据元素都和一组唯一的下标值对应。因此数组是一种随机存取机构。</p>
<p>数据的抽象数据类型</p>
<ul>
<li><p>数据对象：$j_i=0,\cdots,b_i-1,i=1,2,\cdots,n$</p>
<script type="math/tex; mode=display">D=\{a_{j_1j_2\cdots j_n}|n(n>0),b_i,j_i,a_{j_1j_2\cdots j_n}\in ElemSet\}</script><p>$n$是数据的维数，$b_i$是数据的第$i$维的长度，$j_i$是数组元素第$i$维的下标。</p>
</li>
<li><p>数据关系：$R={R_1,R_2,\cdots,R_n}$</p>
</li>
</ul>
<script type="math/tex; mode=display">R_i=\{<a_{j1\cdots ji \cdots jn},a_{j1\cdots ji+1\cdots jn}>\}
    \\ 0\le j_k\le b_k-1,1\le k\le n\;n\neq i,
    \\ 0\le j_i \le b_i-2,
    - InitArray(\&A,n,bound1,...,boundn)
    \\a_{j1\cdots ji \cdots jn},a_{j1\cdots ji+1\cdots jn}\in D,i=2,\cdots,n</script><ul>
<li>基本操作<ul>
<li>$InitArray(\&amp;A,n,bound1,…,boundn)$<ul>
<li>初始条件：无</li>
<li>操作结果：若维数$n$和各维长度$b_1,…,b_n$合法，则构造相应的数组$A$，并返回$OK$</li>
</ul>
</li>
<li>$DestroyArray(\&amp;A)$<ul>
<li>初始条件：无</li>
<li>操作结果：销毁数组$A$</li>
</ul>
</li>
<li>$GetValue(A,\&amp;e,index1,…,indexn)$<ul>
<li>初始条件：$A$是$n$维数组，$e$为数据元素变量，$index1,\cdots,indexn$是$n$个下标值。</li>
<li>操作结果：若下标$index1,\cdots,indexn$都不超界，则读取与下标对应的数据元素的值，并赋值给$e$</li>
</ul>
</li>
<li>$Assign(\&amp;A,e,index1,…,indexn)$<ul>
<li>初始条件：$A$是$n$维数组，$e$为数据元素变量，$index1,\cdots,indexn$是$n$个下标值。</li>
<li>操作结果：若下标$index1,\cdots,indexn$都不超界，则将$e$赋值给下标对应的数据元素</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="数组的存储结构"><a href="#数组的存储结构" class="headerlink" title="数组的存储结构"></a>数组的存储结构</h4><p>由于计算机内存结构是一维的，因此用一维内存来表示多维数组，必须按某种次序将数据元素排成一个序列，然后将这个序列放在存储空间中。</p>
<p>由于一般不对数组进行插入和删除操作，一般采用顺序存储的方法来表示数组。</p>
<p>用一组连续的存储单元存放数据元素存在一个次序约定的问题，是先存一行数据元素还是先存一列数据元素？</p>
<p>根据<strong>存储方式</strong>的不同，顺序存储方法分为一下两类：</p>
<ul>
<li><p>行优先顺序存储</p>
<p>以行序为主序的存储方式。将数据元素按行排列，第$i+1$个行向量紧接在第$i$个行向量后面。</p>
</li>
<li><p>列优先顺序存储</p>
<p>以列序为主序的存储方式。将数据元素按列排列，第$j+1$个列向量紧接在第$j$个列向量后面。</p>
</li>
</ul>
<p>行优先顺序存储：$\boxed{a<em>{11}|a</em>{12}|\cdots|a<em>{1n}|a</em>{21}|a<em>{22}|\cdots|a</em>{2n}|\cdots|a<em>{m1}|a</em>{m2}|\cdots|a<em>{mn}}$<br>列优先顺序存储：$\boxed{a</em>{11}|a<em>{21}|\cdots|a</em>{m1}|a<em>{12}|a</em>{22}|\cdots|a<em>{m2}|\cdots|a</em>{1n}|a<em>{2n}|\cdots|a</em>{mn}}$</p>
<p>二维数组元素地址，按行优先顺序存储的计算公式</p>
<p>任一数据元素$a<em>{ij}$的存储地址$LOC(a</em>{ij})$应为数组的基地址加上排在$a<em>{ij}$前面的数据元素所占用的单元数，因此$a</em>{ij}$的存储地址计算公式为：</p>
<script type="math/tex; mode=display">LOC(a_{ij})=LOC(a_{l_1l_2})+((i-l_1)*(h_2-l_2+1)+(j-l_2))*c\\=LOC(a_{l_1l_2})+i*(h_2-l_2+1)*c-l_1*(h_2-l_2+1)*c+j*c-l_2*c</script><p>令：$M_1=(h_2-l_2+1)*c,M_2=c,$则有</p>
<script type="math/tex; mode=display">LOC(a_{ij})=v_0+i*M_1+j*M_2</script><p>其中，$v<em>0=LOC(a</em>{l<em>1l_2})+-l_1<em>M_1-l_2</em>M_2,i\in[l_1,h_1],j\in[l_2,h_2],$且$i$和$j$均为整数；$LOC(a_l{ij})$是数据元素$a</em>{ij}$的存储地址，$LOC(a_{l_1l_2})$是二维数组中第一个元素的存储地址，即基地址。</p>
<p>二维数组推广到一般，按照行优先顺序存储，则下标为$i_1,i_2,\cdots,i_n$的存储地址为：</p>
<script type="math/tex; mode=display">LOC(a_{i_1,i_2,\cdots,i_n})
=LOC(a_{l_1,l_2,\cdots,l_n})+(j_1d_2d_3\cdots d_n+j_2d_3\cdots d_n+\cdots+j_{n-1}d_n+j_n)*c\\=V_0+i_1*M_1+i_2*M_2+\cdots+i_n*M_n</script><h4 id="矩阵的压缩存储"><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h4><p>在矩阵中，若非零元素呈现某种规律分布或举证中出现大量零数据元素。为了节省空间，可以对这类矩阵进行压缩。</p>
<p>压缩存储的原则：</p>
<ul>
<li>为多个值相同的非零数据元素分配一个存储空间</li>
<li>不为零数据元素分配存储空间</li>
</ul>
<p>特殊矩阵$(Special\;Matrix)$：值相同的数据元素或者零数据元素在矩阵中的分布有一定的规律。</p>
<p>稀疏矩阵$(Sparse\;Maxtrix)$：矩阵中有许多零数据元素(一般根据稀疏因子的值判定领数据元素是否较多)</p>
<ol>
<li><p>特殊矩阵的压缩存储<br>特殊矩阵是指非零数据元素或零<strong>数据元素的分布</strong>具有一定<strong>规律</strong>的矩阵。</p>
<p>常见的特殊矩阵有:对称矩阵、对角矩阵等，它们都是方阵，行数和列数相同。</p>
<ol>
<li><p>对称对称的压缩<br>在一个$n$阶方阵$A$中，若数据元素满足下述性质:</p>
<script type="math/tex; mode=display">a_{ij}=a_{ji}(i\ge1,j\le n)</script><p>则称为$A$为$n$阶对称矩阵。</p>
<p>对称矩阵只需存储矩阵中的上三角$a<em>{ij}(i\le j)$或下三角$a</em>{ij}(i\ge j)$的数据元素。</p>
<p>对称矩阵优先采用行优先顺序存储下三角中的数据元素。</p>
<p>下三角的数据元素可用一个容量是$n<em>(n+1)/2$的一维数组存储。对于下三角中任意数据元素$a<em>{ij}(i\ge j)$,$a</em>{ij}$在一维数组中的下标$k$与$i、j$的关系为：$k=i</em>(i+1)/2+j$。</p>
<script type="math/tex; mode=display">\boxed{a_{00}|a_{10}|a_{11}|a_{20}|a_{21}|a_{22}|\cdots|a_{ij}|\cdots|a_{n-1,0}|a_{n-1,1}|\cdots|a_{n-1,n-1}}</script><p>若采用上述的压缩存储方式，则矩阵中的任一数据元素$a_{ij}$与它在一维数组中的存储位置$k$之间存在如下的对应关系:</p>
<script type="math/tex; mode=display">k=\begin{cases}i(i-1)/2+j-1,\ge j
\\j(j-1)/2+i-1,\lt j\end{cases}</script><p>其中$k=0,1,2，\cdots,((n+1)n/2)-1,<br>\1+2+3+(i-1)=(i-1)i/2,<br>\(i-1)i/2+j=k+1\quad i\ge j\quad and\quad i,j\ge 1$</p>
</li>
<li><p>对角矩阵的压缩存储</p>
<p>对角矩阵：所有的非零数据元素都集中在以主对角线为中心的带状区域中的举证，即除了<strong>主对角线上和主对角线相邻两侧</strong>的若干条对角线上的数据之外，其余所有数据元素均为零数据元素。</p>
</li>
</ol>
</li>
<li><p>稀疏矩阵的压缩存储</p>
<p><strong>稀疏矩阵$(Sparse\;Matrix)$</strong>:矩阵$A$中有$s$个非零数据元素，若$s$远远小于矩阵数据元素的总数即$(s\ll m*n)$。</p>
<p>稀疏因子：假设$m\ast n$阶矩阵中有$s$个非零元素，令$t=s/(m\ast n)$，称$t$为稀疏因子。</p>
<p>通常认为$s\ll0.05$时，称为稀疏矩阵。</p>
<p>存储方法：</p>
<pre><code>-  三元组顺序表
-  十字链表表示法(需要了解，笔记没有写)
</code></pre><ol>
<li><p>稀疏矩阵的三元组顺序表</p>
<ul>
<li>不存储零数据元素，只存储稀疏矩阵的非零数据元素。</li>
<li>除了存储非零数据的元素的数据值，还需要同时存储它所在的行和列的位置$(i,j)$。</li>
<li>一个三元组$(i,j,a_{ij})$唯一确定了矩阵$A$的一个非零数据元素。</li>
<li>若把稀疏矩阵的三元组线性表按顺序存储结构存储，则称为<strong>稀疏矩阵的三元组顺序表</strong></li>
</ul>
</li>
<li><p>稀疏矩阵的类定义和基本操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Triple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    ElemType e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SMatrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> mu; <span class="comment">//行数</span></span><br><span class="line">    <span class="keyword">int</span> nu; <span class="comment">//列数</span></span><br><span class="line">    <span class="keyword">int</span> tu; <span class="comment">//非零数据的个数</span></span><br><span class="line">    Triple *data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    SMatrix();</span><br><span class="line">    SMatrix(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, Triple data[]);</span><br><span class="line">    ~SMatrix();</span><br><span class="line">    <span class="function">SMatrix <span class="title">MCreate</span><span class="params">(<span class="keyword">int</span> d[][<span class="number">3</span>], <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MDisplay</span><span class="params">(SMatrix a)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MatrixTrans_1</span><span class="params">(SMatrix A, SMatrix &amp;B)</span></span>; <span class="comment">//矩阵转置算法1</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MatrixTrans</span><span class="params">(SMatrix A, SMatrix &amp;B)</span></span>;   <span class="comment">//快速转置算法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SMatrix::SMatrix()</span><br><span class="line">&#123;</span><br><span class="line">    mu = <span class="number">0</span>;</span><br><span class="line">    nu = <span class="number">0</span>;</span><br><span class="line">    tu = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; tu; p++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[p].i = <span class="number">0</span>;</span><br><span class="line">        data[p].j = <span class="number">0</span>;</span><br><span class="line">        data[p].e = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SMatrix::SMatrix(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, Triple data[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;mu = m;</span><br><span class="line">    <span class="keyword">this</span>-&gt;nu = n;</span><br><span class="line">    <span class="keyword">this</span>-&gt;tu = k;</span><br><span class="line">    <span class="keyword">this</span>-&gt;data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">SMatrix <span class="title">SMatrix::MCreate</span><span class="params">(<span class="keyword">int</span> d[][<span class="number">3</span>], <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SMatrix M = &#123;m, n, k, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (k != <span class="number">0</span>)</span><br><span class="line">        M.data = <span class="keyword">new</span> Triple[k];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        M.data[i].i = d[i][<span class="number">0</span>];</span><br><span class="line">        M.data[i].j = d[i][<span class="number">1</span>];</span><br><span class="line">        M.data[i].e = d[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> M;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//矩阵遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SMatrix::MDisplay</span><span class="params">(SMatrix a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Triple p;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, c = <span class="number">0</span>;</span><br><span class="line">    p = a.data[k];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; a.mu; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; a.nu; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (k &lt; a.tu &amp;&amp; p.i == i &amp;&amp; p.j == j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; p.e;</span><br><span class="line">                k++;</span><br><span class="line">                <span class="keyword">if</span> (k &lt; a.tu)</span><br><span class="line">                    p = a.data[k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基于三元组顺序表的转置算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SMatrix::MatrixTrans_1</span><span class="params">(SMatrix A, SMatrix &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B.mu = A.nu;</span><br><span class="line">    B.nu = A.tu;</span><br><span class="line">    B.tu = A.tu;</span><br><span class="line">    <span class="keyword">int</span> q, p;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="keyword">if</span> (B.tu)</span><br><span class="line">    &#123;</span><br><span class="line">        q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (col = <span class="number">1</span>; col &lt; A.nu; col++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt;= A.tu - <span class="number">1</span>; p++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (A.data[p].j == col)</span><br><span class="line">                &#123;</span><br><span class="line">                    B.data[q].i = A.data[p].j;</span><br><span class="line">                    B.data[q].j = A.data[p].i;</span><br><span class="line">                    B.data[q].e = A.data[p].e;</span><br><span class="line">                    q++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速转置算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SMatrix::MatrixTrans</span><span class="params">(SMatrix A, SMatrix &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> col, k, p, q;</span><br><span class="line">    <span class="keyword">int</span> *num, *cpot;</span><br><span class="line">    num = <span class="keyword">new</span> <span class="keyword">int</span>[B.nu];</span><br><span class="line">    cpot = <span class="keyword">new</span> <span class="keyword">int</span>[B.nu];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (B.tu)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (col = <span class="number">0</span>; col &lt; A.tu; col++)</span><br><span class="line">        &#123;</span><br><span class="line">            num[col] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; A.tu; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            num[A.data[k].j]++;</span><br><span class="line">        &#125;</span><br><span class="line">        cpot[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (col = <span class="number">1</span>; col &lt;= A.nu; col++)</span><br><span class="line">        &#123;</span><br><span class="line">            cpot[col] = cpot[col - <span class="number">1</span>] + num[col - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (p = <span class="number">0</span>; p &lt; A.tu; p++)</span><br><span class="line">        &#123;</span><br><span class="line">            col = A.data[p].j;</span><br><span class="line">            q = cpot[col];</span><br><span class="line">            B.data[q].i = A.data[p].j;</span><br><span class="line">            B.data[q].j = A.data[p].i;</span><br><span class="line">            B.data[q].e = A.data[p].e;</span><br><span class="line">            cpot[col]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>矩阵的运算一般有<strong>矩阵转置、矩阵相加、矩阵相减、矩阵相乘</strong>等。</p>
<ul>
<li><p>矩阵转置</p>
<p>$def：$一个$m\ast n$的矩阵$A$，它的转置矩阵$B$是一个$n\ast m$的矩阵，且<br>$a[i][j]==b[j][i],1\le i\le m,1\le j\le m$，即$A$的行是$B$的列，$A$的列是$B$的行。</p>
<ol>
<li><p>基于三元组顺序表的转置算法</p>
<ul>
<li><p>基本思想：对矩阵$A$的三元组从头到尾多次扫描</p>
<ol>
<li>第一次扫描时，将$A$中列号为1的三元组行列交换并赋值到矩阵$B$的三元组中；</li>
<li>第二次扫描时，将$A$中列号为2的三元组行列交换并赋值到矩阵$B$的三元组中；</li>
<li>依次类推直到$A$中所有的三元组都赋值到矩阵$B$的三元组中。</li>
</ol>
</li>
<li><p>评价:基于三元组顺序表的矩阵算法更加复杂，虽然节省了存储空间，但可能增大算法的时间复杂度，故基于三元组顺序表的转置算法仅适用<br>$tu \ll m\ast n$情况。</p>
</li>
</ul>
</li>
<li><p>快速转置算法</p>
<ul>
<li><p>快速转置算法的核心思想：对矩阵$A$扫描一次，按矩阵$A$提供的列号一次确定装入矩阵$B$的一个三元组$d$的位置。</p>
<ol>
<li>一遍扫描先确定三元组的位置关系(具体是根据矩阵$A$中非零数据元素的分布确定每列第一个非零数据元素在矩阵$B$中的位置)</li>
<li>二次扫描由位置关系装入三元组。</li>
</ol>
</li>
<li><p>位置关系是快速转置算法的关键<br>为求得矩阵$A$各列第一个非零数据元素的三元组的所在位置，引入两个辅助运算功能的一个数组$num[],cpot[]$</p>
<ul>
<li><p>$num[col]$:存放矩阵$A$中第$col$列的非零数据元素的个数。</p>
</li>
<li><p>$cpot[col]$:存放矩阵$A$中第$col$列第一个非零数据元素的三元组在$B$的位置。</p>
</li>
<li><p>位置计算公式</p>
<script type="math/tex; mode=display">\begin{cases}cpot[1]=1\\
cpot[col]=cpot[col-1]+num[col-1];2\le col\leq n\end{cases}</script></li>
</ul>
</li>
<li><p>步骤：</p>
<ol>
<li>求矩阵$A$中各列非零数据元素的个数$num[]$</li>
<li>求矩阵$A$中各列第一个非零数据元素在转置矩阵$B$中的下标$cpot[col]$</li>
<li>对矩阵$A$进行一次扫描，遇到第$col$列的第一个非零三元组时，按照$cpot[col]$的位置，将其放至矩阵$B$中，当再次遇到第$col$列的非零元三元组时，只需顺序放到第$col$列数据元素的后面。</li>
</ol>
</li>
<li><p>评价：相对于基于三元组顺序表的转置算法，多占用了两个数组的存储空间，同时算法本身比较复杂，但时间复杂度较低，为$O(nu+tu)$。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>矩阵相乘<br>由于两个稀疏矩阵相乘不一定是稀疏矩阵，所以矩阵的乘积采用二维数组表示。设矩阵$A$为$m$行$p$列，矩阵$B$为$p$行$n$列，则计算矩阵乘积$C$($C$为$m$行$n$列)的一般传统方式，依据下述公式计算：</p>
<script type="math/tex; mode=display">C[i][j]=\sum^{p-1}_{k=1}A[i][k]\ast B[k][j]</script><p>一般传统的矩阵相乘的算法代码如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        c[i][j]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;p;k++)</span><br><span class="line">            c[i][j]+=a[i][k]*b[k][j];</span><br></pre></td></tr></table></figure>
<p>算法的时间复杂度为$O(m<em>n</em>p)$</p>
<p>如果采用三元组顺序存储表示，则不能采用上述传统矩阵相乘算法。</p>
<p>思路：先求得各个$c[i][j]$的部分积，最后分别累加，只需对$B$每一行扫描一次。</p>
<p>采用上述思路，需要一些辅助数组：</p>
<ol>
<li>一个累加器$ctemp[]$存储当前行中$c[i][j]$的部分积，待当前行中所有数据元素全部算完后，再将非零数据元素的结果存放到$C.data$中。</li>
<li>为了便于在$B$的三元组表中找到各行的第一个非零数据元素，与快速矩阵转置算法类似，引入$num[row]$和$cpot[row]$两个一维数组。其中$num[row]$指示$row$行的非零元个数，$cpot[row]$指示第$row$行第一个非零数据元素的位置。$cpot[row]$的计算公式如下：</li>
</ol>
<script type="math/tex; mode=display">\begin{cases}cpot[0]]=1\\
            cpot[row]=cpot[row-1]+num[row-1];\end{cases}</script><p>采用三元组顺序表表示的稀疏矩阵的乘法步骤如下：</p>
<ol>
<li>如果矩阵$A$的列数和矩阵$B$的行数不同，则不满足计算条件，算法退出。</li>
<li>如果矩阵$A$的列数与矩阵$B$的行数相同，则申请矩阵$C$的存储空间，令矩阵$C$的行数等于矩阵$A$的行数，矩阵$C$的列数等于矩阵$B$的列数。</li>
<li>如果矩阵$A$或矩阵$B$中的非零数据元素个数为0，则矩阵$C$为全零矩阵，计算结束，算法退出。</li>
<li>如果矩阵$A$和矩阵$B$的非零数据元素个数均不为0，求$B$的$num[row]$和$cpot[row]$。</li>
<li>按矩阵$A$的行号从小到大的顺序，执行一下操作。<ol>
<li>对每行非零数据元素执行一下操作：<ul>
<li>累加器$ctemp[nu]$清零；</li>
<li>数据元素$a[i][k]$与$b[k][j]$相乘，累加到$ctemp[j]$中。</li>
</ul>
</li>
<li>如果$ctemp[j]$非零，则得到一个$c[i][j]$即在$C$中新添加一个三元组，$C$的非零数据元素个数增1。</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="广义表"><a href="#广义表" class="headerlink" title="广义表"></a>广义表</h3><p><strong>广义表</strong>$(Generalized\;Lists)$是$n(n\ge 0)$个数据元素的有限序列，一般记作:</p>
<script type="math/tex; mode=display">LS=(a_1,a_2,\cdots,a_n)</script><p>其中,$LS$是广义表的名称，$a_i(i\le i\le n)$是$LS$的直接数据元素，也称成员，它可以是单个数据元素，也可以是一个广义表，它们分别称为$LS$的单数据元素(原子)或子表。</p>
<p>当广义表$LS$非空时：</p>
<ul>
<li>表头$(Head)$：第一个数据元素</li>
<li>表尾$(Tail)$：除去表头后其余数据元素组成的广义表</li>
<li>长度：直接数据元素的个数</li>
<li>深度：括号中最大嵌套层数</li>
</ul>
<p>广义表$()$和广义表$(())$是不同的，前者为空表，长度为0，后者长度为1。</p>
<p>广义表的性质：</p>
<ul>
<li>广义线性：不考虑其数据元素的内部结构，则它是一个线性表，它的直接数据元素之间是线性关系</li>
<li>数据元素复合性：数据元素分为单数据元素和子表，数据类型不统一。</li>
<li>数据元素递归性：广义表是递归的。即广义表可以是自身的子表。</li>
<li>数据元素共享性：广义表以及广义表的数据元素可以被其他广义表共享。</li>
</ul>
<p>广义表的抽象数据类型：</p>
<ul>
<li>数据对象：$D={e_i|i=1,2,\cdots,n;n\ge 0;e_i\in AtomSet\;or\;e_i\in GList}$$AtomSet$为某个数据对象</li>
<li>数据关系：$R={<e_{i-1},e_i>|e_{i-1},e_i\in D,2\le i\le n}$</li>
<li>基本操作：<ul>
<li>$InitGList(\&amp;L)$</li>
<li>$CreateGList(\&amp;L,S)$</li>
<li>$CopyGList(\&amp;T,L)$</li>
<li>$GListLength(L)$</li>
<li>$GListDepth(L)$</li>
<li>$GListEmpty(L)$</li>
<li>$GetHead(L)$</li>
<li>$GetTail(L)$</li>
<li>$InsertFirst_GL(\&amp;L,e)$</li>
<li>$DeleteFirst_GL(\&amp;L,e)$</li>
<li>$Traverse_GL(L,visit())$</li>
</ul>
</li>
</ul>
<h4 id="广义表的存储结构"><a href="#广义表的存储结构" class="headerlink" title="广义表的存储结构"></a>广义表的存储结构</h4><p>由于数据元素<strong>类型的不统一</strong>，难以采用顺序存储结构，而采用链式存储结构存储广义表。</p>
<p>若广义表不空，则可分解为<strong>表头和表尾</strong>；反之，一对确定的表头和表尾可唯一确定一个广义表。</p>
<p>根据上述性质可采用<strong>头尾表示法</strong>$(Head\;Tail\;Express)$来存储广义表。</p>
<p>广义表的数据元素可以是单数据元素也可以是广义表，相应的在头尾表示法中链表的结点结构也有两种：</p>
<ul>
<li>表结点，用于存储广义表</li>
<li>数据元素结点，用于存储但数据元素</li>
</ul>
<p>为了区别这两类结点，在结点设置一个标识域，标志为1，则为表结点；标志为0，则该结点为数据元素结点。</p>
<script type="math/tex; mode=display">\boxed{tag=1|hp|tp}\quad\quad\boxed{tag=0|data}</script><ul>
<li>tag:区分表结点和数据元素结点的标志</li>
<li>hp:指向表头结点的指针</li>
<li>tp:指向表尾结点的指针</li>
<li>data:存储数据元素自身的信息</li>
</ul>
<p><code>LS=((),(a),(a,(b,c,d)))</code>的头尾链表存储结构。(自己完成)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> tag;</span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">atom</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        GLNode *hp, *tp;</span><br><span class="line">    &#125; ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    GLNode *ls; <span class="comment">//指向表头的指针</span></span><br><span class="line">    <span class="keyword">char</span> result[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">int</span> count;                      <span class="comment">//计数</span></span><br><span class="line">    <span class="function">GLNode *<span class="title">CreateGList</span><span class="params">(<span class="built_in">string</span> st)</span></span>; <span class="comment">//由广义表的书面格式s创建广义表</span></span><br><span class="line">    <span class="function">GLNode *<span class="title">CopyGList</span><span class="params">(GLNode *ts, GLNode *ls)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(GLNode *ls)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(GLNode *ls)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    GList();</span><br><span class="line">    GList(<span class="built_in">string</span> s);</span><br><span class="line">    ~GList();</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DepthGList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GListCopy</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Server</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="built_in">string</span> &amp;hstr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GListDisplay</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">GList::GList()</span><br><span class="line">&#123;</span><br><span class="line">    ls = <span class="literal">NULL</span>;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GList::~GList()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] ls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树和二叉树-重点"><a href="#树和二叉树-重点" class="headerlink" title="树和二叉树(重点)"></a>树和二叉树(重点)</h2><p>树是一种非线性结构。树是一种<strong>层次结构</strong>。</p>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树$(Tree)$:是$n(n\ge0)$个结点的有限集。</p>
<p>树的递归定义如下：</p>
<p>当$n=0$时，$T$称为空树；当$n&gt;0$时，$T$是非空树。在一棵非空树中：</p>
<ol>
<li><p>有且仅有一个特定的结点，它只有后继结点，没有前驱结点，这个结点称为根$(Root)$</p>
</li>
<li><p>当$n\gt1$时，除了根以外的其余结点分为$m(m\gt0)$个互不相交的有限集合$T_1,T_2，\cdots,T_m$其中每一个集合本身又是一棵树，并且称为根的<strong>子树</strong>$(SubTree)$。T的定义记作：</p>
<script type="math/tex; mode=display">T=\begin{cases}\varPhi,n=0\\
\{root,T_1,T_2,\cdots,T_m\},n\gt0\end{cases}</script><p>其中，$root$表示$T$的根，$T_1,T_2,\cdots,T_m$表示$T$的$m$棵子树。</p>
</li>
</ol>
<blockquote>
<p>树中结点数目 = 每种结点的度 * 每种结点个数 + 1 </p>
</blockquote>
<h4 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h4><ul>
<li>结点$(Node)$:树中的每个元素对应一个结点</li>
<li>结点的度$(Degree)$:是结点所拥有的子树的个数</li>
<li>树的度$(Degree)$:树中所有结点的度的最大值</li>
<li>叶子结点$(Deaf)$:即度为0的结点，又称为终端结点，叶子结点简称叶子</li>
<li>分支结点$(Branch)$:即度不为0的结点，又称非终端结点，分支结点简称为分支</li>
<li>孩子结点$(Child)$:若结点$X$有子树，则子树的根结点即为结点$X$的孩子结点，孩子结点简称孩子</li>
<li>双亲结点$(Parent)$:若结点$X$有孩子，则$X$即为孩子的双亲结点，双亲结点简称双亲</li>
<li>兄弟结点$(Sibling)$:同一双亲的孩子结点间互称为兄弟结点，兄弟结点简称兄弟</li>
<li>堂兄弟结点$(Cousin)$:结点在树中的层次相同，但双亲不同的结点称为堂兄弟结点，堂兄弟结点简称堂兄弟</li>
<li>结点的层次:根结点的层次为1，根结点的孩子的层次为2，根结点的孩子的孩子的层次为3.依次类推</li>
<li>祖先结点$(Ancestor)$:从根结点到结点$X$所经过分支上的所有结点，都称为$X$的祖先结点，祖先结点简称为祖先</li>
<li>子孙结点$(Descendant)$:结点$X$的孩子，以及这些孩子的孩子都是$X$的子孙结点，子孙结点简称子孙</li>
<li>树的深度$(Depth)$:树中距离根最远的结点所处的层次即为树的深度。空树的深度为0，有一个根结点的树的深度为1.</li>
<li>树的高度$(Height)$:叶子结点的高度为1，非叶子结点的高度等于它的孩子结点的高度的最大值加1,这样定义树的高度等于根结点的高度。高度的深度的计算的方向不同，但数值相等</li>
<li>路径$(Path)$:从树的双亲结点移动到其孩子结点和其他子孙结点所经过的路线；路径上经过的边的个数成为路径长度。</li>
<li>有序树$(Ordered\;Tree)$:树中个结点的各棵子树从左到右都是有次序的树</li>
<li>无序树$(Unordered\;Tree)$:树中各个结点的各棵子树不存在确定的次序关系</li>
<li>森林$(Forest)$:$m(m\ge0)$棵互不相交的树的集合称之为森林</li>
</ul>
<h4 id="树的性质和存储"><a href="#树的性质和存储" class="headerlink" title="树的性质和存储"></a>树的性质和存储</h4><ol>
<li><p>树的性质</p>
<ul>
<li>树中的结点个数等于树中所有结点的度数之和再加1<br>假设树中的结点个数为</li>
<li>度为$m$的树中第$i$层上至多有$m^{i-1}$个结点$(i\ge1)$</li>
</ul>
</li>
<li><p>树的存储结构</p>
<ol>
<li><p>树的顺序存储结构</p>
<p>双亲表示法：$(Parent\;Express)$，一维数组来存储树的每个结点的信息，数组中的一个数据元素表示树中的一个结点，数据元素为结构体类型，其中包括结点本身的信息以及其双亲结点在数组中的位置信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize = <span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> parent</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PNode</span> <span class="title">Tree</span>[<span class="title">MaxSize</span>];</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>树的链式存储结构</p>
<ul>
<li><p>孩子表示法</p>
<ul>
<li>多重链表表示法：每个结点包括一个信息域和多个指针域，每个指针域指向该结点的一个孩子。<ul>
<li>每个结点的指针域的个数等于树的度数</li>
<li>每个结点的指针域的个数等于该结点的度数</li>
</ul>
</li>
<li>孩子链表示法：存储单元的主体是一个与结点个数大小一样的一维数组，数组的每个元素由两个域组成，一个域用来存放结点的自身信息，另一个域用来存放指针，该指针指向由该结点孩子组成的单链表的表头。</li>
</ul>
</li>
<li><p>双亲孩子表示法：将双亲表示法和孩子表示法相结合的存储方法。将各结点的孩子组成单链表，同时用一维数组顺序存储树的各结点，一维数组中的数组元素除了本身的信息和该结点的孩子结点链表的头指针之外，还有一个域指向双亲结点。</p>
</li>
<li><p>孩子兄弟表示法：又称二叉链表表示法或二叉树表示法。以二叉链表作为树的存储结构，链表中结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点，分别命名为$firstchild$和$nextsibling$域。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    TNode *firstchild,*nextsibling;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>树的遍历<br>遍历：$(Traverse)$是树的基本操作。</p>
<p>树的遍历：指从根结点出发，按照某种次序访问树中所有结点，使得每个结点被访问一次且仅被访问一次。</p>
<ul>
<li>先根遍历(先序遍历)</li>
<li>后根遍历(后序遍历)</li>
<li>层次遍历(一层一层的访问)</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="森林"><a href="#森林" class="headerlink" title="森林"></a>森林</h4><ol>
<li>森林的存储结构<ol>
<li>森林的顺序存储结构</li>
<li>森林的链式存储结构<ul>
<li>双亲孩子表示法</li>
<li>孩子兄弟表示法</li>
</ul>
</li>
</ol>
</li>
<li>森林的遍历<ul>
<li>先序遍历森林<br>若森林非空<ol>
<li>访问森林第一棵树的根节点</li>
<li>先序遍历第一棵树中根结点的子树森林</li>
<li>先序遍历除去第一棵树之后剩余的树构成的森林</li>
</ol>
</li>
<li>中序遍历森林<br>若森林非空<ol>
<li>中序遍历第一个棵树的根结点和子树森林</li>
<li>访问第一个棵树的根结点</li>
<li>中序遍历除去第一棵树之后剩余的树构成的森林</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="二叉树-重点"><a href="#二叉树-重点" class="headerlink" title="二叉树(重点)"></a>二叉树(重点)</h4><ol>
<li><p>定义</p>
<p>二叉树：$(Binary\;Tree)$:一种树形结构，每个结点至多有两棵子树，分别称为左子树和右子树。</p>
<p>二叉树的递归定义如下：</p>
<script type="math/tex; mode=display">T=\begin{cases}\phi,n=0\\\{root,T_L,T_r\},n\gt0\end{cases}</script></li>
<li><p>性质</p>
<ul>
<li>在二叉树的第$i(i\ge1)$层上至多有$2^{i-1}$个结点。</li>
<li>深度为$k(k\ge1)$的二叉树至多有$2^{k}-1$个结点</li>
<li>对任何一棵非空二叉树，如果其叶子结点数为$n_0$,度为2的结点数为$n_2$则$n_0=n_2+1$.<ul>
<li>满二叉树：$(Full\;Binary\;Tree)<br>$深度为$k$且有$2^{k}-1$个结点的二叉树。除最底层结点度为0，其余都为2。</li>
<li>完全二叉树：$(Complete\;Binary\;Tree)$<br>如果一棵深度为$k$且具有$n$个结点的二叉树，它的每一个结点都与深度为$k$的满二叉树中顺序编号为$1\sim n$的结点一一对应。</li>
</ul>
</li>
<li>具有$n(n\gt0)$个结点的完全二叉树的深度为$\left\lfloor log_2n\right\rfloor+1$</li>
<li>如果将一棵$n$个结点的完全二叉树按照自顶向下，同一层自左向右的顺序连续给结点编号$1,2,3,\cdots,n$。<br>按照此结点编号将树中各结点顺序地存放于一个一维数组，并简称编号为$i$的结点为结点$1\le i\le n)$<ol>
<li>若$i=1$，则结点$i$为根，无双亲结点；若$i\gt1$,则结点的双亲结点为结点$\left\lfloor\frac{i}{2}\right\rfloor$</li>
<li>若$2i\le n$，则结点$i$的左孩子为结点$2i$，否则$i$无左孩子</li>
<li>若$2i+1\le n$，则结点$i$的右孩子为结点$2i+1$，否则结点$i$无右孩子</li>
</ol>
</li>
</ul>
</li>
<li><p>二叉树的存储结构</p>
<ul>
<li><p>二叉树的顺序存储结构</p>
<ol>
<li>完全二叉树的顺序存储表示</li>
<li>一般二叉树的顺序表示：对不存在的结点仍然编号。</li>
</ol>
</li>
<li><p>二叉树的链式存储结构</p>
<p>顺序存储方式用于完全二叉树的存储非常有效，但用于一般二叉树，存储空间浪费。</p>
<p>根据二叉树的定义，每个结点可以有两个分支：<br>二叉树的结点至少三个域，分别存放数据信息$data$、左孩子结点指针$lchild$和右孩子结点指针$rchild$，这种结构称为二叉链表$(Binary)\;Linked\;List$。<br>为了便于查找，可以增加一个指向双亲结点的指针域。这样的结构称为三叉链表$(Trifurcate\;Linked\;List)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    BiTNode *lchild, *rchild;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    BiTNode *bt;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">RCreate</span><span class="params">(BiTNode *p, <span class="keyword">int</span> k, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">PreTraverse</span><span class="params">(BiTNode *p)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InTraverse</span><span class="params">(BiTNode *p)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">PostTraverse</span><span class="params">(BiTNode *p)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    BinaryTree();</span><br><span class="line">    ~BinaryTree();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(<span class="keyword">int</span> <span class="built_in">end</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">BiTNode *<span class="title">GetRoot</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BiTreeDisplay</span><span class="params">(BiTNode *bt, <span class="keyword">int</span> level = <span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BinaryTree::BinaryTree()</span><br><span class="line">&#123;</span><br><span class="line">    bt = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BinaryTree::~BinaryTree()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] bt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>平衡二叉树：每个结点的左右子树的高度之差的绝对值不超过1.</p>
</blockquote>
</li>
<li><p>二叉树的遍历</p>
<ol>
<li><p>二叉树遍历的概念</p>
<ul>
<li>先序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层次遍历</li>
</ul>
</li>
<li><p>二叉树遍历的递归算法和非递归算法</p>
<ol>
<li><p>递归算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinaryTree::PreTraverse</span><span class="params">(BiTNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        PreTraverse(p-&gt;lchild);</span><br><span class="line">        PreTraverse(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinaryTree::InTraverse</span><span class="params">(BiTNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InTraverse(p-&gt;lchild);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        InTraverse(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinaryTree::PostTraverse</span><span class="params">(BiTNode *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PostTraverse(p-&gt;lchild);</span><br><span class="line">        PostTraverse(p-&gt;rchild);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>非递归算法</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryTree::PreOrderTraverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"先序非递归遍历二叉树："</span>;</span><br><span class="line">    BiTNode *p = bt;</span><br><span class="line">    <span class="function">SqStack <span class="title">s</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (p || !s.StackEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            s.Push(p-&gt;data);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            s.Pop();</span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>二叉树遍历的应用</p>
<ul>
<li>利用后序递归遍历计算结点个数</li>
<li>利用后序递归遍历计算树的高度</li>
<li>利用后序递归遍历销毁二叉树</li>
<li>利用先序递归遍历复制二叉树</li>
<li>利用先序递归遍历判断两棵二叉树是否相等</li>
<li>利用先序递归遍历构造二叉树</li>
<li>利用先序遍历输出显示二叉树</li>
</ul>
</li>
</ol>
</li>
<li><p>线索二叉树</p>
<p>一个具有$n$个结点的二叉树若采用二叉链表存储结构，在$2n$个指针域中只有$n-1$个指针域用来存储孩子结点的地址，另外的$n+1$个指针域为空，利用这些空指针域存放指向该结点的某种遍历序列中的前驱和后继结点的位置信息。</p>
<p>其中：</p>
<script type="math/tex; mode=display">ltag=\begin{cases}0,*lchild\;is\;lchild\\
1,*lchild\;is\;preNode\end{cases}</script><script type="math/tex; mode=display">rtag=\begin{cases}0,*rchild\;is\;rchild\\
1,*rchild\;is\;postNode\end{cases}</script><p>线索$(Thread)$：指向结点前驱和后继的指针<br>线索二叉树$(Thread\;Binary\;Tree)$：加上线索的二叉树<br>线索链表$(Thread\;Linked\;List)$：加上线索的二叉链表<br>线索化：对二叉树以某种次序进行遍历使其成为线索二叉树的过程</p>
<p>结点结构示意图：</p>
<script type="math/tex; mode=display">\boxed{lchild|ltag|data|rtag|rchild}</script><p>线索二叉树的定义和基本操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    BiThrNode *lchild, *rchild;</span><br><span class="line">    <span class="keyword">int</span> LTag, RTag;</span><br><span class="line">&#125; BiThrNode, *BiThrTree;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadBiTree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    BiThrNode *bt;</span><br><span class="line">    BiThrNode *pre;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RCreate</span><span class="params">(BiThrNode *p, <span class="keyword">int</span> flag, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    BiThrNode *Thrt;</span><br><span class="line">    ThreadBiTree();</span><br><span class="line">    ~ThreadBiTree();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(<span class="keyword">int</span> <span class="built_in">end</span>)</span></span>;</span><br><span class="line">    <span class="function">BiThrNode *<span class="title">GetRoot</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InOrderThreading</span><span class="params">(BiThrTree &amp;Thrt, BiThrTree T)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InOrderTraverse_Thr</span><span class="params">(BiThrTree T)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BiTreeDisplay</span><span class="params">(BiThrNode *bt, <span class="keyword">int</span> level = <span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">ThreadBiTree::ThreadBiTree()</span><br><span class="line">&#123;</span><br><span class="line">    bt = <span class="literal">NULL</span>;</span><br><span class="line">    Thrt = <span class="keyword">new</span> BiThrNode();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadBiTree::~ThreadBiTree()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadBiTree::InThreading</span><span class="params">(BiThrTree p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        InThreading(p-&gt;lchild);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;lchild)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;LTag = <span class="number">1</span>;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pre-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;RTag = <span class="number">1</span>;</span><br><span class="line">            pre-&gt;rchild = p;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        InThreading(p-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="树，森林与二叉树的转换"><a href="#树，森林与二叉树的转换" class="headerlink" title="树，森林与二叉树的转换"></a>树，森林与二叉树的转换</h3><ol>
<li><p>树与二叉树的转换</p>
<p>由于树和二叉树都可以采用二叉链表作为存储结构，则以二叉链表作为中间形态导出树和二叉树之间的对应关系。</p>
<p>将一棵树转换成二叉树的方法如下：</p>
<ol>
<li>加线：在树中所有相邻兄弟之间加一条连线</li>
<li>抹线：对树中的每个结点，只保留它与第一个孩子结点之间的连线，删除它与其他孩子结点之间的连线</li>
<li>旋转：以树的根结点为轴心，将整棵树顺时针旋转45°，使之成为一棵层次分明的二叉树</li>
</ol>
</li>
<li><p>森林与二叉树的转换</p>
<ol>
<li>将森林中的每棵树转换成对应的二叉树</li>
<li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树根结点的右孩子。</li>
</ol>
</li>
</ol>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆：设有$n$个元素的序列${k_1,k_2,\cdots,k_n}$,当且仅当满足下述关系之一时：</p>
<script type="math/tex; mode=display">\begin{cases}k_i\le k_{2i}\\
k_i\le k_{2i+1}\end{cases}
\;or\;
\begin{cases}k_i\ge k_{2i}\\
k_i\ge k_{2i+1}\end{cases}</script><p>若以一维数组存储堆，则堆对应为一棵完全二叉树，且所有非叶子结点的值均不大于或不小于其子女的值，根结点的值是最小或最大的。</p>
<p>堆具有下列其中某一条性质的完全二叉树：</p>
<ol>
<li>每个结点的值都小于或等于其左右孩子结点的值，称为小根堆或小顶堆。</li>
<li>每个结点的值都大于或等于其左右孩子结点的值，称为大根堆或大顶堆。</li>
</ol>
<h3 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h3><ol>
<li><p>概念</p>
<p>哈夫曼树：又称最优二叉树，指带权路径长度最小的二叉树。</p>
<p>涉及的术语：</p>
<ul>
<li>结点的权：对结点赋予的一个有着某种意义的数值</li>
<li>结点的带权路径长度：从树根结点到该结点之间的路径长度与该结点权值的乘积</li>
<li>叶子结点：树中度为0的结点</li>
<li>树的带权路径长度：树中所有叶子结点的带权路径长度之和</li>
</ul>
<p>树的带权路径长度$WPL$可记为：</p>
<script type="math/tex; mode=display">WPL=\sum^n_{k=1}W_k\bullet L_k</script><p>其中$W_k$为第$k$个叶子结点的权值，$L_k$为第$k$个叶子结点的路径长度。</p>
</li>
<li><p>哈夫曼树的构造</p>
<p>哈夫曼树的构造算法如下：</p>
<ol>
<li>根据给定的$n$个权值${w_1,w_2,\cdots,w_n}$构造$n$棵二叉树的集合$F=(T_1,T_2,\cdots,T_n)$，其中每棵二叉树$T_i$中只有一个权值为$W_i$的根结点，其左右子树均为空。</li>
<li>在$F$中选取两个根结点的权值最小的树，分别作为左右子树构造一棵新的二叉树，且将新的二叉树的根结点的权值为置其左右子树上根结点的权值之和。</li>
<li>在$F$中删除作为左右子树的两棵二叉树，同时将新得到的二叉树加入$F$中。</li>
<li>重复2和3，直到$F$只含有一棵树为止，这棵树就是哈夫曼树。</li>
</ol>
</li>
<li><p>哈夫曼编码</p>
<p>在数据通信中，需要将传送的文字转换成由二进制字符0、1组成的字符串也称编码。</p>
<p>每个字符所转换的二进制字符长度相等称为<strong>等长编码</strong>。</p>
<p>如果让出现频率高的字符采用尽可能短的编码，出现频率低的字符采用稍长的编码，构造一种<strong>不等长编码</strong>，则电文的代码总长度会更短。</p>
<p>设计电文总长最短的编码方式：构造以字符使用频率作为权值的哈夫曼树。</p>
<p>具体操作如下：设需要编码的字符集合为${d_1,d_2,\cdots,d_n}$，它们在电文中出现的次数或频率集合为${w_1,w_2,\cdots,w_n}$，以$d_1,d_2,\cdots,d_n$作为叶子结点，$w_1,w_2,\cdots,w_n$作为它们的权值，构造一棵哈夫曼树，规定哈夫曼树的左分支代表0，右分支代表1，则从根结点到每个叶子结点所经过的路径分支组成的0和1的序列便为该结点对应字符的编码，称之为<strong>哈夫曼编码</strong>。</p>
<p><strong>在不等长编码的选择上，必须使任何一个字符的编码都不是其他字符编码的前缀，以保证译码的唯一性。</strong></p>
<p>若采用哈夫曼编码，则能确保译码的唯一性。</p>
<p>哈夫曼编码的算法：</p>
<ol>
<li>构造哈夫曼树。</li>
<li>在哈夫曼树上求叶子结点的编码。</li>
</ol>
</li>
</ol>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h3><ul>
<li>图：是由有穷非空的顶点集合和顶点之间的边的集合组成的，可表示为：</li>
</ul>
<p>  其中，表示图，图中的数组元素通常叫做<strong>顶点</strong>称为顶点的非空有穷集合，是图中顶点之间边的集合。</p>
<ul>
<li><p>无向边：若顶点和间的边没有方向，用表示</p>
</li>
<li><p>无向图：只有无向边的图</p>
</li>
<li><p>有向边(弧)：若顶点和间的边有方向,用表示且称为弧尾或初始点,称为弧头或终端点</p>
</li>
<li><p>有向图：只有有向边的图</p>
</li>
<li><p>自环:顶点有直接与自身相连的边</p>
</li>
<li><p>多重图：任意连个顶点之间有多条边直接相连</p>
</li>
<li><p>完全图：在由个边组成的<strong>无向图</strong>中，若有条边，则称之<strong>无向完全图</strong>。在由个边组成的<strong>有向图</strong>中，若有条边，则称之为<strong>有向完全图</strong></p>
</li>
<li><p>权：在某些图上，边或弧上具有与它相关的数据信息称之为权</p>
</li>
<li><p>网或网络：带权的图</p>
<p>分别称带权的有向图和带权的无向图为<strong>有向网和无向网</strong></p>
</li>
<li><p>邻接顶点：相邻的两个结点互为邻接顶点</p>
</li>
<li><p>子图：设图和，若且，则称图为图的子图。</p>
</li>
<li><p>度：与顶点关联的边的数目，记作。</p>
<ul>
<li>有向图中，顶点的度等于出度加入度</li>
<li>入度：以顶点为弧头的弧的数目，记作</li>
<li>出度：以顶点为弧尾的弧的数目，记作</li>
<li></li>
<li>无论有向图和无向图，若图有n个顶点和e条边，则有：</li>
</ul>
</li>
<li><p>路径：从一个顶点到另一个顶点经过的顶点序列</p>
</li>
<li><p>路径长度：一条路径上经过的边或弧的数目</p>
</li>
<li><p>简单路径和回路：路径上的各顶点补充度称为简单路径，若第一个顶点和最后一项顶点重复，称这样的路径为回路或环。</p>
</li>
<li><p>连通图和连通分量：在无向图中，两顶点之间存在路径，则两顶点是连通的。如果图中任意一对顶点都是连通的，则此图为连通图。非连通图的极大连通子图叫做连通分量</p>
</li>
<li><p>强连通图与强连通分量：在有向图中，若在每一对顶点和之间都存在一条从到的路径，也存在一条从到的路径，则此图叫做强连通图，而非强连通图的极大强连通子图叫做强连通分量。</p>
</li>
<li><p>生成树：具有个顶点的连通图的生成树是包含中全部顶点的一个极小连通子图，在生成树中添加任意一条原图中的边必会产生回路或环，减少一条边则必然会成为非连通图。一棵具有个顶点的生成树有且仅有条边</p>
</li>
<li><p>生成森林：非连通图的每个连通分量都可以得到一棵生成树，这些连通分量的生成树构成了森林，即生成森林</p>
</li>
<li><p>稀疏图和稠密图：边很少的图称为稀疏图，反之称为稠密图。稀疏和稠密是模糊的概念，稀疏图和稠密图常常是相对而言。</p>
<blockquote>
<p>Prim常用求稠密图的最小生成树</p>
</blockquote>
</li>
</ul>
<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><ol>
<li><p>图的顺序存储结构——邻接矩阵</p>
<p>邻接矩阵存储结构是指用两个数组表示图。</p>
<p>一个一维数组存储图中顶点的信息，一个二维数组存储图中顶点之间的关系。</p>
<p>设图包含个顶点，则的邻接矩阵是一个二维数组</p>
<ul>
<li>若是一个无权图，则的邻接矩阵定义为：</li>
</ul>
</li>
</ol>
<ul>
<li>若是一个网，则的邻接矩阵定义为：</li>
</ul>
<p>   图的邻接矩阵存储结构具有的特点：</p>
<ul>
<li>无向图的邻接矩阵是对称的，采用压缩矩阵进行存储。</li>
<li>有向图的邻接矩阵不一定对称，因此采用邻接矩阵存储据具有个顶点的有向图，需要个存储单元。</li>
<li>无向图邻接矩阵的第行(或第列)中非零元素的个数，就是顶点的度。</li>
<li>有向图邻接矩阵的第行中非零元素的个数，就是顶点的出度，第列中非零元素的个数就是顶点的入度。</li>
<li><p>邻接矩阵容易确定图中两顶点的是否有边，但检测边需要很大的时间代价。</p>
<p>邻接矩阵的存储结构的类定义和基本操作：</p>
<p>1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MAX_VERTEX_NUM 20</span><br></pre></td></tr></table></figure>
<p>2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const int infinity &#x3D; INT32_MAX;</span><br></pre></td></tr></table></figure>
<p>3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct ArcCell</span><br></pre></td></tr></table></figure>
<p>4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int adj; &#x2F;&#x2F;对无权图1,0表示是否相邻，对带权图表示权值类型</span><br></pre></td></tr></table></figure>
<p>6</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char *info;</span><br></pre></td></tr></table></figure>
<p>7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<p>9</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct MGraph</span><br></pre></td></tr></table></figure>
<p>10</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>11</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string vexs[MAX_VERTEX_NUM];                  &#x2F;&#x2F;顶点表</span><br></pre></td></tr></table></figure>
<p>12</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArcCell arcs[MAX_VERTEX_NUM][MAX_VERTEX_NUM]; &#x2F;&#x2F;邻接矩阵表，即  边表</span><br></pre></td></tr></table></figure>
<p>13</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int vexnum;                                   &#x2F;&#x2F;顶点数</span><br></pre></td></tr></table></figure>
<p>14</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int arcnum;                                   &#x2F;&#x2F;边数</span><br></pre></td></tr></table></figure>
<p>15</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int kind;                                     &#x2F;&#x2F;邻接矩阵存储的  图的种类</span><br></pre></td></tr></table></figure>
<p>16</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>17</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Graph</span><br></pre></td></tr></table></figure>
<p>18</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>19</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private:</span><br></pre></td></tr></table></figure>
<p>20</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MGraph mgraph;</span><br></pre></td></tr></table></figure>
<p>21</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool visited[MAX_VERTEX_NUM];</span><br></pre></td></tr></table></figure>
<p>22</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<p>23</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public:</span><br></pre></td></tr></table></figure>
<p>24</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Graph(&#x2F;* args *&#x2F;);</span><br></pre></td></tr></table></figure>
<p>25</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~Graph();</span><br></pre></td></tr></table></figure>
<p>26</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CreateGraph();</span><br></pre></td></tr></table></figure>
<p>27</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int LocateVex(string u); &#x2F;&#x2F;返回顶点u在图中的位置</span><br></pre></td></tr></table></figure>
<p>28</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool CreateDG();         &#x2F;&#x2F;构造有向图</span><br></pre></td></tr></table></figure>
<p>29</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool CreateUDG();        &#x2F;&#x2F;构造无向图</span><br></pre></td></tr></table></figure>
<p>30</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool CreateDN();         &#x2F;&#x2F;构造有向网</span><br></pre></td></tr></table></figure>
<p>31</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool CreateUDN();        &#x2F;&#x2F;构造无向网</span><br></pre></td></tr></table></figure>
<p>32</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Display();          &#x2F;&#x2F;输出邻接矩阵</span><br></pre></td></tr></table></figure>
<p>33</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void DFSTraverse(int v); &#x2F;&#x2F;深度优先遍历</span><br></pre></td></tr></table></figure>
<p>34</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void BFDTraverse(int v); &#x2F;&#x2F;广度优先遍历</span><br></pre></td></tr></table></figure>
<p>35</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p>图的链式存储结构</p>
<ol>
<li><p>邻接表是图的一种链式存储结构</p>
<ul>
<li>基本思想： 邻接表只存储有关联的信息，对图中存在的相邻顶点之间边的信息进行存储，而对于不相邻的顶点则不保留信息。设图具有个顶点，则用顶点数组表和边表来表示图</li>
<li>顶点数组表 用于存储顶点的名或其他有关信息，也称为数据域。该数组的大小为图中的顶点个数。顶点数组表中的数据元素也称为表头结点。 每个表头结点由两个域组成：<ul>
<li>：结点的数据域，用来保存结点的数据值</li>
<li>：结点的指针域，也称为链域，指向自该结点出发的第一条边的边结点</li>
</ul>
</li>
<li>边表(弧表) 图中每一个顶点建立一个单链表，第个单链表的结点表示依附于顶点的边。该单链表中的结点称为边结点， 每个边结点由三个域组成：<ul>
<li>:指示该边所指向的顶点在图中的位置，也称为邻接点域</li>
<li>:边结点的指针域，指向下一条边结点</li>
<li>:存储和边相关的信息，如权值</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<pre><code>  1

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;邻接表</span><br><span class="line"></span><br><span class="line">struct ArcNode</span><br></pre></td></tr></table></figure>

  3

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>

  4

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int adjvex;</span><br></pre></td></tr></table></figure>

  5

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArcNode *next;</span><br></pre></td></tr></table></figure>

  6

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

  7

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  8

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct VertexNode</span><br></pre></td></tr></table></figure>

  9

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>

  10

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int vertex;</span><br></pre></td></tr></table></figure>

  11

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArcNode *firstedge;</span><br></pre></td></tr></table></figure>

  12

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

  13

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  14

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MAX_VERTEX_NUM 20</span><br></pre></td></tr></table></figure>

  15

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  16

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct ArcNode</span><br></pre></td></tr></table></figure>

  17

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>

  18

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int adjvex;</span><br></pre></td></tr></table></figure>

  19

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct ArcNode *nextarc;</span><br></pre></td></tr></table></figure>

  20

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *info;</span><br></pre></td></tr></table></figure>

  21

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

  22

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  23

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct VNode</span><br></pre></td></tr></table></figure>

  24

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>

  25

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string data;</span><br></pre></td></tr></table></figure>

  26

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArcNode *firstarc;</span><br></pre></td></tr></table></figure>

  27

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

  28

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  29

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct AdjLGraph</span><br></pre></td></tr></table></figure>

  30

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>

  31

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VNode vertices[MAX_VERTEX_NUM];</span><br></pre></td></tr></table></figure>

  32

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int vexnum;</span><br></pre></td></tr></table></figure>

  33

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int arcnum;</span><br></pre></td></tr></table></figure>

  34

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int kind;</span><br></pre></td></tr></table></figure>

  35

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

  36

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ALGraph</span><br></pre></td></tr></table></figure>

  37

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>

  38

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private:</span><br></pre></td></tr></table></figure>

  39

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AdjLGraph algraph;</span><br></pre></td></tr></table></figure>

  40

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool visited[MAX_VERTEX_NUM];</span><br></pre></td></tr></table></figure>

  41

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  42

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public:</span><br></pre></td></tr></table></figure>

  43

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALGraph(&#x2F;* args *&#x2F;);</span><br></pre></td></tr></table></figure>

  44

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~ALGraph();</span><br></pre></td></tr></table></figure>

  45

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CreateGraph();</span><br></pre></td></tr></table></figure>

  46

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int LocateVex(string u);</span><br></pre></td></tr></table></figure>

  47

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ALGraphDisplay();</span><br></pre></td></tr></table></figure>

  48

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void FindInDegree(int indegree[]);</span><br></pre></td></tr></table></figure>

  49

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool TopologicalSort();</span><br></pre></td></tr></table></figure>

  50

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><ol>
<li>十字链表 十字链表是有向图的一种链式存储方式。 十字链表将邻接表和逆邻接表结合起来得到的</li>
</ol>
<pre><code>  弧结点中共五个域：

  - tailevex：弧尾结点，即弧尾在顶点表的下标
  - headvex：弧头结点，即弧头在顶点表的下标
  - hlink：指向弧头相同的下一条弧
  - tlink：指向弧尾相同的下一条弧
  - info：存储该弧的相关信息

  顶点结点即链表的头结点：

  - data：存储和该顶点相关的信息
  - firstin：指向该顶点的第一个弧结点
  - firstout：指向该顶点为弧尾的第一个弧结点

  1

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;十字链表</span><br></pre></td></tr></table></figure>

  2

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  3

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define MAX_INFO 10</span><br></pre></td></tr></table></figure>

  4

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  5

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct ArcBox</span><br></pre></td></tr></table></figure>

  6

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>

  7

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int tailvex, headvex;</span><br></pre></td></tr></table></figure>

  8

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArcBox *hlink, *tlink;</span><br></pre></td></tr></table></figure>

  9

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char *info;</span><br></pre></td></tr></table></figure>

  10

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

  11

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  12

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct VexNode</span><br></pre></td></tr></table></figure>

  13

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>

  14

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string data;</span><br></pre></td></tr></table></figure>

  15

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArcBox *firstin, *firstout;</span><br></pre></td></tr></table></figure>

  16

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

  17

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  18

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct OLGraph</span><br></pre></td></tr></table></figure>

  19

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>

  20

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VexNode xlist[MAX_VERTEX_NUM];</span><br></pre></td></tr></table></figure>

  21

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int vexnum, arcnum;</span><br></pre></td></tr></table></figure>

  22

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

  23

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  24

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class OrListGraph &#x2F;&#x2F;有向图的十字链表表示</span><br></pre></td></tr></table></figure>

  25

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>

  26

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private:</span><br></pre></td></tr></table></figure>

  27

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OLGraph olgraph;</span><br></pre></td></tr></table></figure>

  28

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool visited[MAX_VERTEX_NUM];</span><br></pre></td></tr></table></figure>

  29

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>

  30

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public:</span><br></pre></td></tr></table></figure>

  31

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OrListGraph(&#x2F;* args *&#x2F;) &#123;&#125;</span><br></pre></td></tr></table></figure>

  32

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~OrListGraph() &#123;&#125;</span><br></pre></td></tr></table></figure>

  33

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void CreateGraph();</span><br></pre></td></tr></table></figure>

  34

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int LocateVex(string u);</span><br></pre></td></tr></table></figure>

  35

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Display();</span><br></pre></td></tr></table></figure>

  36

  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre><ol>
<li>邻接多重表 邻接多重表是无向图的一种链式存储方式。</li>
</ol>
<pre><code>  - mark：标志域，可以标记改边是否被搜索过
  - ivex、jvex：与该边依附的两个顶点在顶点表的下标
  - ilink、jlink：指针域，指向下一条依附于顶点ivex和jvex的边
  - info：存储和边相关的信息
  - data：存储和该点相关的信息
  - firstedge：指示第一条依附于该顶点的边
</code></pre><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><ol>
<li><p>深度优先搜索 类似树的先根遍历。 从图中的某个点v出发，作为当前顶点，访问此顶点，并设置该顶点的访问标志，接着从v的为被访问的邻接点中找出一个作为下一步探查的当前顶点。倘若当前顶点的所有邻接顶点都被访问过，则退回一步，将前一步访问的顶点重新取出，作为当前探查顶点，重复上述过程，直至图中最初指定起点的所有邻接顶点都被访问到。</p>
<p>深度优先搜索的过程中所有访问过的顶点和经过的边，构成一个连通的无环图，也就是深度优先搜索树，简称DFS树</p>
<p>深度优先搜索的递归实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Graph::DFSTraverse(int v)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; mgraph.vertex[v];</span><br><span class="line">    visited[v]&#x3D;1;</span><br><span class="line">    for(j&#x3D;0;j&lt;mgraph.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(mgraph.arcs[v][j]&#x3D;&#x3D;1 &amp;&amp; visited[j]&#x3D;&#x3D;0)</span><br><span class="line">            DFSTraverse(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>广度优先搜索</p>
<p>类似树的层次遍历</p>
<p>无向连通图广度优先搜索的实现</p>
<p>1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Graph::BFSTraverse(int v)</span><br></pre></td></tr></table></figure>
<p>2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">front &#x3D; rear &#x3D; -1;</span><br></pre></td></tr></table></figure>
<p>4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; mgraph.vertex[v];</span><br></pre></td></tr></table></figure>
<p>5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">visited[v]&#x3D;1;</span><br></pre></td></tr></table></figure>
<p>6</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Q[++rear]&#x3D;v;</span><br></pre></td></tr></table></figure>
<p>7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(front!&#x3D;rear)</span><br></pre></td></tr></table></figure>
<p>8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>9</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v&#x3D;Q[++front];</span><br></pre></td></tr></table></figure>
<p>10</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(mgraph.arcs[v][j]&#x3D;&#x3D;1 &amp;&amp; visited[j]&#x3D;&#x3D;0)</span><br></pre></td></tr></table></figure>
<p>11</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DFSTraverse(j);</span><br></pre></td></tr></table></figure>
<p>12</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; mgraph.vertex[j];</span><br></pre></td></tr></table></figure>
<p>13</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">visited[j]&#x3D;1;</span><br></pre></td></tr></table></figure>
<p>14</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Q[++rear]&#x3D;j;</span><br></pre></td></tr></table></figure>
<p>15</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>16</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>连通分量和重连通分量</p>
<ul>
<li>连通分量：当无向图为非连通图时，利用或,无法遍历图中的所有顶点，而只能遍历到该顶点所在的最大连通子图的所有顶点，这些顶点构成一个连通分量。</li>
<li>关节点:在无向连通图中，当且仅当删去一个点及其依附于它的边，图被分为两个连通分量。</li>
<li>重连通图：没有关节点的连通图</li>
</ul>
</li>
</ol>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>设是一个无向连通网</p>
<ul>
<li>代价：的生成树上任一条边的权值称为该边的代价</li>
<li>最小生成树：一棵生成树的代价就是树上各边代价之和，代价最小的生成树就是最小代价生成树，简称最小生成树。</li>
</ul>
<p>根据生成树的定义，若连通带权图由个顶点组成，其生成树必含个顶点，条边，因此构造最小代价生成树的准则有3条：</p>
<ol>
<li>只能使用该网络中的边来构造最小生成树</li>
<li>能且只能使用条边来连接网络中的n个顶点</li>
<li>选用的条边不能产生回路</li>
</ol>
<p>构造最小生成树的方法多数利用了最小生成树的一种性质，简称MST</p>
<ul>
<li>:假设是一个连通网，是顶点集的一个非空子集。若是一条具有最小权值的边，其中，，则必存在一棵包含边的最小生成树。</li>
</ul>
<p>构造最小生成树的典型算法：</p>
<ul>
<li>算法</li>
<li>算法</li>
</ul>
<p>都利用了性质，采用逐步求解的策略，亦称<strong>贪心策略</strong></p>
<ol>
<li><p>算法(适用于稀疏图)</p>
<p>基本思想：设一个有个顶点的连通网络。</p>
<ul>
<li>首先构造一个由个顶点组成，不含任何边的图，其中每个顶点自成一个连通分量</li>
<li>不断从中去除代价最小的一条边（若有多条，任选其一）,若该边的两个顶点来自T的不同的连通分量，则将此边加入到T中，否则舍去此边选择下一条代价最小的边。</li>
<li>依次类推，直到T中所有的顶点在同一个连通分量为止。</li>
</ul>
</li>
</ol>
<ol>
<li><p>算法(适用于稠密图)</p>
<p>基本思想：</p>
<ul>
<li>给定任意带权连通网络是的最小生成树。</li>
<li>算法始终将顶点集合分成没有元素重叠的两部分，，的初始状态为,然后重复执行一下操作：</li>
<li>在所有的边中找出一条代价最小的边并入集合,同时并入，直至为止。</li>
</ul>
</li>
</ol>
<h3 id="有向无环图及其应用"><a href="#有向无环图及其应用" class="headerlink" title="有向无环图及其应用"></a>有向无环图及其应用</h3><ul>
<li><p>有向无环图：一个无环的有向图，简称图</p>
<ul>
<li><p>有向无环图是描述含有公共子式的表达式的有效工具。例如：</p>
</li>
<li><p>有向无环图也是描述一项工程或系统的有效工具</p>
<p>关心的问题：</p>
<ol>
<li>工程是否能够顺利进行</li>
<li>估算整个工程完成所必须的最短时间 对应于有向图，则进行拓扑排序和求关键路径的操作。</li>
</ol>
</li>
</ul>
</li>
<li><p>网与拓扑排序</p>
<ul>
<li>活动：所有工程或某种流程可以分成若干个小的工程或阶段，这些小的工程或阶段就是活动</li>
<li>网：用顶点表示活动，有向边表示活动的优先关系</li>
<li>若顶点到顶点之间存在一条有向路径，则称顶点是顶点的前驱或顶点是顶点的后继</li>
<li>拓扑排序：就是由某个集合的一个偏序得到该集合上的一个全序的操作<ul>
<li>若集合的关系满足自反、反对称和传递性，则称是集合上的偏序</li>
<li>若是集合上的偏序，如果对每个必有或，则称是上的全序关系 对一个有向无环图进行拓扑排序，是将G中所有顶点排成一个线性序列， 使得图中任意一对顶点u和v,若边，则u在线性序列中出现在v之前。 通常，这样的线性序列称为满足拓扑次序的序列，简称拓扑序列。</li>
</ul>
</li>
</ul>
</li>
<li><p>网与关键路径(重点)</p>
<ul>
<li>网：边表示活动的网。网是一个带权的有向无环图。顶点表示事件，弧表示活动，权表示活动持续的时间，网可以用来表示工程的进度计划</li>
<li>在正常情况下(无环)下：网中只有一个入度为0的点,称之为源点；一个出度为0的点，称之为汇点</li>
</ul>
<p>用于工程估算：</p>
<ol>
<li>完成整个工程所需的时间(假设网中无环)？</li>
<li>那些活动是影响工程进度的关键？</li>
</ol>
<ul>
<li>关键路径：完成整个工程所需的时间取决于从源点到汇点的最长路径的长度，即在这条路径上所有活动的持续时间之和，这条最长的路径即关键路径</li>
<li>关键活动：不按时完成就会影响整个工程的活动。关键路径上的活动就是关键活动</li>
</ul>
</li>
</ul>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><ul>
<li><p>最短路径：由于从一个顶点到另一个顶点可能存在多条路径，每条路径上所经过的边数可能不同，即路径长度不同，则称路径长度最短即边数最少的路径为最短路径</p>
</li>
<li><p>带权图路径长度：若图是带权图，则把一个顶点到图中其余任一个顶点的一条路径所经过边上的权值之和定义为带权图路径长度</p>
</li>
<li><p>最短路径问题包括：</p>
<ul>
<li>求图中一个顶点到其余顶点的最短路径</li>
<li>求图中每对顶点之间的最短路径</li>
</ul>
</li>
<li><p>单源最短路径 利用算法解决单源最短路径问题：给定带权有向图和源点,求到中其余个点的最短路径，其时间复杂度为</p>
<p><strong> 搞清执行过程</strong></p>
</li>
<li><p>每对顶点间的最短路径 求各个顶点之间最短路径的算法，其时间复杂度也是：</p>
<p>通过计算图中各个顶点的最短路径时，需要引入两个矩阵，- 矩阵中的元素表示顶点(第个顶点)到顶点(第个顶点)的距离。</p>
<ul>
<li>矩阵中的元素，表示顶点到顶点经过了记录的值所表示的顶点。</li>
</ul>
<p>假设图G中顶点个数为，则需要对矩阵和矩阵进行次更新。初始时，矩阵中顶点的距离为顶点到顶点的权值; 如果和不相邻，则，矩阵的值为顶点的的值。接下来开始，对矩阵进行次更新。 第1次更新时，如果”的距离”“”(表示”与之间经过第1个顶点的距离”)，则更新为””,更新。 同理，第次更新时，如果”的距离”“”，则更新为””,。更新次之后，操作完成！</p>
<p><a href="https://blog.csdn.net/qq_35644234/article/details/60875818" target="_blank" rel="noopener">最短路径问题—-Floyd算法详解</a></p>
</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h3><ul>
<li><p><strong>静态查找表</strong>：仅对查找表进行查找操作，不进行插入和删除操作的查找表</p>
</li>
<li><p><strong>动态查找表</strong>：可以查找表进行查找、插入和删除操作的表。</p>
</li>
<li><p>面向查找操作的数据结构称为<strong>查找结构</strong></p>
<ul>
<li><strong>线性表</strong>：适用于静态查找，主要采用顺序查找技术、折半查找技术</li>
<li><strong>树表</strong>：适用于动态查找，主要采用二叉排序树的查找技术；</li>
<li><strong>散列表</strong>：静态和动态查找均适用，主要采用<strong>散列技术</strong>。</li>
</ul>
<p>以“关键字与给定值的比较次数”作为衡量算法效率的方法，该比较次数的期望值，称为查找成功的<strong>平均查找长度</strong></p>
<p>对于含有n个记录的表，查找成功的平均查找长度为：</p>
</li>
</ul>
<p>  是查找第个记录的概率，且表示找到给定关键字与给定值相等的第个记录，已和给定值进行过比较的关键字个数。</p>
<h3 id="静态查找表"><a href="#静态查找表" class="headerlink" title="静态查找表"></a>静态查找表</h3><ol>
<li><p>顺序查找</p>
<ul>
<li><p>又称线性查找。</p>
</li>
<li><p>基本思想</p>
<p>首先将顺序表中的第一个存储单元(即下标为0的单元)设置为“监视哨”，即把待查值放入该单元，查找时从顺序表的最后一个单元开始，依次向前搜索进行查找</p>
</li>
<li><p>算法分析</p>
<ul>
<li>查找成功的情况下： 若每个记录的查找概率相等，即，则为：</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code> - 查找失败和查找成功的可能性相同，且每个记录的查找概率相等，则 在查找失败的情况下，不管查找的关键字为何值，其比较次数都为。在该条件下的平均查找长度为：
</code></pre><ul>
<li><p>优点：算法简单，对表的结构没有任何要求</p>
</li>
<li><p>缺点：当很大，查找效率很低</p>
</li>
</ul>
<ol>
<li><p>有序表的查找</p>
<ul>
<li><p>当查找表中的数据元素无序，选择顺序查找简单又实用。但但查找表中的数据元素在顺序存储时是有序的情况下，可以采用<strong>折半查找</strong>，又称<strong>二分查找</strong></p>
</li>
<li><p>基本思想</p>
<p>给定有序表ST,在表ST中取位于中间的记录作为比较对象，若中间记录和关键字与给定值相等，则查找成功；若中间记录的关键字大于给定值，则在中间记录的左半区继续查找；若中间记录的关键字小于给定值，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功或所查找的区域无记录即查找失败</p>
</li>
<li><p>折半查找算法的非递归实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int Search_Bin(int key)</span><br><span class="line">&#123;</span><br><span class="line">    int low&#x3D;0;high&#x3D;st.length-1;</span><br><span class="line">    int mid;</span><br><span class="line">    while(low&lt;&#x3D;hight)</span><br><span class="line">    &#123;</span><br><span class="line">        mid &#x3D; (low+high)&#x2F;2;</span><br><span class="line">        if(st.elem[mid]&#x3D;&#x3D;key)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;查找成功，处于第&quot;&lt;&lt;mid+1&lt;&lt;&quot;位置&quot;&lt;&lt;endl;</span><br><span class="line">            return mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(st.elem[mid]&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            high &#x3D; mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(st.elem[mid]&lt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            low &#x3D; mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;未找到！&quot;&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造折半查找判定树</p>
<ol>
<li>确定下标范围：0-10</li>
<li>L[(0+10)/2]=5 —&gt; 根结点为6 左子树的下标为0-4 右子树的下标范围为 6-10</li>
<li>L[(0+4)/2]=2 ,…..</li>
<li>L[(6+10)/2]=8 ,…..</li>
</ol>
</li>
<li><p>算法分析</p>
<p>对于折半查找，查找成功时进行的关键字比较次数至多为。 查找成功的平均查找长度为</p>
</li>
</ul>
</li>
</ol>
<pre><code> 当比较大时， 查找失败时的平均查找长度的量级为：
</code></pre><ol>
<li><p>分块查找</p>
<ul>
<li><p>分块查找又称索引顺序查找</p>
</li>
<li><p>前提：查找表，满足分块有序，分块有序即整个查找表无序，但把查找表看做几个子表时，每个子表的关键字是有序的。</p>
</li>
<li><p>基本思想</p>
<p>在查找时，首先用待查值key在索引表中进行区间查找(即查找key所在的子表，由于索引表按最大关键字项有序，因此可采用折半查找或者顺序查找)，然后在对应的子表进行顺序查找</p>
</li>
<li><p>算法分析</p>
<p>设对索引表查找的平均查找长度为,对待查子表中查找元素的平均查找长度为，则分块查找的平均查找长度可以通过两种算法的平均查找长度之和表示：</p>
</li>
</ul>
</li>
</ol>
<pre><code> 采用分块查找：长度为n的表分为b块，每个块m个记录，则。

 - 采用顺序查找确定块的位置

   块的查找概率为，块中每个记录的查找概率为，该条件下分块查找的平均查找长度为：



   当时，平均查找厂区取最小值为。

 - 采用折半查找确定块
</code></pre><ol>
<li><p>二叉排序树</p>
<ul>
<li><p>二叉排序树又称二叉查找树</p>
</li>
<li><p>性质</p>
<ol>
<li>若左子树不空，则左子树上的所有结点的值均小于根结点的值</li>
<li>若右子树不空，则右子树上的所有结点的值均大于根结点的值</li>
<li>它的左右子树也分别是二叉排序树</li>
</ol>
</li>
<li><p>查找方法</p>
<p>首先将给定值key与根结点的关键字进行比较，若相等，则查找成功；若根结点的关键字大于key，则在根结点的左子树上进行查找，否则在根结点的右子树上进行查找</p>
</li>
<li><p>查找代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Node</span><br><span class="line">&#123;</span><br><span class="line">    int key;</span><br><span class="line">&#125;;</span><br><span class="line">struct BTSNode</span><br><span class="line">&#123;</span><br><span class="line">    Node data;</span><br><span class="line">    BTSNode *lchild,*rchild;</span><br><span class="line">&#125;;</span><br><span class="line">void SearchBST(BTSNode *T,int key)</span><br><span class="line">&#123;</span><br><span class="line">    if((!T)||(key&#x3D;&#x3D;T-&gt;data.key))</span><br><span class="line">    &#123;</span><br><span class="line">        if(!T)</span><br><span class="line">            cout &lt;&lt; &quot;找不到&quot;&lt;&lt;key&lt;&lt;“的结点”&lt;&lt;endl;</span><br><span class="line">        else</span><br><span class="line">            cout &lt;&lt; &quot;找到&quot;&lt;&lt;key&lt;&lt;“的结点”&lt;&lt;endl;</span><br><span class="line">        else if(key&lt;T-&gt;data.key)</span><br><span class="line">            SearchBST(T-&gt;lchild,key);</span><br><span class="line">        else</span><br><span class="line">            SearchBST(T-&gt;rchild,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int SearchBST(BTSNode *T,int key,BTSNode *f,BTSNode* &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    if(!T)&#x2F;&#x2F;查找不成功</span><br><span class="line">    &#123;</span><br><span class="line">        p&#x3D;f;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(key&#x3D;&#x3D;T-&gt;data.key)&#x2F;&#x2F;查找成功</span><br><span class="line">    &#123;</span><br><span class="line">        p&#x3D;T;</span><br><span class="line">        return &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(key&lt;T-&gt;data.key)</span><br><span class="line">        return SearchBST(T-&gt;lchild,key,T,p);</span><br><span class="line">    else</span><br><span class="line">        return SearchBST(T-&gt;rchild,key,T,p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二叉排序树的插入(插入的位置为查找失败的位置)</p>
<ul>
<li><p>插入方法</p>
<p>首先在树中查找是否已有关键字为key的结点，若查找成功，则说明待插入结点已经存在，不能插入重复结点。只有当查找失败，才能在树中插入关键字为key的新节点。</p>
</li>
<li><p>插入代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int InsertBST(int e)</span><br><span class="line">&#123;</span><br><span class="line">    int key &#x3D;e;</span><br><span class="line">    BTSNode *p &#x3D; new BTSNode;</span><br><span class="line">    BTSNode *T &#x3D; BT;</span><br><span class="line">    if(!SearchBST(T,key,NULL,p))</span><br><span class="line">    &#123;</span><br><span class="line">        BTSNode *s &#x3D; new BTSNode;</span><br><span class="line">        s-&gt;data.key &#x3D; e;</span><br><span class="line">        s-&gt;lchild&#x3D;s-&gt;rchild&#x3D;NULL:</span><br><span class="line">        if(!p)</span><br><span class="line">        &#123;</span><br><span class="line">            BT&#x3D;s;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(key&lt;p-&gt;data.key)</span><br><span class="line">            p-&gt;lchild&#x3D;s;</span><br><span class="line">        else</span><br><span class="line">            p-&gt;rchild&#x3D;s;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>二叉排序树的删除</p>
<ul>
<li><p>删除代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int DeleteBST(BSTNode* &amp;T，int key)</span><br><span class="line">&#123;</span><br><span class="line">    if(!T)</span><br><span class="line">        return 0;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if(key&#x3D;&#x3D;T-&gt;data.key)</span><br><span class="line">            return Delete(T);</span><br><span class="line">        else if(key&lt;T-&gt;data.key)</span><br><span class="line">            return DeleteBST(T-&gt;lchild,key);</span><br><span class="line">        else</span><br><span class="line">            return DeleteBST(T-&gt;rchild,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>平衡二叉树的构造（AVL）首先是一个二叉树排序树(重点，补充平衡二叉树的调整)</p>
</li>
</ul>
</li>
<li><p>B_树</p>
<p>上述介绍的查找方法都是适用于内部查找的方法，称为<strong>内部查找法</strong>。适用于数据集不大，可以放入内存中，适用于对较小的文件进行查找，而不适用于对较大的存放在外存储器中文件。</p>
<ul>
<li><p>B_树：特点是插入、删除时易于保持平衡，外部查找效率高，适用于组织磁盘文件的动态索引结构。</p>
<p>B_树是一种平衡的多路查找树，作为索引组织文件，用以提高访问速度。</p>
</li>
<li><p>一棵m阶的B_树，可以为空树，或者是一棵满足下列性质的m叉树：</p>
<ol>
<li>树中的每个结点至多有m棵子树</li>
<li>若根结点不是叶子结点，则至少有两棵子树</li>
<li>除根结点之外所有非叶子结点至少有棵子树</li>
<li>有s个子树的非叶子结点具有s-1个关键字，所有非叶子结点包含下列信息： ，其中为关键字个数，为关键字，为指向子树根结点的指针，且指针所指子树中所有结点的关键字均小于，所指子树中所有结点的关键字均大于 </li>
<li>B_树总是树高平衡的，所有的叶子结点都在同一层，且不包含任何关键字信息。通常叶子结点也被称为失败结点。</li>
</ol>
</li>
<li><p>B树的构造(补充)</p>
</li>
</ul>
</li>
</ol>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>在查找时，如果给定值在表中存在，则需根据并通过对应关系，即可的到在表中的存储位置。因此不需要比较，仅通过的计算，就能获得要查找的记录。称这样的对应关系为<strong>哈希函数</strong>或<strong>散列函数</strong>或<strong>杂凑函数</strong>，根据这个思想建立的表称为<strong>哈希表</strong>或<strong>散列表</strong>或<strong>杂凑表</strong>，根据哈希函数所得到的存储位置称为<strong>哈希地址</strong>或<strong>散列地址</strong>，而这种映像过程被称为<strong>哈希造表</strong>或<strong>散列</strong>。</p>
<p>根据函数的性质可知，对于某个函数，不同的通过获得的可能是相同的。</p>
<ul>
<li><strong>冲突</strong>：不同的关键字有可能的到相同的哈希地址的现象</li>
<li><strong>同义词</strong>：相同函数值的关键字称为函数上的同义词。</li>
</ul>
<p>采用散列技术需要考虑的两个问题：</p>
<ul>
<li>哈希函数的设计</li>
<li>冲突的处理</li>
</ul>
<ol>
<li><p>哈希函数</p>
<p>设计哈希函数应该遵循的原则</p>
<ul>
<li>计算简单，否则会降低查找效率</li>
<li>每个关键字所对应的哈希地址分布均匀。</li>
</ul>
<p>常见的几种哈希函数的构造方法：</p>
<ol>
<li><p>直接定址法</p>
<ul>
<li>定义 直接定义一个线性函数，取关键字对于该函数的函数值作为哈希地址，即：</li>
</ul>
</li>
</ol>
</li>
</ol>
<pre><code>    其中a和b是常数。

  - 特点 这类函数是一一对应函数，因此不会产生冲突，但要求地址集合和关键字集合的大小相同，并且当关键字跨度非常大时并不适用。该方法在实际生活中并不常用
</code></pre><ol>
<li><p>数学分析法</p>
<ul>
<li><p>定义 在关键字集合中，若每个关键字均由位组成，而每位上都有中不同的取值，通过分析中不同符号在每一位上的分布情况，选择其中某几位分布较为均匀的符号组成哈希地址。</p>
</li>
<li><p>Example 例如：一组关键字进行关键字分析</p>
<p>| 第一位 | 第二位 | 第三位 | 第四位 | 第五位 | 第六位 | 第七位 |<br>| ——— | ——— | ——— | ——— | ——— | ——— | ——— |<br>| 6      | 5      | 3      | 7      | 6      | 8      | 5      |<br>| 6      | 5      | 3      | 3      | 2      | 5      | 1      |<br>| 6      | 5      | 3      | 6      | 5      | 4      | 3      |<br>| 6      | 5      | 4      | 2      | 0      | 1      | 9      |<br>| 6      | 5      | 3      | 9      | 8      | 3      | 4      |<br>| 6      | 5      | 4      | 1      | 2      | 3      | 4      |<br>| 6      | 5      | 4      | 5      | 4      | 3      | 7      |</p>
<p>其中所有关键字的第一、二位均为6/5，而第三位也只有3和4，因此 这三位不用作哈希地址，剩余4位的取值分布比较均匀，可以作为哈希地址，因此可选取者四位中任意两位组合成哈希地址，也可以对这四位进行适当的处理来获得哈希地址。</p>
</li>
</ul>
</li>
<li><p>平方取中法</p>
<ul>
<li><p>定义 取关键字平方后的中间几位作为哈希地址。</p>
</li>
<li><p>Example 例如：关键字集合</p>
<p>| 关键字 | 关键字平方 | 所选取哈希地址 |<br>| ——— | ————— | ——————— |<br>| 3456   | 11943936   | 43             |<br>| 2564   | 6574096    | 40             |<br>| 3466   | 12013156   | 13             |<br>| 3454   | 11930116   | 30             |</p>
<p>平方后可取地中第4、5位作为哈希地址</p>
</li>
</ul>
</li>
<li><p>折叠法</p>
<ul>
<li><p>定义 将关键字按位数分割成几部分(其中最后一部分的长度会较小)，然后将这些部分按一定的方式进行求和，按哈希表表长取后几位作为哈希地址</p>
</li>
<li><p>形式</p>
<ul>
<li>位移法：将各部分按最后一维对齐相加</li>
<li>间接折叠法：从一端向另一端沿分割界来回折叠，然后对齐相加</li>
</ul>
</li>
<li><p>Example 例子：一个关键字为83950661436，哈希表长为3 首先将关键字表长分割成若干部分：</p>
<p>位移法： 间接折叠法：</p>
<p>由于哈希表长度为3，分别取后三位991和721作为关键地对应的哈希地址。</p>
</li>
</ul>
</li>
<li><p>除留余数法</p>
<ul>
<li>定义 选择一个常数，取关键字除以所得的余数作为哈希地址，即</li>
</ul>
</li>
</ol>
<pre><code>    该方法对的选取非常重要，若哈希表长度为，则要求小于等于且接近，并且一般选质数作为，或者是一个不包含小于20质因子的合数。
</code></pre><ol>
<li><p>处理冲突的方法</p>
<ol>
<li><p>开放定址法</p>
<ul>
<li>定义 开放地址，即一旦根据关键字所得到的哈希地址发生冲突，则按照某种规则寻找下一个空闲单元的哈希地址，只要哈希地址足够大，空的哈希地址总是能找到的。 其函数定义为：</li>
</ul>
</li>
</ol>
</li>
</ol>
<pre><code>    其中，为哈希函数，为哈希表长，的所取的增量序列。每种再散列的方法区别在于的取值不同。

  - 常用的方法

    - 线性探测再散列 取增量序列为的方法。 其过程描述为：当哈希地址发生冲突时，查看哈希地址是否为空，若为空则将数据放入，否则查看是否为空，依次类推
    - 二次探测在散列 取增量序列为 其过程描述为：当哈希地址发生冲突时，查看哈希地址是否为空，若为空则将数据放入，否则查看是否为空，若为空则将数据放入，否则查看是否为空，依次类推
    - 伪随机探测在散列 取增量序列为一个伪随机数 其过程描述为：当哈希地址发生冲突时，产生一个伪随机数，查找哈希地址是否为空，若为空则将数据放入，否则重新产生一个伪随机数查看是否为空，依次类推。
</code></pre><ol>
<li><p>再哈希法</p>
<ul>
<li>定义 再哈希法用数学表达式可以描述为:</li>
</ul>
</li>
</ol>
<pre><code>    其中，均为不同的哈希函数。 在哈希法的本质是使用个哈希函数，若第一个函数发生冲突，则利用第二个函数再生生成一个地址，直到产生的地址不冲突为止。
</code></pre><ol>
<li><p>链地址法</p>
<ul>
<li>定义 将每个哈希地址都作为一个指针，指向一个链表。 若哈希表长为，则建立个空链表，将哈希函数对关键字进行转换为后，映射到统一哈希地址的同义词均加入到地址指向的链表中</li>
</ul>
</li>
<li><p>建立一个公共溢出区</p>
<ul>
<li>定义 设哈希函数产生的哈希地址集为，则分配两个表。一个表作为基本表，其每个存储单元仅存放一个数据元素；另一个表为溢出表，只要关键字对应的哈希地址在基本表上发生了冲突，则将发生冲突的元素一律放入该表中。</li>
</ul>
<p>查找时，对应给定关键字，通过哈希函数计算出哈希地址为，则先与基本表中的地址为的数据元素进行比较，若相等则查找成功；否则再在溢出表中进行查找。</p>
</li>
</ol>
<ol>
<li><p>哈希查找算法及分析</p>
<p>查找元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define p 13&#x2F;&#x2F;MOD 13</span><br><span class="line">struct HashTable</span><br><span class="line">&#123;</span><br><span class="line">    int *elem;&#x2F;&#x2F;数据元素基址</span><br><span class="line">    int count;&#x2F;&#x2F;当前数据元素个数</span><br><span class="line">    int size;&#x2F;&#x2F;哈希表长度</span><br><span class="line">&#125;ht;</span><br><span class="line">int SearchHash(int key,int &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    s &#x3D; CalHash(key);</span><br><span class="line">    while((ht.elem[s]!&#x3D;-1)&amp;&amp;(ht.elem[s]!&#x3D;key))&#x2F;&#x2F;发生冲突</span><br><span class="line">        Collision(s);</span><br><span class="line">    if(ht.elem[s]&#x3D;&#x3D;key)</span><br><span class="line">        return 1;</span><br><span class="line">    else</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算哈希地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int CalHash(int key)&#x2F;&#x2F;由哈希函数求哈希地址</span><br><span class="line">&#123;</span><br><span class="line">    return key % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发生冲突，计算下一地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Collision(int &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    s&#x3D;s++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int InsertHash(int e)</span><br><span class="line">&#123;</span><br><span class="line">    int s;</span><br><span class="line">    if(ht.count &#x3D;&#x3D; ht.size)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; &quot;表满，不能插入！&quot; &lt;&lt; endl;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        s &#x3D; CalHash(e);</span><br><span class="line">        int r &#x3D; SearchHash(e,s);</span><br><span class="line">        if(r)&#x2F;&#x2F;表中已有和e的关键字相同的元素，不能插入操作</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;元素已经存在，不能插入！&quot; &lt;&lt; endl;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            ht.elem[s]&#x3D;e;</span><br><span class="line">            ht.count++;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找过程中，关键字的比较次数取决于产生冲突的次数，冲突产生越少，查找效率就越高。</p>
<p>影响冲突产生的因素有：</p>
<ol>
<li><p>哈希函数是否均匀</p>
</li>
<li><p>冲突的处理方法</p>
</li>
<li><p>哈希表的<strong>装填因子</strong> 将哈希表中元素的个数和哈希长度的比值最为哈希表的装填因子，即</p>
</li>
</ol>
</li>
</ol>
<pre><code>  是哈希表装满程度的指标，即装填因子。 与填入表中的元素的个数成正比，填入表中元素越多越大，冲突产生的可能性越大。
</code></pre><h2 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h2><h3 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h3><ul>
<li><p>排序</p>
<p>设有记录序列，其相应的关键字序列为， 若存在某种确定的关系，其中且各不相同，则将记录序列排成按关键字有序的序列的操作。</p>
</li>
<li><p>正序：若待排序序列中的记录已按关键字排序，此序列为正序</p>
</li>
<li><p>逆序和反序：若待排序序列中的记录的排序顺序与排序后的排列顺序正好相反</p>
</li>
<li><p>一趟：指在排序过程中，将待排序的记录序列扫描一遍</p>
</li>
<li><p>单关键字排序：根据一个关键字进行的排序</p>
</li>
<li><p>多关键字排序：根据多个关键字进行的排序，多关键字排序主要针对关键字有重复的情况下。</p>
</li>
<li><p>按照排序过程中数据元素是否完全在内存，分为：</p>
<ol>
<li>内部排序：在排序的整个过程，待排序的所有记录全部放置在内存中的排序方法，也称内排序</li>
<li>外部排序：指待排序的记录个数太多，不能同时放置在内存，需要将一部分记录放置在内存中，另一部分放置在外存中，整个排序过程需要在内外存之间多次交换数据才能得到排序结果的方法，也称外排序</li>
</ol>
</li>
<li><p>按照是否建立在关键字比较的基础上，分为：</p>
<ol>
<li>基于比较的排序方法：通过关键字之间的比较、记录的移动者两种操作来实现的方法 如：插入排序、交换排序、选择排序和归并排序</li>
<li>不基于比较的排序方法：根据待排序数据的特点所采取的其他方法，通常没有大量的关键字之间的比较和记录的移动这两种操作的排序 如：基数排序</li>
</ol>
</li>
</ul>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ul>
<li>插入排序的工作原理：每次将一个待排序的数据按其关键字的大小<strong>插入</strong>到一个已经完成排序的<strong>有序序列</strong>中，直到所有记录排序结束。</li>
<li>根据排序的执行过程分为<ul>
<li>直接插入排序</li>
<li>折半插入排序</li>
<li>表插入排序</li>
<li>Shell排序</li>
</ul>
</li>
</ul>
<ol>
<li><p>直接插入排序</p>
<ul>
<li><p>算法思路</p>
<p>通过构建有序序列，对于未排序数据，在已排序序列中从后往前扫描，从而找到相应的位置并插入。 在从后往前扫描过程中，需要反复把已排序逐步往后挪位，为待插入的新元素提供插入空间</p>
</li>
<li><p>步骤</p>
<ol>
<li>设置</li>
<li>将待插入记录放入编号为0的结点(即下标为0的结点)，即;并令，从第个记录开始向前查找插入位置</li>
<li>若,执行5；否则执行4</li>
<li>将第个记录后移，即；并令;执行3</li>
<li>完成插入记录：。若，则排序结束，否则执行2</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>语言描述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SInsertSort(SqList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i&#x3D;2;i&lt;&#x3D;L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(L.r[i]&lt;&#x3D;L.r[i-1])</span><br><span class="line">        &#123;</span><br><span class="line">            L.r[0]&#x3D;L.r[i];</span><br><span class="line">            L.r[i]&#x3D;L.r[i-1];</span><br><span class="line">            for(int j&#x3D;i-2;L.r[0]&lt;&#x3D;L.r[j];j--)</span><br><span class="line">                L.r[j+1]&#x3D;L.r[j];</span><br><span class="line">            L.r[j+1]&#x3D;L.r[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：两层嵌套循环结构，其外层循环n-1次，而内层循环执行次数取决于待排序列记录初始的排列情况。<ul>
<li>最好情况：待排序序列为正序，算法时间复杂度为</li>
<li>最坏情况：待排序序列为逆序，算法时间复杂度为</li>
<li>平均情况：算法的平均时间复杂度为</li>
</ul>
</li>
<li>空间复杂度：由于只需一个作为暂存待插入记录的存储单元，空间复杂度为</li>
<li>稳定性：该算法是稳定的排序算法</li>
</ul>
</li>
</ul>
<ol>
<li><p>折半插入排序</p>
<blockquote>
<p>当待排序记录数量很小时，直接插入排序方法是一种效率较高的排序算法。当记录数量较大，不宜用直接插入排序。</p>
</blockquote>
<ul>
<li><p>算法思想</p>
<p>既然在有序表中确定插入位置，可以不断二分有序表来确定插入位置，即在一次比较中，通过比较待插入记录和有序表中中间记录的关键字，将有序表一分为二，而下一次比较则在其中一个有序子表中进行，将子表再次一分为二。这样继续下去，直到要比较的子表中只有一个记录时，做最后一次比较以确定插入位置。</p>
</li>
<li><p>步骤</p>
<ol>
<li>设置</li>
<li>顺序表中前个记录有序，将第个记录插入。令，，</li>
<li>若,得到插入位置；执行6；否则执行4</li>
<li>则取有序子表的中点</li>
<li>若,则插入位置在低半区，令；否则插入位置在高半区，令;执行3</li>
<li>即为待插入位置，从到的记录，逐个后移，。若，则排序结束，否则执行2</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>语言描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void BInsertSort(SqList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">    int high,low,m;</span><br><span class="line">    for(int i&#x3D;2;i&lt;&#x3D;L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.r[0]&#x3D;L.r[i];</span><br><span class="line">        low &#x3D; 1;</span><br><span class="line">        high &#x3D; i-1;</span><br><span class="line">        while(low&lt;&#x3D;high)</span><br><span class="line">        &#123;</span><br><span class="line">            m &#x3D; (low+high)&#x2F;2;</span><br><span class="line">            if(L.r[0]&lt;&#x3D;L.r[m])</span><br><span class="line">                high&#x3D;m-1;</span><br><span class="line">            else</span><br><span class="line">                low&#x3D;m+1;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j&#x3D;i-1;j&gt;high+1;j--)</span><br><span class="line">            L.r[j+1]&#x3D;r[j];</span><br><span class="line">        L.r[high+1]&#x3D;L.r[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：关键字比较次数最多为因此时间复杂度为</li>
<li>空间复杂度：</li>
<li>稳定性：折半插入排序是稳定的排序方法</li>
</ul>
</li>
</ul>
<ol>
<li><p>表插入排序</p>
<blockquote>
<p>前面介绍的两种插入排序算法都要大量移动记录，表插入排序则是一种不移动记录而是通过改变存储结构来进行排序的算法</p>
</blockquote>
<ul>
<li><p>算法思想</p>
<p>表插入排序是通过链接指针、按关键字的大小实现从小到大的链接过程，为此需增设一个指针项。</p>
<p>具体的操作方法与直接插入排序类似，不同的是表插入排序是直接修改链接指针来完成记录的排序。</p>
<p>所需结点定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define SIZE 150</span><br><span class="line">struct SLNode</span><br><span class="line">&#123;</span><br><span class="line">    int rc;&#x2F;&#x2F;记录项</span><br><span class="line">    int next;&#x2F;&#x2F;指针项</span><br><span class="line">&#125;;</span><br><span class="line">struct SLinkList</span><br><span class="line">&#123;</span><br><span class="line">    SLNode node[size];&#x2F;&#x2F;0号单元为表头结点</span><br><span class="line">    int curlen;&#x2F;&#x2F;链表实际长度</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<p>具体思想：</p>
<p>首先设置空循环链表，即头结点指针置0，并在头结点数据中存放比所有记录的关键字都大的整数，然后把结点逐个向链表中插入即可。</p>
</li>
<li><p>步骤</p>
<ol>
<li>进行初始化操作。令</li>
<li>若，调整结束；否则根据对静态链表进行遍历：<ol>
<li>当时停止遍历，令执行2</li>
<li>当时，，执行2.1</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>语言描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void SLInsertSort(SlinkList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">    int min,max;</span><br><span class="line">    L.node[0].next &#x3D; 1;</span><br><span class="line">    L.node[1].next &#x3D; 0;&#x2F;&#x2F;初始化形成指头头结点的循环链表</span><br><span class="line">    max &#x3D; min &#x3D; 1;</span><br><span class="line">    for(int i&#x3D;2;i&lt;&#x3D;L.curlen;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(L.node[i].rc&lt;&#x3D;L.node[min].rc)</span><br><span class="line">        &#123;</span><br><span class="line">            L.node[0].next &#x3D; i;</span><br><span class="line">            L.node[i].next &#x3D; i-1;</span><br><span class="line">            min &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(L.node[i].rc&gt;&#x3D;L.node[max].rc)</span><br><span class="line">        &#123;</span><br><span class="line">            L.node[i].next &#x3D; 0;</span><br><span class="line">            L.node[max].next &#x3D; i;</span><br><span class="line">            max &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">        if(L.node[i].rc&lt;L.node[max].rc &amp;&amp; L.node[i].rc &gt; L.node[min].rc)</span><br><span class="line">        &#123;</span><br><span class="line">            int index1&#x3D;min,index2;&#x2F;&#x2F;index2标记index1的前一个下标</span><br><span class="line">            while(L.node[i].rc&gt;&#x3D;L.node[index1].rc)</span><br><span class="line">            &#123;</span><br><span class="line">                index2&#x3D;index1;</span><br><span class="line">                index1&#x3D;L.node[index1].next;</span><br><span class="line">            &#125;</span><br><span class="line">            L.node[i].next&#x3D;index1;</span><br><span class="line">            L.node[index2].next&#x3D;i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; &quot;表插入排序结果如下：&quot; &lt;&lt; endl;</span><br><span class="line">    int index &#x3D; L.node[0].next;</span><br><span class="line">    while(index!&#x3D;0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; L.node[index].rc &lt;&lt; &quot;\t&quot;;</span><br><span class="line">        index &#x3D; L.node[index].next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：</li>
<li>空间复杂度：</li>
<li>稳定性：表插入排序是稳定的排序方法</li>
</ul>
</li>
</ul>
<ol>
<li><p>希尔排序</p>
<blockquote>
<p>希尔排序又称缩小增量排序，是1969年D.L.Shell提出的，它是对直接插入排序的一种改进</p>
</blockquote>
<ul>
<li><p>算法思想</p>
<ul>
<li><p>先将待排序记录分成若干个子序列，在子序列内分别进行直接插入排序；</p>
</li>
<li><p>直到整个序列基本有序时，在对全体记录进行一次直接插入排序。</p>
</li>
<li><p>与直接插入排序的区别</p>
<p>希尔排序不是每次一个元素挨着一个元素比较，而是初期选用大跨步(增量较大)间隔比较，使记录跳跃式的接近它的排序位置；然后增量逐步缩小，最后增量为1.</p>
</li>
</ul>
</li>
<li><p>步骤</p>
<ol>
<li>选择一个步长序列，其中且当时，</li>
<li>按步长序列个数，对序列执行次3</li>
<li>每次排序，根据对应的步长，将待排序列分成若干个子序列，分别对各子序列进行直接插入排序。当步长为1时，整个序列作为一个表来处理，表长度即为整个序列的长度</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>语言描述</p>
<ul>
<li><p>子程序(一趟希尔排序)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ShellInsert(SqList &amp;L,int dk)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i&#x3D;dk+1;i&lt;&#x3D;L.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.r[0]&#x3D;L.r[i];</span><br><span class="line">        for(int j&#x3D;i-dk;j&gt;0 &amp;&amp; L.r[0]&lt;&#x3D;L.r[j];j-&#x3D;dk)</span><br><span class="line">            L.r[j+dk]&#x3D;L.r[j];</span><br><span class="line">        L.r[j+dk]&#x3D;L.r[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主程序(按照增量序列对顺序表调用子程序)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ShellSort(SqList &amp;L,int dlta[],int t)</span><br><span class="line">&#123;</span><br><span class="line">    for(int k&#x3D;0;k&lt;t;k++)</span><br><span class="line">        ShellInsert(L,dlta[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：时间性能在，当在某个特定范围，希尔排序算法的时间复杂度约为</li>
<li>空间复杂度：</li>
<li>稳定性：不稳定，以为例，该序列经过步长序列的希尔排序得到有序序列为</li>
</ul>
</li>
</ul>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><blockquote>
<p>交换排序是一类借助比较和交换进行排序的犯法。其中交换是指对序列中两个记录的关键字进行比较，如果排序不对则对换两个记录在序列中的位置。交换排序的特点是：将关键字较大的记录向序列的一端移动，而关键字较小的记录向序列的另一端移动。</p>
</blockquote>
<ol>
<li><p>冒泡排序</p>
<blockquote>
<p>冒泡排序也称为起泡排序，是交换排序中常用的排序方法</p>
</blockquote>
<ul>
<li><p>算法思想</p>
<p>通过对排序元素中相邻元素间的关键字的比较和交换，是关键字最大的元素如气泡一样逐渐“上浮”。</p>
</li>
<li><p>步骤</p>
<ol>
<li>从存储个待排序元素的表尾开始，并令</li>
<li>若，则排序结束</li>
<li>从第一个元素开始进行两两比较，令</li>
<li>若，则冒泡排序结束，；待排序表记录数为-1，转2</li>
<li>比较与，若，则不交换，转7</li>
<li>当时，将和交换</li>
<li>，转4继续比较</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>语言描述</p>
<p>1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void BubbleSort(SqList &amp;L)</span><br></pre></td></tr></table></figure>
<p>2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int i &#x3D; 1; i &lt; L.length; i++)</span><br></pre></td></tr></table></figure>
<p>4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int j &#x3D; 0; j &lt; L.length - i; j++)</span><br></pre></td></tr></table></figure>
<p>6</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (L.r[j] &gt; L.r[j + 1])</span><br></pre></td></tr></table></figure>
<p>8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>9</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int t &#x3D; L.r[j];</span><br></pre></td></tr></table></figure>
<p>10</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L.r[j] &#x3D; L.r[j + 1];</span><br></pre></td></tr></table></figure>
<p>11</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L.r[j + 1] &#x3D; t;</span><br></pre></td></tr></table></figure>
<p>12</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>13</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>14</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>15</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度 总需要进行次冒泡，对个记录的表进行一趟冒泡排序需要次关键字比较，平均的总比较次数为:</li>
</ul>
</li>
</ul>
<pre><code>   - 平均时间复杂度为：
   - 最好情况：
   - 最坏情况：

 - 稳定性：冒泡排序是一种稳定的排序方法。比较是相邻单元进行的，如果关键字值相同则不进行交换。
</code></pre><ol>
<li><p>快速排序</p>
<blockquote>
<p>快速排序也称分区交换排序</p>
</blockquote>
<ul>
<li><p>算法思想</p>
<p>通过对关键字的比较和交换，以待排序列中的某个数据为支点(或称枢轴量)，将待排序列分成两个部分，其中左半部分小于等于支点，右半部分大于等于支点。然后对左右两部分分别进行快速排序的递归处理，直到整个序列按关键字有序为止。</p>
<p>其中将待排序列按关键字以支点分成两个部分的过程称为<strong>一次划分</strong></p>
</li>
</ul>
</li>
</ol>
<pre><code> 冒泡排序中，元素的比较和移动是在相邻位置进行的，元素比较次数和移动次数较多。 而在快速排序中，元素的比较和移动是从两端向中间进行的，关键字较大的记录一次就能从前面移动到后面，关键字较小的记录一次移动到前面，记录移动的距离较远，从而减少了总的比较次数和移动次数。 可将快速排序看做对冒泡排序的一种改进。
</code></pre><ul>
<li><p>步骤</p>
<ol>
<li>如果待排序子序列中元素的个数等于1，则排序结束；否则以为支点，按如下方法进行一次划分：<ol>
<li>设置两个搜索指针：是向后搜索指针，初始指向序列第一个结点；是向前搜索指针，初始指向最后一个结点；取第一个记录为支点，位暂时取值为支点。</li>
<li>若,枢轴空位确定为，一次划分结束。</li>
<li>若且，则从所指定的位置向前搜索：，重新执行1.3； 否则若有并且有，则设置为新的支点位置。 并交换和，然后令,执行1.4；若，则执行1.2</li>
<li>若且。则从所指的位置开始向后搜索：，重新执行1.4； 否则若由并且有，则设置为新的支点位置， 并交换和，然后令，执行1.3；若，则执行1.2</li>
</ol>
</li>
<li>对支点左半子序列重复1</li>
<li>对支点右半子序列重复1</li>
</ol>
</li>
<li><p>语言描述</p>
<p>1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int QSort::Partition(SqList &amp;L, int low, int high)&#x2F;对序列的一次划分</span><br></pre></td></tr></table></figure>
<p>2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int pivotkey;</span><br></pre></td></tr></table></figure>
<p>4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L.r[0] &#x3D; L.r[low];   &#x2F;&#x2F;用子表的第一个记录作枢轴记录</span><br></pre></td></tr></table></figure>
<p>5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pivotkey &#x3D; L.r[low]; &#x2F;&#x2F;关键字</span><br></pre></td></tr></table></figure>
<p>6</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<p>7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (low &lt; high) &#x2F;&#x2F;从表的两边交替向中间扫描</span><br></pre></td></tr></table></figure>
<p>8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>9</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<p>10</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (low &lt; high &amp;&amp; L.r[high] &gt;&#x3D; pivotkey)</span><br></pre></td></tr></table></figure>
<p>11</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>12</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--high;</span><br></pre></td></tr></table></figure>
<p>13</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>14</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L.r[low] &#x3D; L.r[high]; &#x2F;&#x2F;将比枢轴小的记录移至低端</span><br></pre></td></tr></table></figure>
<p>15</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<p>16</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while (low &lt; high &amp;&amp; L.r[low] &lt;&#x3D; pivotkey)</span><br></pre></td></tr></table></figure>
<p>17</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>18</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">++low;</span><br></pre></td></tr></table></figure>
<p>19</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>20</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L.r[high] &#x3D; L.r[low]; &#x2F;&#x2F;将比枢轴大的记录移至高端</span><br></pre></td></tr></table></figure>
<p>21</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>22</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L.r[low] &#x3D; L.r[0]; &#x2F;&#x2F;枢轴记录到位</span><br></pre></td></tr></table></figure>
<p>23</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return low;        &#x2F;&#x2F;返回枢轴位置</span><br></pre></td></tr></table></figure>
<p>24</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>25</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void QSort::QuickSort1(SqList &amp;L, int low, int high) &#x2F;&#x2F;按分区对子程序进行调用</span><br></pre></td></tr></table></figure>
<p>26</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>27</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int mid;</span><br></pre></td></tr></table></figure>
<p>28</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (low &lt; high)</span><br></pre></td></tr></table></figure>
<p>29</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>30</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mid &#x3D; Partition(L, low, high);</span><br></pre></td></tr></table></figure>
<p>31</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QuickSort1(L, low, mid - 1);</span><br></pre></td></tr></table></figure>
<p>32</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QuickSort1(L, mid + 1, high);</span><br></pre></td></tr></table></figure>
<p>33</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>34</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度<ul>
<li>最好情况：每次支点都将待排序划分成两个长度相等的子列时，</li>
<li>最坏情况：每次划分都只得到一个子列时，快速排序的过程类似冒泡排序，</li>
<li>为了避免最坏情况，对快速排序进行一定的改进，改进方法是选取支点时选最左、最右和中间三个元素取值处于中间的元素作为支点。</li>
</ul>
</li>
<li>空间复杂度：</li>
<li>稳定性：以为例，经过快速排序得到有序序列为，因此快速排序是<strong>不稳定</strong>的排序方法</li>
</ul>
</li>
</ul>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><blockquote>
<p><strong>选择排序</strong>是一类借助”选择”进行排序的方法</p>
</blockquote>
<ul>
<li><p>算法思想</p>
<p>每一趟从待排序列中选取一个关键字最小的记录，也即第一趟从个记录中选取关键字最小的记录，第二趟从剩下的个记录中选取关键字最小的记录，直到全部元素排序完毕。</p>
<p>适用于从大量元素中选择一部分排序元素的应用，如从50000个元素中选择前10个关键字最小的元素等。</p>
</li>
</ul>
<ol>
<li><p>简单选择排序</p>
<ul>
<li><p>算法思想</p>
<p>第一趟从个记录中选出关键字最小的记录和第一个记录交换；第二趟从第二个记录开始的个记录中选出关键字最小的记录与第二个记录交换；如此第趟则从第个记录开始的个记录中选出关键字最小的记录与第个记录交换，直到整个序列按关键字有序。</p>
</li>
<li><p>步骤</p>
<blockquote>
<p>注：书上的设置i=1，因为书上默认列表的第一个元素即用来暂存待移动的下标</p>
</blockquote>
<ol>
<li>创建一个辅助变量用于存放每次遍历关键字最小记录的下标，设指变量</li>
<li>遍历第个记录到第个记录。选这一个关键字最小的记录，将其下标保存指中</li>
<li>若第个记录的关键字小于中保存的记录的关键字，则交换这两个记录</li>
<li>，若，则执行2；否则排序结束</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>语言描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void QSort::SSelectionSort(SqList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">    int t, j;</span><br><span class="line">    for (int x &#x3D; 0; x &lt;&#x3D; L.length - 1; x++)</span><br><span class="line">    &#123;</span><br><span class="line">        j &#x3D; x;</span><br><span class="line">        for (int y &#x3D; x; y &lt;&#x3D; L.length - 1; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (L.r[y] &lt; L.r[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j &#x3D; y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (x !&#x3D; j)</span><br><span class="line">        &#123;</span><br><span class="line">            t &#x3D; L.r[x];</span><br><span class="line">            L.r[x] &#x3D; L.r[j];</span><br><span class="line">            L.r[j] &#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：总比较次数为：，</li>
<li>空间复杂度：</li>
<li>稳定性：简单选择排序是稳定的排序方法</li>
</ul>
</li>
</ul>
<ol>
<li><p>树形选择排序</p>
<blockquote>
<p><strong>树形选择排序</strong>又称<strong>锦标赛排序</strong>，它是一种按照锦标赛的思想设计的选择排序方法</p>
</blockquote>
<ul>
<li><p>算法思想</p>
<p>将个参赛选择完全视为完全二叉树的叶子结点，则该完全二叉树有或个结点。首先，叶子结点进行两两比较，胜出(关键字较小者胜出)的结点在在兄弟结点之间再两两比较，直至产生第一名；接下来将作为第一名的结点视为最差的，并从该结点开始，沿该结点到根路径上，依次进行各分支结点孩子之间的比较，胜出的就是第二名(因为和它比赛的均是刚刚输给第一名的结点)。这样继续下去，直到所有选手的名次排定。</p>
</li>
<li><p>步骤</p>
<ol>
<li>从底层的叶子结点开始，逐层进行兄弟间的比较，关键字较小者上升为双亲结点，直到树根为止。</li>
<li>将树的根结点输出，并将底层叶子结点中的一个值与输出结点值相同的结点设为.</li>
<li>如果输出的结点总数小于初始树的叶子结点个数，则重复步骤1；否则结束排序。</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：树的深度为，进行了次比较，</li>
<li>空间复杂度：</li>
<li>稳定性：树形选择排序是稳定的排序方法</li>
</ul>
</li>
</ul>
<ol>
<li><p>堆排序</p>
<blockquote>
<p>堆排序利用堆的特性进行排序的方法。 堆排序适用于从1000个数据中选出较小的十个数据</p>
</blockquote>
<p>堆：设有个元素的序列,当且仅当满足下述关系之一时：</p>
</li>
</ol>
<p>   其中，，分别称为小顶堆和大顶堆。</p>
<p>   根据堆的性质，它也是完全二叉树，且具有下列性质之一：</p>
<ol>
<li>每个结点的值都小于或等于其左右孩子的值，称之为<strong>小顶堆</strong></li>
<li>每个结点的值都大于或等于其左右孩子的值，称之为<strong>大顶堆</strong></li>
</ol>
<ul>
<li><p>算法思想</p>
<p>首先用待排序列的记录序列构造出一个堆，此时选出了堆中所有记录的最小者为堆顶，随后将它从堆中移走(通常是将堆顶记录和堆中最后一个记录交换)，并将剩余记录在调整成堆，这样又找出了次小的记录，依次类推，直到堆中只有一个记录位置。</p>
</li>
<li><p>步骤</p>
<ol>
<li>i=1，基于顺序表中的元素先建一个小顶堆</li>
<li>将堆顶元素和交换</li>
<li>，若，则再对进行调整，形成新的小顶堆，执行2； 若，则排序结束</li>
</ol>
</li>
</ul>
<pre><code> &gt; 图片的内容没有过关联，只是在网上找的图片示例，便于理解堆排序的过程。

 堆的创建：(按照二叉树顺序放好，对第一个有孩子的结点进行比较)
</code></pre><ul>
<li><p>语言描述</p>
<p>1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;堆的建立</span><br></pre></td></tr></table></figure>
<p>2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void HeapAdjust(SqList &amp;L, int s, int m) &#x2F;&#x2F;对顺序表做查找，从值最小的孩子结点向下筛选，找到最小值</span><br></pre></td></tr></table></figure>
<p>3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int rc &#x3D; L.r[s];</span><br></pre></td></tr></table></figure>
<p>5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int j &#x3D; 2 * s; j &lt;&#x3D; m; j *&#x3D; 2)</span><br></pre></td></tr></table></figure>
<p>6</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (j &lt; m &amp;&amp; L.r[j] &gt;&#x3D; L.r[j + 1])</span><br></pre></td></tr></table></figure>
<p>8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">j++;</span><br></pre></td></tr></table></figure>
<p>9</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (rc &lt; L.r[j])</span><br></pre></td></tr></table></figure>
<p>10</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">break;</span><br></pre></td></tr></table></figure>
<p>11</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L.r[s] &#x3D; L.r[j];</span><br></pre></td></tr></table></figure>
<p>12</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; j;</span><br></pre></td></tr></table></figure>
<p>13</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>14</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L.r[s] &#x3D; rc;</span><br></pre></td></tr></table></figure>
<p>15</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>16</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;完整的堆排序</span><br></pre></td></tr></table></figure>
<p>17</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void HeapSort(SqList &amp;L) &#x2F;&#x2F;对顺序表L进行堆排序</span><br></pre></td></tr></table></figure>
<p>18</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>19</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int value;</span><br></pre></td></tr></table></figure>
<p>20</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i;</span><br></pre></td></tr></table></figure>
<p>21</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (i &#x3D; L.length &#x2F; 2; i &gt; 0; i--) &#x2F;&#x2F;把L.r[1...L.length]调整为小顶堆</span><br></pre></td></tr></table></figure>
<p>22</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HeapAdjust(L, i, L.length);</span><br></pre></td></tr></table></figure>
<p>23</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (i &#x3D; L.length; i &gt; 1; i--)</span><br></pre></td></tr></table></figure>
<p>24</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>25</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">value &#x3D; L.r[1];</span><br></pre></td></tr></table></figure>
<p>26</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L.r[1] &#x3D; L.r[i];</span><br></pre></td></tr></table></figure>
<p>27</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">L.r[i] &#x3D; value;</span><br></pre></td></tr></table></figure>
<p>28</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HeapAdjust(L, 1, i - 1);</span><br></pre></td></tr></table></figure>
<p>29</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>30</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：建堆需要，每次取完顶堆进行调整需要的时间为，且过程经过次，总的时间复杂度：</li>
<li>空间复杂度：</li>
<li>稳定性：不稳定的排序方法</li>
</ul>
</li>
</ul>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><strong>归并排序</strong>是借助归并进行排序的方法。</p>
<p>归并的含义：将两个或两个以上的有序序列归并成一个有序序列的过程。</p>
<p>归并排序按所合并的表的个数分为：二路归并排序和多路归并排序</p>
<ul>
<li><p>二路归并排序</p>
<ul>
<li><p>算法思想</p>
<p>将待排序的个元素看成是个有序的子序列，每个子序列的长度为1，然后两两归并，得到个长度为2或1(最后一个有序序列长度可能为1)的有序子序列；再两两归并，得到个长度为4或小于4(最后一个有序序列长度可能小于4)的有序子序列;再两两归并，直至得到一个长度为的有序序列</p>
</li>
<li><p>步骤</p>
<ol>
<li>将待排序序列划分为两个长度相当的子序列</li>
<li>若子序列长度大于1，则对子序列执行一次归并排序</li>
<li>执行下列步骤对子序列两两合并成有序序列<ol>
<li>创建一个辅助数组。假设两个子列的长度分别为，两个子列的下标为。设置两个子表的起始下标和辅助数组的起始下标：</li>
<li>若h或，说明其中一个子表已经合并完毕，直接执行3.4</li>
<li>选取和中关键字较小的存入辅助数组:若，则否则，返回执行3.2</li>
<li>尚未处理完的子表元素与此存入，结束合并，并将结果返回。</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>语言描述</p>
<p>1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;一趟归并排序</span><br></pre></td></tr></table></figure>
<p>2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Merge(int *SR, int *TR, int i, int m, int n)</span><br></pre></td></tr></table></figure>
<p>3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int j, k;</span><br></pre></td></tr></table></figure>
<p>5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (j &#x3D; m + 1, k &#x3D; i; i &lt;&#x3D; m &amp;&amp; j &lt;&#x3D; n; k++) &#x2F;&#x2F;将SR中的记录由大到小并入TR</span><br></pre></td></tr></table></figure>
<p>6</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>7</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (SR[i] &lt;&#x3D; SR[j])</span><br></pre></td></tr></table></figure>
<p>8</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>9</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TR[k] &#x3D; SR[i++];</span><br></pre></td></tr></table></figure>
<p>10</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>11</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">else</span><br></pre></td></tr></table></figure>
<p>12</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>13</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TR[k] &#x3D; SR[j++];</span><br></pre></td></tr></table></figure>
<p>14</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>15</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>16</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure>
<p>17</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (i &lt;&#x3D; m) &#x2F;&#x2F;将剩余的SR[i...m]赋值到TR</span><br></pre></td></tr></table></figure>
<p>18</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>19</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int a &#x3D; i; a &lt;&#x3D; m; a++)</span><br></pre></td></tr></table></figure>
<p>20</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>21</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TR[k++] &#x3D; SR[a];</span><br></pre></td></tr></table></figure>
<p>22</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>23</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>24</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">else if (j &lt;&#x3D; n) &#x2F;&#x2F;将剩余的SR[j...n]赋值到TR</span><br></pre></td></tr></table></figure>
<p>25</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>26</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int b &#x3D; j; b &lt;&#x3D; n; b++)</span><br></pre></td></tr></table></figure>
<p>27</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>28</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TR[k++] &#x3D; SR[b];</span><br></pre></td></tr></table></figure>
<p>29</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>30</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>31</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>32</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;归并排序递归算法</span><br></pre></td></tr></table></figure>
<p>33</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void MergeSort(int *SR, int *TR1, int s, int t)</span><br></pre></td></tr></table></figure>
<p>34</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>35</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int TR2[100];</span><br></pre></td></tr></table></figure>
<p>36</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int m;</span><br></pre></td></tr></table></figure>
<p>37</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (s &#x3D;&#x3D; t)</span><br></pre></td></tr></table></figure>
<p>38</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>39</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TR1[s] &#x3D; SR[s];</span><br></pre></td></tr></table></figure>
<p>40</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>41</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">else</span><br></pre></td></tr></table></figure>
<p>42</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br></pre></td></tr></table></figure>
<p>43</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m &#x3D; (s + t) &#x2F; 2;</span><br></pre></td></tr></table></figure>
<p>44</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MergeSort(SR, TR2, s, m);</span><br></pre></td></tr></table></figure>
<p>45</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MergeSort(SR, TR2, m+1, t);</span><br></pre></td></tr></table></figure>
<p>46</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Merge(TR2,TR1,s,m,t);</span><br></pre></td></tr></table></figure>
<p>47</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>48</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：</li>
<li>空间复杂度：</li>
<li>稳定性：归并排序是稳定的排序算法</li>
</ul>
</li>
<li><p>Ex:{49,38,65,97,76,13,27}</p>
<ol>
<li>看成一个关键字的子序列</li>
<li>第一趟两两归并：{38,49}，{65,97}，{13,76}，{27}</li>
<li>第二趟：{38,49,65,97},{13,27,79}</li>
<li>第三趟：13,27,38,49,95,76,97</li>
</ol>
</li>
</ul>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p><strong>基数排序</strong>不利用关键字之间的比较和移动操作来进行排序，而是通过多关键字排序的思想，根据关键字每个位上的有效数字的取值，借助分配和收集两种操作对单关键字进行排序。</p>
<ol>
<li><p>多关键字的排序</p>
<blockquote>
<p><strong>多关键字排序</strong>是应用在多关键字的序列上的排序方法，最常见的多关键字序列的排序方法是<strong>最低优先法</strong></p>
</blockquote>
<ul>
<li><p>最低优先法的算法思想</p>
<p>首先按照最低位进行排序，再对高一位关键字进行排序，一次类推直到所有关键字都排序完毕。</p>
</li>
<li><p>Example</p>
<p>代表性的例子就是扑克牌的排序。可以将扑克牌的52张牌按花色和值分成两个关键字，其关系如下：</p>
<ul>
<li>花色：梅花方块红桃黑桃</li>
<li>值： 且花色的关键字等级高于值关键字。 花色相同时，才根据值确定大小。</li>
</ul>
</li>
</ul>
</li>
<li><p>链式基数排序</p>
<blockquote>
<p>对于单关键字的序列，也可以通过将关键字拆分成若干项，每一项都看作是一个新的关键字，则可以利用上述多关键字排序的方法对单关键字的序列进行排序。如对于一个2位的整数，可以将其按照位数拆分为2项。这样拆分后，每个关键字的范围都相同，这样关键字可以出现的符号个数称为”基”,例如，二进制数的基是2，十进制数的基是10。基于这样的设定，可以通过多关键字排序的方法方便地进行单关键字序列排序。</p>
</blockquote>
<p>链式基数排序：采用单链表作为分配的”容器”.</p>
<ul>
<li><p>步骤</p>
<ol>
<li>建立待排序序列的静态链表和分配记录用的若干个单链表</li>
<li>从最低位关键字开始，按关键字将中记录分配到各个单链表中</li>
<li>按照关键字的值从小到大从各个单链表中收集记录到静态链表中，重复Step2直至排序完成。</li>
</ol>
</li>
<li><p>Example</p>
<p>例如：给定8个2位的十进制数序列：49,39,65,97,76,13,27,69，采用链式基数排序的过程如下。</p>
</li>
</ul>
</li>
</ol>
<pre><code> 方法：设置若干桶，因十进制分别有数字：，因此其基为10。设置十个桶，分别用进行标识。排序分两步：位数字相同的数放入同一个桶。

 1. 分配：将右起第位数字相同的数放入同一桶。比如数字为1者(若位数不同则左边补0),将其看成01，放入桶。其余类推
 2. 收集：按的顺序进行收集。 重复1,2从最右位直到最左位共2次。
</code></pre><ul>
<li><p>语言描述</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RADIX 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ArrType[RADIX];</span><br><span class="line">ArrType f, e;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLCell</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *keys; <span class="comment">//关键字</span></span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SLList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SLCell *SList;</span><br><span class="line">    <span class="keyword">int</span> keynum; <span class="comment">//记录当前关键字个数</span></span><br><span class="line">    <span class="keyword">int</span> recnum; <span class="comment">//记录当前静态链表的长度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//分配</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Distrbute</span><span class="params">(SLCell *r, <span class="keyword">int</span> i, ArrType &amp;f, ArrType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; RADIX; j++)</span><br><span class="line">        f[j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = r[<span class="number">0</span>].next; a; a = r[a].next)</span><br><span class="line">    &#123;</span><br><span class="line">        j = r[a].keys[i];</span><br><span class="line">        <span class="keyword">if</span> (!f[j])</span><br><span class="line">            f[j] = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r[e[j]].next = a;</span><br><span class="line">        e[j] = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//收集</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Collect</span><span class="params">(SLCell *r, <span class="keyword">int</span> i, ArrType &amp;f, ArrType &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; !f[j]; j++)</span><br><span class="line">        ;             <span class="comment">//找到第一个非空子集</span></span><br><span class="line">    r[<span class="number">0</span>].next = f[j]; <span class="comment">//r[0].next 指向第一个非空子表中第一个结点</span></span><br><span class="line">    <span class="keyword">int</span> t = e[j];</span><br><span class="line">    <span class="keyword">while</span> (j &lt; RADIX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j++; j &lt; RADIX - <span class="number">1</span> &amp;&amp; !f[j]; j++)</span><br><span class="line">            ; <span class="comment">//找下一个非空子集</span></span><br><span class="line">        <span class="keyword">if</span> (f[j])</span><br><span class="line">        &#123;</span><br><span class="line">            r[t].next = f[j];</span><br><span class="line">            t = e[j]; <span class="comment">//链接两个非空子表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r[t].next = <span class="number">0</span>; <span class="comment">//t指向最后一个非空子表的左后一个结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(SLList &amp;SL)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = SL.keynum; i &gt;= <span class="number">1</span>; i--) <span class="comment">//按最高位优先依次对各关键字进行分配收集</span></span><br><span class="line">    &#123;</span><br><span class="line">        Distrbute(SL.SList, i, f, e); <span class="comment">//第i趟分散</span></span><br><span class="line">        Collect(SL.SList, i, f, e);   <span class="comment">//第i趟收集</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算法分析</p>
<ul>
<li>时间复杂度：设待排序列有个记录，个关键字，每个关键字的取值范围(基)为,进行一趟分配的时间复杂度为，一趟收集的时间复杂度为，总共要进行趟分配和收集，因此链式基数排序的时间复杂度为</li>
<li>空间复杂度：链式基数排序需要个指向队列的辅助空间，且需要个用于静态链表的指针，因此空间复杂度</li>
<li>稳定性：链式基数排序是稳定的排序方法</li>
</ul>
</li>
</ul>
<h3 id="各种内部排序方法的比较"><a href="#各种内部排序方法的比较" class="headerlink" title="各种内部排序方法的比较"></a>各种内部排序方法的比较</h3><ol>
<li>快速排序、堆排序、归并排序的平均时间复杂度最好。</li>
<li>直接插入排序思路明了、算法简单，是一种常用的排序算法。</li>
<li>基数排序的时间复杂度为，因此党待排序列的记录数量很大且关键字长度很小时，其时间性能好。</li>
<li>从空间复杂度上看，大多数排序算法的辅助空间为。但快速排序和归并排序例外，分别为和。而基数排序的空间复杂度和关键字的数量和基有关。</li>
<li>从稳定性上讲，属于稳定性算法的有直接插入排序、简单选择排序、归并排序和基数排序，属于不稳定排序算法的有希尔排序、快速排序和堆排序。</li>
<li>从算法本身的复杂度上看，直接插入排序、简单选择排序比较容易理解，属于简单算法，其时间性能理论上较差；而另一类像希尔排序、快速排序、堆排序和归并排序这样较为复杂的算法，属于改进算法，时间性能理论上较好。</li>
<li>从待排记录个数来看，当越小，采用简单排序算法更为合适，当很大时，采用改进算法更为合适。</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>排序算法</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>平均情况</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>直接插入排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>希尔排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>快速排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>简单选择排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>堆排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>归并排序</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>基数排序</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="算法设计与分析"><a href="#算法设计与分析" class="headerlink" title="算法设计与分析"></a>算法设计与分析</h2><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><blockquote>
<p>对于一个规模为n的问题，若问题比较容易解决(比如规模n较小)，则直接解决，否则将该问题分割为k个规模较小的子问题，这些子问题互相独立且与原问题的形式相同，递归的解决这些子问题，然后将各个子问题的解合并到原问题的解，这就是分治法。</p>
</blockquote>
<ul>
<li><p>基本思想</p>
<p>“分治”就是“分而治之”，即将一个难以解决的大问题分割成若干个规模较小的子问题，以便各个击破，分而治之。</p>
<p>分治法是很多算法的基础，如快速排序、归并排序等排序算法，以及傅里叶变换。</p>
</li>
</ul>
<h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><blockquote>
<p><strong>回溯法</strong>可以系统地搜索问题的所有解，是一个具有系统性和跳跃性的算法。</p>
</blockquote>
<p>如搜索问题和优化问题，它们的解分布在一个<strong>解空间</strong>里，求解这些问题的算法就是一种遍历搜索解空间的系统方法，所以解空间又称为<strong>搜索空间</strong>。</p>
<p>回溯法将搜索空间看成树形结构，一个问题的解对应树中的一个叶子结点。</p>
<ul>
<li>基本思想<ul>
<li>回溯法在问题的解空间中，按照深度优先策略，从根结点出发搜索解空间树。</li>
<li>算法搜索至解空间的任一结点，先判断该结点是否包含问题的解。<ul>
<li>如果不包含，则跳过对该结点为根的子树的搜索，逐层向其祖先结点回溯；</li>
<li>否则，进入该子树，继续进行深度优先策略搜索。</li>
</ul>
</li>
<li>回溯法求问题的所有解时，要回溯到根结点，且根结点所有子树都被搜索完才算结束。</li>
</ul>
</li>
</ul>
<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><blockquote>
<p><strong>贪心算法</strong>是一种通用的算法设计方法，在许多<strong>最优化问题</strong>求解中得到了广泛应用，例如求图的最小生成树的Prim算法和Kruskal算法，单源最短路径的Dijkstra算法，数据压缩的Huffman算法</p>
</blockquote>
<p>贪心算法和动态规划算法一样，常用于求解最优化问题，即量的最大化或最小化。</p>
<ul>
<li><p>基本思想</p>
<p>贪心算法的求解是一个多步决策的过程，每步决策不考虑子问题的计算结果，而是经过少量的计算，根据当前情况做出取舍，这样一步步地构筑解，每一步均建立在局部最优解的基础上，同时又扩大了局部解的规模。</p>
<p>贪心选择：每一个选择都是当前状态下局部的最好选择</p>
</li>
<li><p>贪心算法的性质</p>
<p>贪心算法求解问题，一般具有两个性质：贪心选择性质和最优子结构性质</p>
<ul>
<li><p>贪心选择性质</p>
<p>贪心选择性质是指所求问题的整体最优解可以通过一系列的局部最优的选择(贪心选择)来达到，它采用自顶向下的方式将所求问题简化为规模更小的子问题。</p>
</li>
<li><p>最优子结构性质</p>
<p>当一个问题的最优解包括其子问题的最优解时，称此问题具有最优子结构性质</p>
</li>
</ul>
</li>
</ul>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><blockquote>
<p>动态规划：是一种将问题实例分解为更小的、相似的子问题，并存储子问题的解而避免重复计算的子问题，以解决最优化问题的算法策略。</p>
</blockquote>
<ul>
<li><p>基本思想</p>
<p>与分治法类似，将带求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适用于动态规划求解的问题，经分割得到的子问题往往不是互相独立的。若用分治法解决这些问题，分割的子问题数目太多，以致最后解决原问题需要耗费的指数时间。</p>
<p>在使用分治法求解时，有些子问题被重复计算多次。若保存已解决的子问题的答案，在需要时找出已求出的答案，可以避免大量重复计算，从而得到多项式时间的算法，这就是动态规划的基本思想。</p>
</li>
<li><p>设计步骤</p>
<ol>
<li>找出最优解的性质，并刻画其结构特征</li>
<li>递归的定义最优值</li>
<li>自底向上的方式计算得出最优值</li>
<li>根据计算最优值时得到的信息构造最优解</li>
</ol>
<p>步骤1-3是动态规划算法的基本步骤。</p>
<p>若只需求出最优值，则步骤4可以省略。 若需求出问题的最优解，则必须执行步骤4，此时，在步骤3中计算最优值，通常需要记录更多的信息，以便在步骤4中，能够根据记录的信息快速构造出最优解。</p>
</li>
</ul>
<p>动态规划算法解决的问题需要一定条件：最优化原理(最优子结构性质)和子问题的重叠性。</p>
<ul>
<li><p>条件</p>
<ul>
<li><p>最优化原理(最优子结构性质)</p>
<p>一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理称起具有最优子结构性质。</p>
</li>
<li><p>子问题的重叠性</p>
<p>对于重复出现的子问题，只在第一次遇到时加以求解，并把答案保存起来，让以后再遇到时直接引用，不必重新求解。</p>
</li>
</ul>
</li>
</ul>
<h3 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h3><blockquote>
<p><strong>分支限界法</strong>类似回溯法，都是在解空间树上搜索问题的解，也可以看做是回溯法的改进。回溯法是在整个状态空间树中搜索解，并用约束条件判断搜索过程，一旦发生不可能产生问题的不分解，就终止对相应子树的搜索，从而避免不必要的工作。</p>
</blockquote>
<p>分支限界法和回溯在两个方法存在差异：控制条件和搜索方式</p>
<ul>
<li><p>控制条件</p>
<p>回溯法一般使用约束条件产生部分解。若满足约束条件，则继续扩大解；否则丢弃，重新搜索。 分支限界法中，除了使用约束函数外，还使用更有效的评判函数——目标函数控制搜索进行，从而能够尽快得到最优解。</p>
</li>
<li><p>搜索方式</p>
<p>回溯法中的搜索一般是以深度优先的方式进行，而分支限界法中一般以广度优先方式进行搜索。</p>
</li>
<li><p>基本思想</p>
<p>略</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
  </entry>
  <entry>
    <title>Ruby-Tutorial</title>
    <url>/2021/01/20/Ruby-Tutorial/</url>
    <content><![CDATA[<h1 id="Ruby-Tutorial"><a href="#Ruby-Tutorial" class="headerlink" title="Ruby Tutorial"></a>Ruby Tutorial</h1><a id="more"></a>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/ruby</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This is a comment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">=begin</span></span><br><span class="line"><span class="comment">This is a multi-line comment.</span></span><br><span class="line"><span class="comment">The beginning line must start with "=begin"</span></span><br><span class="line"><span class="comment">and the ending line must start with "=end".</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">You can do this, or start each line in</span></span><br><span class="line"><span class="comment">a multi-line comment with the # character.</span></span><br><span class="line"><span class="comment">=end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In Ruby, (almost) everything is an object.</span></span><br><span class="line"><span class="comment"># This includes numbers...</span></span><br><span class="line">puts <span class="number">3</span><span class="class">.<span class="keyword">class</span> <span class="comment">#=&gt; Integer</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...and strings...</span></span><br><span class="line">puts <span class="string">"Hello"</span><span class="class">.<span class="keyword">class</span> <span class="comment">#=&gt; String</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...and even methods!</span></span><br><span class="line">puts <span class="string">"Hello"</span>.method(<span class="symbol">:class</span>)<span class="class">.<span class="keyword">class</span> <span class="comment">#=&gt; Method</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Some basic arithmetic</span></span><br><span class="line">puts <span class="number">1</span> + <span class="number">1</span> <span class="comment">#=&gt; 2</span></span><br><span class="line">puts <span class="number">8</span> - <span class="number">1</span> <span class="comment">#=&gt; 7</span></span><br><span class="line">puts <span class="number">10</span> * <span class="number">2</span> <span class="comment">#=&gt; 20</span></span><br><span class="line">puts <span class="number">35</span> / <span class="number">5</span> <span class="comment">#=&gt; 7</span></span><br><span class="line">puts <span class="number">2</span> ** <span class="number">5</span> <span class="comment">#=&gt; 32</span></span><br><span class="line">puts <span class="number">5</span> % <span class="number">3</span> <span class="comment">#=&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bitwise operators</span></span><br><span class="line">puts <span class="number">3</span> &amp; <span class="number">5</span> <span class="comment">#=&gt; 1</span></span><br><span class="line">puts <span class="number">3</span> <span class="params">| 5 #=&gt; 7</span></span><br><span class="line"><span class="params">puts 3 ^ 5 #=&gt; 6</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Arithmetic is just syntactic sugar</span></span><br><span class="line"><span class="params"># <span class="keyword">for</span> calling a method on an object</span></span><br><span class="line"><span class="params">puts 1.+(3) #=&gt; 4</span></span><br><span class="line"><span class="params">puts 10.* 5 #=&gt; 50</span></span><br><span class="line"><span class="params">puts 100.methods.<span class="keyword">include</span>?(:/) #=&gt; <span class="literal">true</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Special values are objects</span></span><br><span class="line"><span class="params">puts <span class="literal">nil</span> # equivalent to null <span class="keyword">in</span> other languages</span></span><br><span class="line"><span class="params">puts <span class="literal">true</span> # truth</span></span><br><span class="line"><span class="params">puts <span class="literal">false</span> # falsehood</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">puts <span class="literal">nil</span>.<span class="keyword">class</span> #=&gt; NilClass</span></span><br><span class="line"><span class="params">puts <span class="literal">true</span>.<span class="keyword">class</span> #=&gt; TrueClass</span></span><br><span class="line"><span class="params">puts <span class="literal">false</span>.<span class="keyword">class</span> #=&gt; FalseClass</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Equality</span></span><br><span class="line"><span class="params">puts 1 == 1 #=&gt; <span class="literal">true</span></span></span><br><span class="line"><span class="params">puts 2 == 1 #=&gt; <span class="literal">false</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Inequality</span></span><br><span class="line"><span class="params">puts 1 != 1 #=&gt; <span class="literal">false</span></span></span><br><span class="line"><span class="params">puts 2 != 1 #=&gt; <span class="literal">true</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Apart from <span class="literal">false</span> itself, <span class="literal">nil</span> is the only other 'falsey' value</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">puts !!<span class="literal">nil</span>   #=&gt; <span class="literal">false</span></span></span><br><span class="line"><span class="params">puts !!<span class="literal">false</span> #=&gt; <span class="literal">false</span></span></span><br><span class="line"><span class="params">puts !!0     #=&gt; <span class="literal">true</span></span></span><br><span class="line"><span class="params">puts !!""    #=&gt; <span class="literal">true</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># More comparisons</span></span><br><span class="line"><span class="params">puts 1 &lt; 10 #=&gt; <span class="literal">true</span></span></span><br><span class="line"><span class="params">puts 1 &gt; 10 #=&gt; <span class="literal">false</span></span></span><br><span class="line"><span class="params">puts 2 &lt;= 2 #=&gt; <span class="literal">true</span></span></span><br><span class="line"><span class="params">puts 2 &gt;= 2 #=&gt; <span class="literal">true</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Combined comparison operator (returns `1` <span class="keyword">when</span> the first argument is greater,</span></span><br><span class="line"><span class="params"># `-1` <span class="keyword">when</span> the second argument is greater, <span class="keyword">and</span> `0` otherwise)</span></span><br><span class="line"><span class="params">puts 1 &lt;=&gt; 10 #=&gt; -1 (1 &lt; 10)</span></span><br><span class="line"><span class="params">puts 10 &lt;=&gt; 1 #=&gt; 1 (10 &gt; 1)</span></span><br><span class="line"><span class="params">puts 1 &lt;=&gt; 1 #=&gt; 0 (1 == 1)</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Logical operators</span></span><br><span class="line"><span class="params">puts <span class="literal">true</span> &amp;&amp; <span class="literal">false</span> #=&gt; <span class="literal">false</span></span></span><br><span class="line"><span class="params">puts <span class="literal">true</span> |</span><span class="params">| <span class="literal">false</span> #=&gt; <span class="literal">true</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># There are alternate versions of the logical operators with much lower</span></span><br><span class="line"><span class="params"># precedence. These are meant to be used as flow-control constructs to chain</span></span><br><span class="line"><span class="params"># statements together <span class="keyword">until</span> one of them returns <span class="literal">true</span> <span class="keyword">or</span> <span class="literal">false</span>.</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># `do_something_else` only called <span class="keyword">if</span> `do_something` succeeds.</span></span><br><span class="line"><span class="params">def do_something()</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">def do_something_else()</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">do_something() <span class="keyword">and</span> do_something_else()</span></span><br><span class="line"><span class="params"># `log_error` only called <span class="keyword">if</span> `do_something` fails.</span></span><br><span class="line"><span class="params">def log_error()</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">do_something() <span class="keyword">or</span> log_error()</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># String interpolation</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">placeholder = 'use string interpolation'</span></span><br><span class="line"><span class="params">puts "I can #&#123;placeholder&#125; <span class="keyword">when</span> using double quoted strings"</span></span><br><span class="line"><span class="params">#=&gt; "I can use string interpolation <span class="keyword">when</span> using double quoted strings"</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># You can combine strings using `+`, but <span class="keyword">not</span> with other types</span></span><br><span class="line"><span class="params">puts 'hello ' + 'world'  #=&gt; "hello world"</span></span><br><span class="line"><span class="params"># 'hello ' + 3 #=&gt; TypeError: can't convert Fixnum into String</span></span><br><span class="line"><span class="params">puts 'hello ' + 3.to_s #=&gt; "hello 3"</span></span><br><span class="line"><span class="params">puts  "hello #&#123;3&#125;" #=&gt; "hello 3"</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># ...<span class="keyword">or</span> combine strings <span class="keyword">and</span> operators</span></span><br><span class="line"><span class="params">puts 'hello ' * 3 #=&gt; "hello hello hello "</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># ...<span class="keyword">or</span> append to string</span></span><br><span class="line"><span class="params">puts 'hello' &lt;&lt; ' world' #=&gt; "hello world"</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># You can print to the output with a newline at the <span class="keyword">end</span></span></span><br><span class="line"><span class="params">puts "I'm printing!"</span></span><br><span class="line"><span class="params">#=&gt; I'm printing!</span></span><br><span class="line"><span class="params">#=&gt; <span class="literal">nil</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># ...<span class="keyword">or</span> print to the output without a newline</span></span><br><span class="line"><span class="params">print "I'm printing!"</span></span><br><span class="line"><span class="params">#=&gt; "I'm printing!" =&gt; <span class="literal">nil</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Variables</span></span><br><span class="line"><span class="params">x = 25 #=&gt; 25</span></span><br><span class="line"><span class="params">puts x #=&gt; 25</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Note that assignment returns the value assigned.</span></span><br><span class="line"><span class="params"># This means you can <span class="keyword">do</span> multiple assignment.</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">x = y = 10 #=&gt; 10</span></span><br><span class="line"><span class="params">puts x #=&gt; 10</span></span><br><span class="line"><span class="params">puts y #=&gt; 10</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># By convention, use snake_case <span class="keyword">for</span> variable names.</span></span><br><span class="line"><span class="params">snake_case = <span class="literal">true</span></span></span><br><span class="line"><span class="params">puts snake_case</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># By convention, use snake_case <span class="keyword">for</span> variable names.</span></span><br><span class="line"><span class="params">snake_case = <span class="literal">true</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Use descriptive variable names</span></span><br><span class="line"><span class="params">path_to_project_root = '/good/name/'</span></span><br><span class="line"><span class="params">m = '/bad/name/'</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Symbols are immutable, reusable constants represented internally by an</span></span><br><span class="line"><span class="params"># integer value. They're often used instead of strings to efficiently convey</span></span><br><span class="line"><span class="params"># specific, meaningful values.</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">:pending.<span class="keyword">class</span> #=&gt; Symbol</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">status = :pending</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">status == :pending #=&gt; <span class="literal">true</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">status == 'pending' #=&gt; <span class="literal">false</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">status == :approved #=&gt; <span class="literal">false</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Strings can be converted into symbols <span class="keyword">and</span> vice versa.</span></span><br><span class="line"><span class="params">status.to_s #=&gt; "pending"</span></span><br><span class="line"><span class="params">"argon".to_sym #=&gt; :argon</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Arrays</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># This is an array.</span></span><br><span class="line"><span class="params">array = [1, 2, 3, 4, 5] #=&gt; [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Arrays can contain different types of items.</span></span><br><span class="line"><span class="params">[1, 'hello', <span class="literal">false</span>] #=&gt; [1, "hello", <span class="literal">false</span>]</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># You might prefer %w instead of quotes</span></span><br><span class="line"><span class="params">%w[foo bar baz] #=&gt; ["foo", "bar", "baz"]</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Arrays can be indexed.</span></span><br><span class="line"><span class="params"># From the front...</span></span><br><span class="line"><span class="params">array[0] #=&gt; 1</span></span><br><span class="line"><span class="params">array.first #=&gt; 1</span></span><br><span class="line"><span class="params">array[12] #=&gt; <span class="literal">nil</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># ...<span class="keyword">or</span> from the back...</span></span><br><span class="line"><span class="params">array[-1] #=&gt; 5</span></span><br><span class="line"><span class="params">array.last #=&gt; 5</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># ...<span class="keyword">or</span> with a start index <span class="keyword">and</span> length...</span></span><br><span class="line"><span class="params">array[2, 3] #=&gt; [3, 4, 5]</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># ...<span class="keyword">or</span> with a range...</span></span><br><span class="line"><span class="params">array[1..3] #=&gt; [2, 3, 4]</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># You can reverse an Array.</span></span><br><span class="line"><span class="params"># Return a new array with reversed values</span></span><br><span class="line"><span class="params">[1,2,3].reverse #=&gt; [3,2,1]</span></span><br><span class="line"><span class="params"># Reverse an array <span class="keyword">in</span> place to update variable with reversed values</span></span><br><span class="line"><span class="params">a = [1,2,3]</span></span><br><span class="line"><span class="params">a.reverse! #=&gt; a==[3,2,1] because of the bang ('!') call to reverse</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Like arithmetic, [var] access is just syntactic sugar</span></span><br><span class="line"><span class="params"># <span class="keyword">for</span> calling a method '[]' on an object.</span></span><br><span class="line"><span class="params">array.[] 0 #=&gt; 1</span></span><br><span class="line"><span class="params">array.[] 12 #=&gt; <span class="literal">nil</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># You can add to an array...</span></span><br><span class="line"><span class="params">array &lt;&lt; 6 #=&gt; [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="params"># Or like this</span></span><br><span class="line"><span class="params">array.push(6) #=&gt; [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># ...<span class="keyword">and</span> check <span class="keyword">if</span> an item exists <span class="keyword">in</span> an array</span></span><br><span class="line"><span class="params">array.<span class="keyword">include</span>?(1) #=&gt; <span class="literal">true</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Hashes are Ruby's primary dictionary with key/value pairs.</span></span><br><span class="line"><span class="params"># Hashes are denoted with curly braces.</span></span><br><span class="line"><span class="params">hash = &#123; 'color' =&gt; 'green', 'number' =&gt; 5 &#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">hash.keys #=&gt; ['color', 'number']</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Hashes can be quickly looked up by key.</span></span><br><span class="line"><span class="params">hash['color'] #=&gt; "green"</span></span><br><span class="line"><span class="params">hash['number'] #=&gt; 5</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Asking a hash <span class="keyword">for</span> a key that doesn't exist returns <span class="literal">nil</span>.</span></span><br><span class="line"><span class="params">hash['nothing here'] #=&gt; <span class="literal">nil</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># When using symbols <span class="keyword">for</span> keys <span class="keyword">in</span> a hash, you can use an alternate syntax.</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">hash = &#123; :defcon =&gt; 3, :action =&gt; <span class="literal">true</span> &#125;</span></span><br><span class="line"><span class="params">hash.keys #=&gt; [:defcon, :action]</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">hash = &#123; defcon: 3, action: <span class="literal">true</span> &#125;</span></span><br><span class="line"><span class="params">hash.keys #=&gt; [:defcon, :action]</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Check existence of keys <span class="keyword">and</span> values <span class="keyword">in</span> hash</span></span><br><span class="line"><span class="params">hash.key?(:defcon) #=&gt; <span class="literal">true</span></span></span><br><span class="line"><span class="params">hash.value?(3) #=&gt; <span class="literal">true</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Tip: Both Arrays <span class="keyword">and</span> Hashes are Enumerable!</span></span><br><span class="line"><span class="params"># They share a lot of useful methods such as each, map, count, <span class="keyword">and</span> more.</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Control structures</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Conditionals</span></span><br><span class="line"><span class="params"><span class="keyword">if</span> <span class="literal">true</span></span></span><br><span class="line"><span class="params">  '<span class="keyword">if</span> statement'</span></span><br><span class="line"><span class="params"><span class="keyword">elsif</span> <span class="literal">false</span></span></span><br><span class="line"><span class="params">  '<span class="keyword">else</span> <span class="keyword">if</span>, optional'</span></span><br><span class="line"><span class="params"><span class="keyword">else</span></span></span><br><span class="line"><span class="params">  '<span class="keyword">else</span>, also optional'</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># If a condition controls invocation of a single statement rather than a block of code</span></span><br><span class="line"><span class="params"># you can use postfix-<span class="keyword">if</span> notation</span></span><br><span class="line"><span class="params">warnings = ['Patronimic is missing', 'Address too short']</span></span><br><span class="line"><span class="params">puts("Some warnings occurred:\n" + warnings.join("\n"))  <span class="keyword">if</span> !warnings.empty?</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Rephrase condition <span class="keyword">if</span> `<span class="keyword">unless</span>` sounds better than `<span class="keyword">if</span>`</span></span><br><span class="line"><span class="params">puts("Some warnings occurred:\n" + warnings.join("\n"))  <span class="keyword">unless</span> warnings.empty?</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Loops</span></span><br><span class="line"><span class="params"># In Ruby, traditional `<span class="keyword">for</span>` loops aren't very common. Instead, these</span></span><br><span class="line"><span class="params"># basic loops are implemented using enumerable, which hinges on `each`.</span></span><br><span class="line"><span class="params">(1..5).each <span class="keyword">do</span> |</span>counter<span class="params">|</span></span><br><span class="line"><span class="params">  puts "iteration #&#123;counter&#125;"</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Which is roughly equivalent to the following, which is unusual to see <span class="keyword">in</span> Ruby.</span></span><br><span class="line"><span class="params"><span class="keyword">for</span> counter <span class="keyword">in</span> 1..5</span></span><br><span class="line"><span class="params">  puts "iteration #&#123;counter&#125;"</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># The `<span class="keyword">do</span> |</span>variable<span class="params">| ... <span class="keyword">end</span>` construct above is called a 'block'. Blocks are similar</span></span><br><span class="line"><span class="params"># to lambdas, anonymous functions <span class="keyword">or</span> closures <span class="keyword">in</span> other programming languages. They can</span></span><br><span class="line"><span class="params"># be passed around as objects, called, <span class="keyword">or</span> attached as methods.</span></span><br><span class="line"><span class="params">#</span></span><br><span class="line"><span class="params"># The 'each' method of a range runs the block once <span class="keyword">for</span> each element of the range.</span></span><br><span class="line"><span class="params"># The block is passed a counter as a parameter.</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># You can also surround blocks <span class="keyword">in</span> curly brackets.</span></span><br><span class="line"><span class="params">(1..5).each &#123; |</span>counter<span class="params">| puts "iteration #&#123;counter&#125;" &#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># The contents of data structures can also be iterated using each.</span></span><br><span class="line"><span class="params">array.each <span class="keyword">do</span> |</span>element<span class="params">|</span></span><br><span class="line"><span class="params">  puts "#&#123;element&#125; is part of the array"</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params">hash.each <span class="keyword">do</span> |</span>key, value<span class="params">|</span></span><br><span class="line"><span class="params">  puts "#&#123;key&#125; is #&#123;value&#125;"</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># If you still need an index you can use 'each_with_index' <span class="keyword">and</span> define an index</span></span><br><span class="line"><span class="params"># variable.</span></span><br><span class="line"><span class="params">array.each_with_index <span class="keyword">do</span> |</span>element, index<span class="params">|</span></span><br><span class="line"><span class="params">  puts "#&#123;element&#125; is number #&#123;index&#125; <span class="keyword">in</span> the array"</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">counter = 1</span></span><br><span class="line"><span class="params"><span class="keyword">while</span> counter &lt;= 5 <span class="keyword">do</span></span></span><br><span class="line"><span class="params">  puts "iteration #&#123;counter&#125;"</span></span><br><span class="line"><span class="params">  counter += 1</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params">#=&gt; iteration 1</span></span><br><span class="line"><span class="params">#=&gt; iteration 2</span></span><br><span class="line"><span class="params">#=&gt; iteration 3</span></span><br><span class="line"><span class="params">#=&gt; iteration 4</span></span><br><span class="line"><span class="params">#=&gt; iteration 5</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># There are a bunch of other helpful looping functions <span class="keyword">in</span> Ruby.</span></span><br><span class="line"><span class="params"># For example: 'map', 'reduce', 'inject', the list goes on.</span></span><br><span class="line"><span class="params"># Map, <span class="keyword">for</span> instance, takes the array it's looping over, does something</span></span><br><span class="line"><span class="params"># to it as <span class="keyword">defined</span> <span class="keyword">in</span> your block, <span class="keyword">and</span> returns an entirely new array.</span></span><br><span class="line"><span class="params">array = [1,2,3,4,5]</span></span><br><span class="line"><span class="params">doubled = array.map <span class="keyword">do</span> |</span>element<span class="params">|</span></span><br><span class="line"><span class="params">  element * 2</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params">puts doubled</span></span><br><span class="line"><span class="params">#=&gt; [2,4,6,8,10]</span></span><br><span class="line"><span class="params">puts array</span></span><br><span class="line"><span class="params">#=&gt; [1,2,3,4,5]</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># another useful syntax is .map(&amp;:method)</span></span><br><span class="line"><span class="params">a = ["FOO", "BAR", "BAZ"]</span></span><br><span class="line"><span class="params">a.map &#123; |</span>s<span class="params">| s.downcase &#125; #=&gt; ["foo", "bar", "baz"]</span></span><br><span class="line"><span class="params">a.map(&amp;:downcase) #=&gt; ["foo", "bar", "baz"]</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Case construct</span></span><br><span class="line"><span class="params">grade = 'B'</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">case</span> grade</span></span><br><span class="line"><span class="params"><span class="keyword">when</span> 'A'</span></span><br><span class="line"><span class="params">  puts 'Way to go kiddo'</span></span><br><span class="line"><span class="params"><span class="keyword">when</span> 'B'</span></span><br><span class="line"><span class="params">  puts 'Better luck <span class="keyword">next</span> time'</span></span><br><span class="line"><span class="params"><span class="keyword">when</span> 'C'</span></span><br><span class="line"><span class="params">  puts 'You can <span class="keyword">do</span> better'</span></span><br><span class="line"><span class="params"><span class="keyword">when</span> 'D'</span></span><br><span class="line"><span class="params">  puts 'Scraping through'</span></span><br><span class="line"><span class="params"><span class="keyword">when</span> 'F'</span></span><br><span class="line"><span class="params">  puts 'You failed!'</span></span><br><span class="line"><span class="params"><span class="keyword">else</span></span></span><br><span class="line"><span class="params">  puts 'Alternative grading system, eh?'</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params">#=&gt; "Better luck <span class="keyword">next</span> time"</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Cases can also use ranges</span></span><br><span class="line"><span class="params">grade = 82</span></span><br><span class="line"><span class="params"><span class="keyword">case</span> grade</span></span><br><span class="line"><span class="params"><span class="keyword">when</span> 90..100</span></span><br><span class="line"><span class="params">  puts 'Hooray!'</span></span><br><span class="line"><span class="params"><span class="keyword">when</span> 80...90</span></span><br><span class="line"><span class="params">  puts 'OK job'</span></span><br><span class="line"><span class="params"><span class="keyword">else</span></span></span><br><span class="line"><span class="params">  puts 'You failed!'</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params">#=&gt; "OK job"</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Exception handling</span></span><br><span class="line"><span class="params"><span class="keyword">begin</span></span></span><br><span class="line"><span class="params">  # Code here that might raise an exception</span></span><br><span class="line"><span class="params">  raise NoMemoryError, 'You ran out of memory.'</span></span><br><span class="line"><span class="params"><span class="keyword">rescue</span> NoMemoryError =&gt; exception_variable</span></span><br><span class="line"><span class="params">  puts 'NoMemoryError was raised', exception_variable</span></span><br><span class="line"><span class="params"><span class="keyword">rescue</span> RuntimeError =&gt; other_exception_variable</span></span><br><span class="line"><span class="params">  puts 'RuntimeError was raised now'</span></span><br><span class="line"><span class="params"><span class="keyword">else</span></span></span><br><span class="line"><span class="params">  puts 'This runs <span class="keyword">if</span> no exceptions were thrown at all'</span></span><br><span class="line"><span class="params"><span class="keyword">ensure</span></span></span><br><span class="line"><span class="params">  puts 'This code always runs no matter what'</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Methods</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">def double(x)</span></span><br><span class="line"><span class="params">  x * 2</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Methods (<span class="keyword">and</span> blocks) implicitly <span class="keyword">return</span> the value of the last statement.</span></span><br><span class="line"><span class="params">double(2) #=&gt; 4</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Parentheses are optional where the interpretation is unambiguous.</span></span><br><span class="line"><span class="params">double 3 #=&gt; 6</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">double double 3 #=&gt; 12</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">def sum(x, y)</span></span><br><span class="line"><span class="params">  x + y</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Method arguments are separated by a comma.</span></span><br><span class="line"><span class="params">sum 3, 4 #=&gt; 7</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">sum sum(3, 4), 5 #=&gt; 12</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># <span class="keyword">yield</span></span></span><br><span class="line"><span class="params"># All methods have an implicit, optional block parameter.</span></span><br><span class="line"><span class="params"># It can be called with the '<span class="keyword">yield</span>' keyword.</span></span><br><span class="line"><span class="params">def surround</span></span><br><span class="line"><span class="params">  puts '&#123;'</span></span><br><span class="line"><span class="params">  <span class="keyword">yield</span></span></span><br><span class="line"><span class="params">  puts '&#125;'</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">surround &#123; puts 'hello world' &#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">#=&gt; &#123;</span></span><br><span class="line"><span class="params">#=&gt; hello world</span></span><br><span class="line"><span class="params">#=&gt; &#125;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Blocks can be converted into a 'proc' object, which wraps the block</span></span><br><span class="line"><span class="params"># <span class="keyword">and</span> allows it to be passed to another method, bound to a different scope,</span></span><br><span class="line"><span class="params"># <span class="keyword">or</span> manipulated otherwise. This is most common <span class="keyword">in</span> method parameter lists,</span></span><br><span class="line"><span class="params"># where you frequently see a trailing '&amp;block' parameter that will accept</span></span><br><span class="line"><span class="params"># the block, <span class="keyword">if</span> one is given, <span class="keyword">and</span> convert it to a 'Proc'. The naming here is</span></span><br><span class="line"><span class="params"># convention; it would work just as well with '&amp;pineapple'.</span></span><br><span class="line"><span class="params">def guests(&amp;block)</span></span><br><span class="line"><span class="params">  block.<span class="keyword">class</span> #=&gt; Proc</span></span><br><span class="line"><span class="params">  block.call(4)</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># The 'call' method on the Proc is similar to calling '<span class="keyword">yield</span>' <span class="keyword">when</span> a block is</span></span><br><span class="line"><span class="params"># present. The arguments passed to 'call' will be forwarded to the block as arguments.</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">guests &#123; |</span>n<span class="params">| "You have #&#123;n&#125; guests." &#125;</span></span><br><span class="line"><span class="params"># =&gt; "You have 4 guests."</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># You can pass a list of arguments, which will be converted into an array.</span></span><br><span class="line"><span class="params"># That's what splat operator ("*") is <span class="keyword">for</span>.</span></span><br><span class="line"><span class="params">def guests(*array)</span></span><br><span class="line"><span class="params">  array.each &#123; |</span>guest<span class="params">| puts guest &#125;</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># There is also the shorthand block syntax. It's most useful <span class="keyword">when</span> you need</span></span><br><span class="line"><span class="params"># to call a simple method on all array items.</span></span><br><span class="line"><span class="params">upcased = ['Watch', 'these', 'words', 'get', 'upcased'].map(&amp;:upcase)</span></span><br><span class="line"><span class="params">puts upcased</span></span><br><span class="line"><span class="params">#=&gt; ["WATCH", "THESE", "WORDS", "GET", "UPCASED"]</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">sum = [1, 2, 3, 4, 5].reduce(&amp;:+)</span></span><br><span class="line"><span class="params">puts sum</span></span><br><span class="line"><span class="params">#=&gt; 15</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Destructuring</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Ruby will automatically destructure arrays on assignment to multiple variables.</span></span><br><span class="line"><span class="params">a, b, c = [1, 2, 3]</span></span><br><span class="line"><span class="params">a #=&gt; 1</span></span><br><span class="line"><span class="params">b #=&gt; 2</span></span><br><span class="line"><span class="params">c #=&gt; 3</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># In some cases, you will want to use the splat operator: `*` to prompt destructuring</span></span><br><span class="line"><span class="params"># of an array into a list.</span></span><br><span class="line"><span class="params">ranked_competitors = ["John", "Sally", "Dingus", "Moe", "Marcy"]</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">def best(first, second, third)</span></span><br><span class="line"><span class="params">  puts "Winners are #&#123;first&#125;, #&#123;second&#125;, <span class="keyword">and</span> #&#123;third&#125;."</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">best *ranked_competitors.first(3) #=&gt; Winners are John, Sally, <span class="keyword">and</span> Dingus.</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># The splat operator can also be used <span class="keyword">in</span> parameters.</span></span><br><span class="line"><span class="params">def best(first, second, third, *others)</span></span><br><span class="line"><span class="params">  puts "Winners are #&#123;first&#125;, #&#123;second&#125;, <span class="keyword">and</span> #&#123;third&#125;."</span></span><br><span class="line"><span class="params">  puts "There were #&#123;others.count&#125; other participants."</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">best *ranked_competitors</span></span><br><span class="line"><span class="params">#=&gt; Winners are John, Sally, <span class="keyword">and</span> Dingus.</span></span><br><span class="line"><span class="params">#=&gt; There were 2 other participants.</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># By convention, all methods that <span class="keyword">return</span> booleans <span class="keyword">end</span> with a question mark.</span></span><br><span class="line"><span class="params">5.even? #=&gt; <span class="literal">false</span></span></span><br><span class="line"><span class="params">5.odd? #=&gt; <span class="literal">true</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># By convention, <span class="keyword">if</span> a method name ends with an exclamation mark, it does something destructive</span></span><br><span class="line"><span class="params"># like mutate the receiver. Many methods have a ! version to make a change, <span class="keyword">and</span></span></span><br><span class="line"><span class="params"># a non-! version to just <span class="keyword">return</span> a new changed version.</span></span><br><span class="line"><span class="params">company_name = "Dunder Mifflin"</span></span><br><span class="line"><span class="params">company_name.upcase #=&gt; "DUNDER MIFFLIN"</span></span><br><span class="line"><span class="params">company_name #=&gt; "Dunder Mifflin"</span></span><br><span class="line"><span class="params"># We're mutating company_name this time.</span></span><br><span class="line"><span class="params">company_name.upcase! #=&gt; "DUNDER MIFFLIN"</span></span><br><span class="line"><span class="params">company_name #=&gt; "DUNDER MIFFLIN"</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Classes</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># You can define a <span class="keyword">class</span> with the '<span class="keyword">class</span>' keyword.</span></span><br><span class="line"><span class="params"><span class="keyword">class</span> Human</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  # A <span class="keyword">class</span> variable. It is shared by all instances of this <span class="keyword">class</span>.</span></span><br><span class="line"><span class="params">  @@species = 'H. sapiens'</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  # Basic initializer</span></span><br><span class="line"><span class="params">  def initialize(name, age = 0)</span></span><br><span class="line"><span class="params">    # Assign the argument to the 'name' instance variable <span class="keyword">for</span> the instance.</span></span><br><span class="line"><span class="params">    @name = name</span></span><br><span class="line"><span class="params">    # If no age given, we will fall back to the default <span class="keyword">in</span> the arguments list.</span></span><br><span class="line"><span class="params">    @age = age</span></span><br><span class="line"><span class="params">  <span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  # Basic setter method</span></span><br><span class="line"><span class="params">  def name=(name)</span></span><br><span class="line"><span class="params">    @name = name</span></span><br><span class="line"><span class="params">  <span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  # Basic getter method</span></span><br><span class="line"><span class="params">  def name</span></span><br><span class="line"><span class="params">    @name</span></span><br><span class="line"><span class="params">  <span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  # The above functionality can be encapsulated using the <span class="keyword">attr_accessor</span> method as follows.</span></span><br><span class="line"><span class="params">  <span class="keyword">attr_accessor</span> :name</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  # Getter/setter methods can also be created individually like this.</span></span><br><span class="line"><span class="params">  <span class="keyword">attr_reader</span> :name</span></span><br><span class="line"><span class="params">  <span class="keyword">attr_writer</span> :name</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  # A <span class="keyword">class</span> method uses <span class="keyword">self</span> to distinguish from instance methods.</span></span><br><span class="line"><span class="params">  # It can only be called on the <span class="keyword">class</span>, <span class="keyword">not</span> an instance.</span></span><br><span class="line"><span class="params">  def <span class="keyword">self</span>.say(msg)</span></span><br><span class="line"><span class="params">    puts msg</span></span><br><span class="line"><span class="params">  <span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  def species</span></span><br><span class="line"><span class="params">    @@species</span></span><br><span class="line"><span class="params">  <span class="keyword">end</span></span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Instantiating of a <span class="keyword">class</span></span></span><br><span class="line"><span class="params">jim = Human.new('Jim Halpert')</span></span><br><span class="line"><span class="params">dwight = Human.new('Dwight K. Schrute')</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># You can call the methods of the generated object.</span></span><br><span class="line"><span class="params">jim.species #=&gt; "H. sapiens"</span></span><br><span class="line"><span class="params">jim.name #=&gt; "Jim Halpert"</span></span><br><span class="line"><span class="params">jim.name = "Jim Halpert II" #=&gt; "Jim Halpert II"</span></span><br><span class="line"><span class="params">jim.name #=&gt; "Jim Halpert II"</span></span><br><span class="line"><span class="params">dwight.species #=&gt; "H. sapiens"</span></span><br><span class="line"><span class="params">dwight.name #=&gt; "Dwight K. Schrute"</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Calling of a <span class="keyword">class</span> method</span></span><br><span class="line"><span class="params">Human.say('Hi') #=&gt; "Hi"</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Variable's scopes are <span class="keyword">defined</span> by the way we name them.</span></span><br><span class="line"><span class="params"># Variables that start with $ have global scope.</span></span><br><span class="line"><span class="params">$var = "I'm a global var"</span></span><br><span class="line"><span class="params"><span class="keyword">defined</span>? $var #=&gt; "global-variable"</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Variables that start with @ have instance scope.</span></span><br><span class="line"><span class="params">@var = "I'm an instance var"</span></span><br><span class="line"><span class="params"><span class="keyword">defined</span>? @var #=&gt; "instance-variable"</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Variables that start with @@ have <span class="keyword">class</span> scope.</span></span><br><span class="line"><span class="params">@@var = "I'm a <span class="keyword">class</span> var"</span></span><br><span class="line"><span class="params"><span class="keyword">defined</span>? @@var #=&gt; "<span class="keyword">class</span> variable"</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Variables that start with a capital letter are constants.</span></span><br><span class="line"><span class="params">Var = "I'm a constant"</span></span><br><span class="line"><span class="params"><span class="keyword">defined</span>? Var #=&gt; "constant"</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Class is also an object <span class="keyword">in</span> ruby. So a <span class="keyword">class</span> can have instance variables.</span></span><br><span class="line"><span class="params"># A <span class="keyword">class</span> variable is shared among the <span class="keyword">class</span> <span class="keyword">and</span> all of its descendants.</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Base <span class="keyword">class</span></span></span><br><span class="line"><span class="params"><span class="keyword">class</span> Human</span></span><br><span class="line"><span class="params">  @@foo = 0</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  def <span class="keyword">self</span>.foo</span></span><br><span class="line"><span class="params">    @@foo</span></span><br><span class="line"><span class="params">  <span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  def <span class="keyword">self</span>.foo=(value)</span></span><br><span class="line"><span class="params">    @@foo = value</span></span><br><span class="line"><span class="params">  <span class="keyword">end</span></span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Derived <span class="keyword">class</span></span></span><br><span class="line"><span class="params"><span class="keyword">class</span> Worker &lt; Human</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">Human.foo #=&gt; 0</span></span><br><span class="line"><span class="params">Worker.foo #=&gt; 0</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">Human.foo = 2</span></span><br><span class="line"><span class="params">Worker.foo #=&gt; 2</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># A <span class="keyword">class</span> instance variable is <span class="keyword">not</span> shared by the <span class="keyword">class</span>'s descendants.</span></span><br><span class="line"><span class="params"><span class="keyword">class</span> Human</span></span><br><span class="line"><span class="params">  @bar = 0</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  def <span class="keyword">self</span>.bar</span></span><br><span class="line"><span class="params">    @bar</span></span><br><span class="line"><span class="params">  <span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  def <span class="keyword">self</span>.bar=(value)</span></span><br><span class="line"><span class="params">    @bar = value</span></span><br><span class="line"><span class="params">  <span class="keyword">end</span></span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">class</span> Doctor &lt; Human</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">Human.bar #=&gt; 0</span></span><br><span class="line"><span class="params">Doctor.bar #=&gt; <span class="literal">nil</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">module</span> ModuleExample</span></span><br><span class="line"><span class="params">  def foo</span></span><br><span class="line"><span class="params">    'foo'</span></span><br><span class="line"><span class="params">  <span class="keyword">end</span></span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Including modules binds their methods to the <span class="keyword">class</span> instances.</span></span><br><span class="line"><span class="params"># Extending modules binds their methods to the <span class="keyword">class</span> itself.</span></span><br><span class="line"><span class="params"><span class="keyword">class</span> Person</span></span><br><span class="line"><span class="params">  <span class="keyword">include</span> ModuleExample</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">class</span> Book</span></span><br><span class="line"><span class="params">  extend ModuleExample</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Person.foo     #=&gt; NoMethodError: undefined method `foo' <span class="keyword">for</span> Person:Class</span></span><br><span class="line"><span class="params">Person.new.foo #=&gt; "foo"</span></span><br><span class="line"><span class="params">Book.foo       #=&gt; "foo"</span></span><br><span class="line"><span class="params"># Book.new.foo   #=&gt; NoMethodError: undefined method `foo'</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"># Callbacks are executed <span class="keyword">when</span> including <span class="keyword">and</span> extending a <span class="keyword">module</span></span></span><br><span class="line"><span class="params"><span class="keyword">module</span> ConcernExample</span></span><br><span class="line"><span class="params">  def <span class="keyword">self</span>.included(base)</span></span><br><span class="line"><span class="params">    base.extend(ClassMethods)</span></span><br><span class="line"><span class="params">    base.send(:<span class="keyword">include</span>, InstanceMethods)</span></span><br><span class="line"><span class="params">  <span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  <span class="keyword">module</span> ClassMethods</span></span><br><span class="line"><span class="params">    def bar</span></span><br><span class="line"><span class="params">      'bar'</span></span><br><span class="line"><span class="params">    <span class="keyword">end</span></span></span><br><span class="line"><span class="params">  <span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">  <span class="keyword">module</span> InstanceMethods</span></span><br><span class="line"><span class="params">    def qux</span></span><br><span class="line"><span class="params">      'qux'</span></span><br><span class="line"><span class="params">    <span class="keyword">end</span></span></span><br><span class="line"><span class="params">  <span class="keyword">end</span></span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params"><span class="keyword">class</span> Something</span></span><br><span class="line"><span class="params">  <span class="keyword">include</span> ConcernExample</span></span><br><span class="line"><span class="params"><span class="keyword">end</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">Something.bar     #=&gt; "bar"</span></span><br><span class="line"><span class="params"># Something.qux     #=&gt; NoMethodError: undefined method `qux'</span></span><br><span class="line"><span class="params"># Something.new.bar #=&gt; NoMethodError: undefined method `bar'</span></span><br><span class="line"><span class="params">Something.new.qux #=&gt; "qux"</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Make命令基本教程</title>
    <url>/2021/02/04/Make%E5%91%BD%E4%BB%A4%E5%9F%BA%E6%9C%AC%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>代码变成可执行文件，叫做<a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html" target="_blank" rel="noopener">编译</a>（compile）；先编译这个，还是先编译那个（即编译的安排），叫做<a href="http://en.wikipedia.org/wiki/Software_build" target="_blank" rel="noopener">构建</a>（build）。</p>
<p><a href="http://en.wikipedia.org/wiki/Make_(software" target="_blank" rel="noopener">Make</a>)是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。</p>
</blockquote>
<a id="more"></a>
<p><a href="http://www.ruanyifeng.com/blog/2015/02/make.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/02/make.html</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEAVIM配置</title>
    <url>/2022/02/12/IDEAVIM%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mapleader=<span class="string">","</span></span><br><span class="line"></span><br><span class="line"><span class="string">""</span><span class="comment">" Plugins  --------------------------------</span></span><br><span class="line"><span class="keyword">set</span> surround</span><br><span class="line"><span class="keyword">set</span> multiple-cursors</span><br><span class="line"><span class="keyword">set</span> commentary</span><br><span class="line"><span class="keyword">set</span> argtextobj</span><br><span class="line"><span class="keyword">set</span> easymotion</span><br><span class="line"><span class="keyword">set</span> textobj-entire</span><br><span class="line"><span class="keyword">set</span> ReplaceWithRegister</span><br><span class="line"><span class="keyword">set</span> exchange</span><br><span class="line"><span class="comment">" Trying the new syntax</span></span><br><span class="line">Plug <span class="string">'machakann/vim-highlightedyank'</span></span><br><span class="line"></span><br><span class="line"><span class="string">""</span><span class="comment">" Plugin settings -------------------------</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:argtextobj_pairs</span>=<span class="string">"[:],(:),&lt;:&gt;"</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;C-n&gt;</span> <span class="symbol">&lt;Plug&gt;</span>NextWholeOccurrence</span><br><span class="line"><span class="string">" easy motion"</span></span><br><span class="line"><span class="keyword">map</span> , <span class="symbol">&lt;Plug&gt;</span>(easymotion-prefix)</span><br><span class="line"></span><br><span class="line"><span class="comment">"Turn on case insensitive feature</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:EasyMotion_smartcase</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">"Use upper target labels and type as a lower case</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:EasyMotion_use_upper</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" move to character</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="keyword">f</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-s2)</span><br><span class="line"><span class="keyword">xmap</span> <span class="keyword">f</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-s2)</span><br><span class="line"><span class="keyword">omap</span> <span class="keyword">f</span> <span class="symbol">&lt;Plug&gt;</span>(easymotion-s2)</span><br><span class="line"><span class="comment">" move to word</span></span><br><span class="line"><span class="keyword">nmap</span> F <span class="symbol">&lt;Plug&gt;</span>(easymotion-<span class="keyword">bd</span>-<span class="keyword">w</span>)</span><br><span class="line"><span class="keyword">xmap</span> F <span class="symbol">&lt;Plug&gt;</span>(easymotion-<span class="keyword">bd</span>-<span class="keyword">w</span>)</span><br><span class="line"><span class="keyword">omap</span> F <span class="symbol">&lt;Plug&gt;</span>(easymotion-<span class="keyword">bd</span>-<span class="keyword">w</span>)</span><br><span class="line"><span class="comment">" move to line</span></span><br><span class="line"><span class="comment">" nmap gl &lt;Plug&gt;(easymotion-bd-jk)</span></span><br><span class="line"><span class="comment">" xmap gl &lt;Plug&gt;(easymotion-bd-jk)</span></span><br><span class="line"><span class="comment">" omap gl &lt;Plug&gt;(easymotion-bd-jk)</span></span><br><span class="line"></span><br><span class="line"><span class="string">" acejump"</span></span><br><span class="line"><span class="comment">" Press `f` to activate AceJump</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="keyword">f</span> <span class="symbol">&lt;Action&gt;</span>(AceAction)</span><br><span class="line"><span class="comment">" Press `F` to activate Target Mode</span></span><br><span class="line"><span class="string">" 在 Target 模式下会跳转到目标，并选中目标整个Word"</span></span><br><span class="line"><span class="keyword">nnoremap</span> F <span class="symbol">&lt;Action&gt;</span>(AceTargetAction)</span><br><span class="line"><span class="comment">" Press `g` to activate Line Mode</span></span><br><span class="line"><span class="comment">" nnoremap g &lt;Action&gt;(AceLineAction)</span></span><br><span class="line"></span><br><span class="line"><span class="string">""</span><span class="comment">" Common settings -------------------------</span></span><br><span class="line"><span class="keyword">set</span> showmode</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">so</span>=<span class="number">5</span></span><br><span class="line"><span class="keyword">set</span> incsearch</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">nu</span></span><br><span class="line"></span><br><span class="line"><span class="string">""</span><span class="comment">" Idea specific settings ------------------</span></span><br><span class="line"><span class="keyword">set</span> ideajoin</span><br><span class="line"><span class="keyword">set</span> ideastatusicon=gray</span><br><span class="line"><span class="keyword">set</span> ideaput</span><br><span class="line"><span class="keyword">set</span> ideamarks</span><br><span class="line"><span class="keyword">set</span> clipboard+=unnamed</span><br><span class="line"></span><br><span class="line"><span class="comment">" 通用</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;Leader&gt;</span><span class="keyword">o</span> <span class="symbol">&lt;Action&gt;</span>(RecentProjectListGroup)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;Leader&gt;</span>d <span class="symbol">&lt;Action&gt;</span>(ChooseDebugConfiguration)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;Leader&gt;</span>r <span class="symbol">&lt;Action&gt;</span>(RecentFiles)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;Leader&gt;</span><span class="keyword">w</span> <span class="symbol">&lt;Action&gt;</span>(Switcher)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;Leader&gt;</span>fs <span class="symbol">&lt;Action&gt;</span>(FileStructurePopup)</span><br><span class="line"></span><br><span class="line"><span class="comment">" 窗口管理</span></span><br><span class="line"><span class="comment">" 垂直分割</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Leader&gt;</span>\ <span class="symbol">&lt;C-w&gt;</span>v</span><br><span class="line"><span class="comment">" 水平分割</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;Leader&gt;</span>- <span class="symbol">&lt;C-w&gt;</span>s</span><br><span class="line"><span class="comment">" 切换</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;C-h&gt;</span> <span class="symbol">&lt;C-w&gt;</span>h</span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;C-l&gt;</span> <span class="symbol">&lt;C-w&gt;</span><span class="keyword">l</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;C-j&gt;</span> <span class="symbol">&lt;C-w&gt;</span><span class="keyword">j</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;C-k&gt;</span> <span class="symbol">&lt;C-w&gt;</span><span class="keyword">k</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" 全局跳转</span></span><br><span class="line"><span class="keyword">map</span> gse <span class="symbol">&lt;Action&gt;</span>(SearchEverywhere)</span><br><span class="line"><span class="keyword">map</span> gf <span class="symbol">&lt;Action&gt;</span>(GotoFile)</span><br><span class="line"><span class="keyword">map</span> gm <span class="symbol">&lt;Action&gt;</span>(GotoSymbol)</span><br><span class="line"><span class="keyword">map</span> gcs <span class="symbol">&lt;Action&gt;</span>(GotoClass)</span><br><span class="line"><span class="keyword">map</span> gac <span class="symbol">&lt;Action&gt;</span>(GotoAction)</span><br><span class="line"></span><br><span class="line"><span class="comment">" 文件内部跳转</span></span><br><span class="line"><span class="keyword">map</span> gd <span class="symbol">&lt;Action&gt;</span>(GotoDeclaration)</span><br><span class="line"><span class="keyword">map</span> gs <span class="symbol">&lt;Action&gt;</span>(GotoSuperMethod)</span><br><span class="line"><span class="keyword">map</span> gi <span class="symbol">&lt;Action&gt;</span>(GotoImplementation)</span><br><span class="line"><span class="keyword">map</span> gl <span class="symbol">&lt;Action&gt;</span>(JumpToLastChange)</span><br><span class="line"><span class="keyword">map</span> <span class="keyword">gu</span> <span class="symbol">&lt;Action&gt;</span>(ShowUsages)</span><br><span class="line"><span class="keyword">map</span> gt <span class="symbol">&lt;Action&gt;</span>(GotoTest)</span><br><span class="line"></span><br><span class="line"><span class="comment">" 代码编辑</span></span><br><span class="line"><span class="keyword">map</span> oi <span class="symbol">&lt;Action&gt;</span>(OptimizeImports)</span><br><span class="line"><span class="keyword">map</span> si <span class="symbol">&lt;Action&gt;</span>(ShowIntentionActions)</span><br><span class="line"><span class="keyword">map</span> fc <span class="symbol">&lt;Action&gt;</span>(ReformatCode)</span><br><span class="line"><span class="keyword">map</span> rn <span class="symbol">&lt;Action&gt;</span>(RenameElement)</span><br><span class="line"><span class="keyword">map</span> <span class="keyword">cc</span> <span class="symbol">&lt;Action&gt;</span>(CommentByLineComment)</span><br><span class="line"><span class="keyword">map</span> doc <span class="symbol">&lt;Action&gt;</span>(QuickJavaDoc)</span><br><span class="line"><span class="comment">" Redo</span></span><br><span class="line"><span class="keyword">nnoremap</span> U <span class="symbol">&lt;C-r&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Tab 管理</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;space&gt;</span>h gT</span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;space&gt;</span><span class="keyword">l</span> gt</span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;c-s-tab&gt;</span> gT</span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;c-tab&gt;</span> gt</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;space&gt;</span>q <span class="symbol">&lt;Action&gt;</span>(CloseContent)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;space&gt;</span><span class="keyword">w</span> <span class="symbol">&lt;Action&gt;</span>(CloseAllEditorsButActive)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;space&gt;</span>Q <span class="symbol">&lt;Action&gt;</span>(ReopenClosedTab)</span><br><span class="line"></span><br><span class="line"><span class="comment">" 搜索</span></span><br><span class="line"><span class="keyword">map</span> <span class="keyword">e</span>/ <span class="symbol">&lt;Action&gt;</span>(Find)</span><br><span class="line"><span class="keyword">map</span> g/ <span class="symbol">&lt;Action&gt;</span>(FindInPath)</span><br><span class="line"><span class="keyword">map</span> <span class="string">' &lt;Action&gt;(Replace)</span></span><br><span class="line"><span class="string">map g'</span> <span class="symbol">&lt;Action&gt;</span>(ReplaceInPath)</span><br><span class="line"></span><br><span class="line"><span class="comment">" 运行和调试</span></span><br><span class="line"><span class="keyword">map</span> \r <span class="symbol">&lt;Action&gt;</span>(RunClass)</span><br><span class="line"><span class="keyword">map</span> \R <span class="symbol">&lt;Action&gt;</span>(Run)</span><br><span class="line"><span class="keyword">map</span> \d <span class="symbol">&lt;Action&gt;</span>(DebugClass)</span><br><span class="line"><span class="keyword">map</span> \D <span class="symbol">&lt;Action&gt;</span>(Debug)</span><br><span class="line"><span class="keyword">map</span> \<span class="keyword">c</span> <span class="symbol">&lt;Action&gt;</span>(CheckStyleCurrentFileAction)</span><br><span class="line"></span><br><span class="line"><span class="comment">" 调试控制</span></span><br><span class="line"><span class="keyword">map</span> Di <span class="symbol">&lt;Action&gt;</span>(StepInto)</span><br><span class="line"><span class="keyword">map</span> Dn <span class="symbol">&lt;Action&gt;</span>(StepOver)</span><br><span class="line"><span class="keyword">map</span> Dr <span class="symbol">&lt;Action&gt;</span>(Resume)</span><br><span class="line"><span class="keyword">map</span> Do <span class="symbol">&lt;Action&gt;</span>(StepOut)</span><br><span class="line"><span class="keyword">map</span> Db <span class="symbol">&lt;Action&gt;</span>(ToggleLineBreakpoint)</span><br><span class="line"></span><br><span class="line"><span class="comment">" 移动查找</span></span><br><span class="line"><span class="keyword">nnoremap</span> [<span class="symbol">&lt;space&gt;</span> O<span class="symbol">&lt;esc&gt;</span><span class="keyword">j</span></span><br><span class="line"><span class="keyword">nnoremap</span> ]<span class="symbol">&lt;space&gt;</span> <span class="keyword">o</span><span class="symbol">&lt;esc&gt;</span><span class="keyword">k</span></span><br><span class="line"><span class="keyword">map</span> [q <span class="symbol">&lt;Action&gt;</span>(PreviousOccurrence)</span><br><span class="line"><span class="keyword">map</span> ]q <span class="symbol">&lt;Action&gt;</span>(NextOccurrence)</span><br><span class="line"><span class="keyword">map</span> [<span class="keyword">m</span> <span class="symbol">&lt;Action&gt;</span>(MethodUp)</span><br><span class="line"><span class="keyword">map</span> ]<span class="keyword">m</span> <span class="symbol">&lt;Action&gt;</span>(MethodDown)</span><br><span class="line"><span class="keyword">map</span> [<span class="keyword">c</span> <span class="symbol">&lt;Action&gt;</span>(VcsShowPrevChangeMarker)</span><br><span class="line"><span class="keyword">map</span> ]<span class="keyword">c</span> <span class="symbol">&lt;Action&gt;</span>(VcsShowNextChangeMarker)</span><br><span class="line"></span><br><span class="line"><span class="comment">" 其他选项</span></span><br><span class="line"><span class="keyword">map</span> cow <span class="symbol">&lt;Action&gt;</span>(EditorToggleUseSoftWraps)</span><br><span class="line"><span class="keyword">map</span> <span class="keyword">col</span> <span class="symbol">&lt;Action&gt;</span>(EditorToggleShowWhitespaces)</span><br><span class="line"><span class="keyword">map</span> <span class="keyword">ta</span> <span class="symbol">&lt;Action&gt;</span>(Annotate)</span><br><span class="line"><span class="keyword">map</span> tb <span class="symbol">&lt;Action&gt;</span>(ToggleLineBreakpoint)</span><br><span class="line"><span class="keyword">map</span> <span class="keyword">tm</span> <span class="symbol">&lt;Action&gt;</span>(ToggleBookmark)</span><br><span class="line"><span class="keyword">map</span> ap <span class="symbol">&lt;Action&gt;</span>(ActivateProjectToolWindow)</span><br><span class="line"><span class="keyword">map</span> <span class="keyword">up</span> <span class="symbol">&lt;Action&gt;</span>(ShowUmlDiagramPopup)</span><br><span class="line"><span class="keyword">map</span> haw <span class="symbol">&lt;Action&gt;</span>(HideAllWindows)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;space&gt;</span>\ <span class="symbol">&lt;Action&gt;</span>(VimFilePrevious)</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;space&gt;</span><span class="keyword">k</span> <span class="symbol">&lt;Action&gt;</span>(HighlightUsagesInFile)</span><br><span class="line"></span><br><span class="line"><span class="comment">" built-in navigation to navigated items works better</span></span><br><span class="line"><span class="comment">" map &lt;c-o&gt; &lt;Action&gt;(Back)</span></span><br><span class="line"><span class="comment">" map &lt;c-i&gt; &lt;Action&gt;(Forward)</span></span><br><span class="line"><span class="comment">" but preserve ideavim defaults</span></span><br><span class="line"><span class="keyword">nnoremap</span> g<span class="symbol">&lt;c-o&gt;</span> <span class="symbol">&lt;c-o&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> g<span class="symbol">&lt;c-i&gt;</span> <span class="symbol">&lt;c-i&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" multiple cursors</span></span><br><span class="line"><span class="comment">" &lt;A-n&gt;, &lt;A-n&gt;, &lt;A-p&gt;, g&lt;A-n&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
